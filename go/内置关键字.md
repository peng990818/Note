



# 内置关键字

## 1、defer

延迟语句，defer的语义表明，它会在函数返回、产生恐慌或者runtime.Goexit时被调用。<span style='color:red'>直觉上看，defer应该由编译器直接将需要的函数调用插入到该调用的地方，似乎是一个编译期特性，不应该存在运行时性能问题，非常类似于C++的RALL范式（当离开资源的作用域，自动执行析构函数）。但实际情况是，由于defer并没有与其依赖资源挂钩，也允许在条件、循环语句中出现，从而不再是一个作用域相关的概念，这就使得defer的语义变得相对复杂。在一些复杂情况下，无法在编译期决定有多少个defer调用。</span>

Go语言的语句在执行buildssa阶段中，会由state.stmt完成函数中各个语句SSA处理。

对于延迟语句而言，其中间表示会产生三种不同的延迟形式，第一种是最一般情况下的在堆上分配的延迟语句，第二种是允许在栈上分配的延迟语句，最后一种则是开放式编码的延迟语句。

- 堆上分配的延迟语句：在大多数情况下，defer语句会在堆上分配，以确保延迟函数在函数返回之前被正确调用。堆上分配的优点是灵活性高，但也会带来一定的性能开销，因为堆分配需要内存管理操作。堆上分配的defer需要最多的运行时支持，因而产生的运行时开销也最大。
- 栈上分配的延迟语句：在某些情况下，defer语句可以在栈上分配，从而减少堆分配的开销。栈上分配的延迟语句通常用于简单的函数调用，不涉及复杂的闭包捕获，栈上分配的延迟语句执行速度快，因为它们避免了堆分配和垃圾收集的开销。
- 开放式编码的延迟语句：这是一种编译器优化技术，编译器在生成代码时，会将延迟函数直接嵌入到返回路径中，从而避免了堆栈分配，这种方式适用于那些不需要复杂延迟函数的场景，提高了性能 ，但限制了延迟函数的灵活性。

编译阶段

```go
// src/cmd/compile/internal/gc/ssa.go
func buildssa(fn *Node, worker int) *ssa.Func {
	var s state
	...
	s.stmtList(fn.Nbody)
	...
}
func (s *state) stmtList(l Nodes) {
	for _, n := range l.Slice() { s.stmt(n) }
}
```

```go
// src/cmd/compile/internal/gc/ssa.go
func (s *state) stmt(n *Node) {
	...
	switch n.Op {
	case ODEFER:
		n := n.(*ir.GoDeferStmt)
        if base.Debug.Defer > 0 {
            // defer函数类型
            var defertype string
            if s.hasOpenDefers {
                // 开放编码式 defer
                defertype = "open-coded"
            } else if n.Esc() == ir.EscNever {
                // 栈上分配的defer
                defertype = "stack-allocated"
            } else {
                // 堆上分配的defer
                defertype = "heap-allocated"
            }
            base.WarnfAt(n.Pos(), "%s defer", defertype)
        }
        // 执行函数结束时需要执行所记录的defer代码块
        if s.hasOpenDefers {
            // 开放式编码处理
            s.openDeferRecord(n.Call.(*ir.CallExpr))
        } else {
            // 默认堆分配
            d := callDefer
            // 逃逸分析，成功采用栈分配
            // defer在循环嵌套里会分配在堆上
            if n.Esc() == ir.EscNever {
                d = callDeferStack
            }
            s.callResult(n.Call.(*ir.CallExpr), d)
        }
	case ...
	}
	...
}
```

state.call调用会生成用于记录延迟调用参数的指令，并创建一个deferproc的调用指令，而后在state.exit调用在函数返回前插入deferreturn调用指令。

```go
// src/cmd/compile/internal/ssagen/ssa.go
// Calls the function n using the specified call type.
// Returns the address of the return value (or nil if none).
// 用于处理函数调用的方法，包括普通调用、尾调用、defer调用和go调用
func (s *state) call(n *ir.CallExpr, k callKind, returnResultAddr bool) *ssa.Value {
    s.prevCall = nil
    var callee *ir.Name    // target function (if static) 调用目标
    var closure *ssa.Value // ptr to closure to run (if dynamic) 闭包
    var codeptr *ssa.Value // ptr to target code (if dynamic) 代码指针
    var rcvr *ssa.Value    // receiver to set 接收者
    fn := n.X
    var ACArgs []*types.Type    // AuxCall args 辅助调用的参数类型
    var ACResults []*types.Type // AuxCall results 辅助调用的结果类型
    var callArgs []*ssa.Value   // For late-expansion, the args themselves (not stored, args to the call instead).

    callABI := s.f.ABIDefault

    // 如果调用类型不是普通调用或尾调用，并且有参数或是接口调用或有返回结果，则报错。
    if k != callNormal && k != callTail && (len(n.Args) != 0 || n.Op() == ir.OCALLINTER || n.X.Type().NumResults() != 0) {
        s.Fatalf("go/defer call with arguments: %v", n)
    }

    switch n.Op() {
    case ir.OCALLFUNC:
        // 静态调用，直接获取目标函数
        if (k == callNormal || k == callTail) && fn.Op() == ir.ONAME && fn.(*ir.Name).Class == ir.PFUNC {
            fn := fn.(*ir.Name)
            callee = fn
            if buildcfg.Experiment.RegabiArgs {
                // This is a static call, so it may be
                // a direct call to a non-ABIInternal
                // function. fn.Func may be nil for
                // some compiler-generated functions,
                // but those are all ABIInternal.
                if fn.Func != nil {
                    callABI = abiForFunc(fn.Func, s.f.ABI0, s.f.ABI1)
                }
            } else {
                // TODO(register args) remove after register abi is working
                inRegistersImported := fn.Pragma()&ir.RegisterParams != 0
                inRegistersSamePackage := fn.Func != nil && fn.Func.Pragma&ir.RegisterParams != 0
                if inRegistersImported || inRegistersSamePackage {
                    callABI = s.f.ABI1
                }
            }
            break
        }
        // 动态调用，获取闭包
        closure = s.expr(fn)
        if k != callDefer && k != callDeferStack {
            // Deferred nil function needs to panic when the function is invoked,
            // not the point of defer statement.
            s.maybeNilCheckClosure(closure, k)
        }
    case ir.OCALLINTER:
        // 接口调用，获取闭包和接收者
        if fn.Op() != ir.ODOTINTER {
            s.Fatalf("OCALLINTER: n.Left not an ODOTINTER: %v", fn.Op())
        }
        fn := fn.(*ir.SelectorExpr)
        var iclosure *ssa.Value
        iclosure, rcvr = s.getClosureAndRcvr(fn)
        if k == callNormal {
            codeptr = s.load(types.Types[types.TUINTPTR], iclosure)
        } else {
            closure = iclosure
        }
    }

    // 计算参数和结果的大小
    params := callABI.ABIAnalyze(n.X.Type(), false /* Do not set (register) nNames from caller side -- can cause races. */)
    types.CalcSize(fn.Type())
    stksize := params.ArgWidth() // includes receiver, args, and results

    res := n.X.Type().Results()
    if k == callNormal || k == callTail {
        for _, p := range params.OutParams() {
            ACResults = append(ACResults, p.Type)
        }
    }

    var call *ssa.Value
    if k == callDeferStack {
        // 栈上的defer
        // Make a defer struct d on the stack.
        if stksize != 0 {
            s.Fatalf("deferprocStack with non-zero stack size %d: %v", stksize, n)
        }

        t := deferstruct() // 创建defer结构
        d := typecheck.TempAt(n.Pos(), s.curfn, t)

        // 如果这个defer结构体包含指针，记录该变量的内存状态
        if t.HasPointers() {
            s.vars[memVar] = s.newValue1A(ssa.OpVarDef, types.TypeMem, d, s.mem())
        }
        // 获取defer结构体的地址
        addr := s.addr(d)

        // 在栈上预留_defer结构体各个字段的空间
        // Must match deferstruct() below and src/runtime/runtime2.go:_defer.
        // 0: started, set in deferprocStack
        // 1: heap, set in deferprocStack
        // 2: openDefer
        // 3: sp, set in deferprocStack
        // 4: pc, set in deferprocStack
        // 5: fn
        // 均采用闭包类型
        s.store(closure.Type,
            s.newValue1I(ssa.OpOffPtr, closure.Type.PtrTo(), t.FieldOff(5), addr),
            closure)
        // 6: panic, set in deferprocStack
        // 7: link, set in deferprocStack
        // 8: fd
        // 9: varp
        // 10: framepc

        // Call runtime.deferprocStack with pointer to _defer record.
        // 创建deferprocStack调用，传递 _defer 记录的指针，记录到协程栈中
        ACArgs = append(ACArgs, types.Types[types.TUINTPTR])
        aux := ssa.StaticAuxCall(ir.Syms.DeferprocStack, s.f.ABIDefault.ABIAnalyzeTypes(nil, ACArgs, ACResults))
        callArgs = append(callArgs, addr, s.mem())
        call = s.newValue0A(ssa.OpStaticLECall, aux.LateExpansionResultType(), aux)
        call.AddArgs(callArgs...)
        call.AuxInt = int64(types.PtrSize) // deferprocStack takes a *_defer arg
    } else {
        // Store arguments to stack, including defer/go arguments and receiver for method calls.
        // These are written in SP-offset order.
        argStart := base.Ctxt.Arch.FixedFrameSize
        // Defer/go args.
        // defer和go均涉及闭包
        if k != callNormal && k != callTail {
            // Write closure (arg to newproc/deferproc).
            // 把闭包函数写入newproc或deferproc中
            ACArgs = append(ACArgs, types.Types[types.TUINTPTR]) // not argExtra
            callArgs = append(callArgs, closure)
            stksize += int64(types.PtrSize)
            argStart += int64(types.PtrSize)
        }

        // Set receiver (for interface calls).
        if rcvr != nil {
            callArgs = append(callArgs, rcvr)
        }

        // Write args.
        t := n.X.Type()
        args := n.Args

        for _, p := range params.InParams() { // includes receiver for interface calls
            ACArgs = append(ACArgs, p.Type)
        }

        // Split the entry block if there are open defers, because later calls to
        // openDeferSave may cause a mismatch between the mem for an OpDereference
        // and the call site which uses it. See #49282.
        if s.curBlock.ID == s.f.Entry.ID && s.hasOpenDefers {
            b := s.endBlock()
            b.Kind = ssa.BlockPlain
            curb := s.f.NewBlock(ssa.BlockPlain)
            b.AddEdgeTo(curb)
            s.startBlock(curb)
        }

        // 放入参数
        for i, n := range args {
            callArgs = append(callArgs, s.putArg(n, t.Params().Field(i).Type))
        }

        callArgs = append(callArgs, s.mem())

        // call target
        switch {
        case k == callDefer:
            // 创建deferproc调用，记录到堆中
            aux := ssa.StaticAuxCall(ir.Syms.Deferproc, s.f.ABIDefault.ABIAnalyzeTypes(nil, ACArgs, ACResults)) // TODO paramResultInfo for DeferProc
            call = s.newValue0A(ssa.OpStaticLECall, aux.LateExpansionResultType(), aux)
        case k == callGo:
            aux := ssa.StaticAuxCall(ir.Syms.Newproc, s.f.ABIDefault.ABIAnalyzeTypes(nil, ACArgs, ACResults))
            call = s.newValue0A(ssa.OpStaticLECall, aux.LateExpansionResultType(), aux) // TODO paramResultInfo for NewProc
        case closure != nil:
            // rawLoad because loading the code pointer from a
            // closure is always safe, but IsSanitizerSafeAddr
            // can't always figure that out currently, and it's
            // critical that we not clobber any arguments already
            // stored onto the stack.
            codeptr = s.rawLoad(types.Types[types.TUINTPTR], closure)
            aux := ssa.ClosureAuxCall(callABI.ABIAnalyzeTypes(nil, ACArgs, ACResults))
            call = s.newValue2A(ssa.OpClosureLECall, aux.LateExpansionResultType(), aux, codeptr, closure)
        case codeptr != nil:
            // Note that the "receiver" parameter is nil because the actual receiver is the first input parameter.
            aux := ssa.InterfaceAuxCall(params)
            call = s.newValue1A(ssa.OpInterLECall, aux.LateExpansionResultType(), aux, codeptr)
        case callee != nil:
            aux := ssa.StaticAuxCall(callTargetLSym(callee), params)
            call = s.newValue0A(ssa.OpStaticLECall, aux.LateExpansionResultType(), aux)
            if k == callTail {
                call.Op = ssa.OpTailLECall
                stksize = 0 // Tail call does not use stack. We reuse caller's frame.
            }
        default:
            s.Fatalf("bad call type %v %v", n.Op(), n)
        }
        // 追加调用参数
        call.AddArgs(callArgs...)
        call.AuxInt = stksize // Call operations carry the argsize of the callee along with them
    }
    // 结束处理
    s.prevCall = call
    s.vars[memVar] = s.newValue1I(ssa.OpSelectN, types.TypeMem, int64(len(ACResults)), call)
    // Insert VarLive opcodes.
    for _, v := range n.KeepAlive {
        if !v.Addrtaken() {
            s.Fatalf("KeepAlive variable %v must have Addrtaken set", v)
        }
        switch v.Class {
        case ir.PAUTO, ir.PPARAM, ir.PPARAMOUT:
        default:
            s.Fatalf("KeepAlive variable %v must be Auto or Arg", v)
        }
        s.vars[memVar] = s.newValue1A(ssa.OpVarLive, types.TypeMem, v, s.mem())
    }

    // Finish block for defers
    // 结束defer块
    if k == callDefer || k == callDeferStack {
        b := s.endBlock()
        b.Kind = ssa.BlockDefer
        b.SetControl(call)
        bNext := s.f.NewBlock(ssa.BlockPlain)
        b.AddEdgeTo(bNext)
        // Add recover edge to exit code.
        r := s.f.NewBlock(ssa.BlockPlain)
        s.startBlock(r)
        s.exit()
        b.AddEdgeTo(r)
        b.Likely = ssa.BranchLikely
        s.startBlock(bNext)
    }

    // 检查返回值
    if res.NumFields() == 0 || k != callNormal {
        // call has no return value. Continue with the next statement.
        // 没有返回值或者调用类型不是普通调用，返回nil
        return nil
    }
    fp := res.Field(0)
    // 判断是返回地址还是直接返回结果
    if returnResultAddr {
        // 返回结果地址
        return s.resultAddrOfCall(call, 0, fp.Type)
    }
    // 创建一个选择节点，返回结果
    return s.newValue1I(ssa.OpSelectN, fp.Type, 0, call)
}
```

在编译的SSA阶段会翻译成两个主体。

​	deferproc：一个运行时函数，用于注册一个defer调用，当代码中使用defer语句时，Go编译器会生成对deferproc的调用，deferproc会将defer语句的调用信息保存在当前goroutine的栈中，以便在函数返回时执行这些defer语句。

​	deferreturn：也是一个运行时函数，在函数返回时被调用，以执行所有已注册的defer调用，每个注册的defer调用都会被依次执行，按照后进先出的顺序。

defer结构：

```go
// A _defer holds an entry on the list of deferred calls.
// If you add a field here, add code to clear it in deferProcStack.
// This struct must match the code in cmd/compile/internal/ssagen/ssa.go:deferstruct
// and cmd/compile/internal/ssagen/ssa.go:(*state).call.
// Some defers will be allocated on the stack and some on the heap.
// All defers are logically part of the stack, so write barriers to
// initialize them are not required. All defers must be manually scanned,
// and for heap defers, marked.
// 该结构保存延迟调用列表中的一个条目
type _defer struct {
    started bool // 两种情况会为true：panic或退出协程
    heap    bool // 堆或非堆
    // openDefer indicates that this _defer is for a frame with open-coded
    // defers. We have only one defer record for the entire frame (which may
    // currently have 0, 1, or more defers active).
    openDefer bool    // 开放代码优化
    sp        uintptr // sp at time of defer 栈指针
    pc        uintptr // pc at time of defer 程序计数器
    fn        func()  // can be nil for open-coded defers 要执行的函数（闭包形式）
    _panic    *_panic // panic that is running defer 正在运行的defer的panic
    link      *_defer // next defer on G; can point to either heap or stack! 链表指针，指向下一个defer

    // If openDefer is true, the fields below record values about the stack
    // frame and associated function that has the open-coded defer(s). sp
    // above will be the sp for the frame, and pc will be address of the
    // deferreturn call in the function.
    fd   unsafe.Pointer // funcdata for the function associated with the frame
    varp uintptr        // value of varp for the stack frame
    // framepc is the current pc associated with the stack frame. Together,
    // with sp above (which is the sp associated with the stack frame),
    // framepc/sp can be used as pc/sp pair to continue a stack trace via
    // gentraceback().
    framepc uintptr // 栈帧指针
}
```

![img](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/confluenceImport/9169811946972288116/confluenceIMG/46530617/49643543.png)

```go
// src/runtime/panic.go
// 主要用于堆中分配的延迟函数
// 将被defer调用的函数做一次记录
// Create a new deferred function fn, which has no arguments and results.
// The compiler turns a defer statement into a call to this.
func deferproc(fn func()) {
    gp := getg()
    if gp.m.curg != gp {
        // go code on the system stack can't defer
        throw("defer on system stack")
    }

    d := newdefer()
    if d._panic != nil {
        throw("deferproc: d.panic != nil after newdefer")
    }
    // 头添加
    d.link = gp._defer
    gp._defer = d
    // 保存调用该defer的goroutine的上下文
    d.fn = fn
    d.pc = getcallerpc()
    // We must not be preempted between calling getcallersp and
    // storing it to d.sp because getcallersp's result is a
    // uintptr stack pointer.
    d.sp = getcallersp()

    // deferproc returns 0 normally.
    // a deferred func that stops a panic
    // makes the deferproc return 1.
    // the code the compiler generates always
    // checks the return value and jumps to the
    // end of the function if deferproc returns != 0.
    return0()
    // No code can go here - the C return register has
    // been set and must not be clobbered.
}
```

```go
// 将新的延迟函数和相关记录记录在栈中，主要用于栈中分配的延迟函数
// deferprocStack queues a new deferred function with a defer record on the stack.
// The defer record must have its fn field initialized.
// All other fields can contain junk.
// Nosplit because of the uninitialized pointer fields on the stack.
//
//go:nosplit
func deferprocStack(d *_defer) {
    gp := getg()
    if gp.m.curg != gp {
        // go code on the system stack can't defer
        throw("defer on system stack")
    }
    // fn is already set.
    // The other fields are junk on entry to deferprocStack and
    // are initialized here.
    d.started = false
    d.heap = false
    d.openDefer = false
    d.sp = getcallersp()
    d.pc = getcallerpc()
    d.framepc = 0
    d.varp = 0
    // The lines below implement:
    //   d.panic = nil
    //   d.fd = nil
    //   d.link = gp._defer
    //   gp._defer = d
    // But without write barriers. The first three are writes to
    // the stack so they don't need a write barrier, and furthermore
    // are to uninitialized memory, so they must not use a write barrier.
    // The fourth write does not require a write barrier because we
    // explicitly mark all the defer structures, so we don't need to
    // keep track of pointers to them with a write barrier.
  	// 尽管在栈上分配，并串联链表
    *(*uintptr)(unsafe.Pointer(&d._panic)) = 0
    *(*uintptr)(unsafe.Pointer(&d.fd)) = 0
    *(*uintptr)(unsafe.Pointer(&d.link)) = uintptr(unsafe.Pointer(gp._defer))
    *(*uintptr)(unsafe.Pointer(&gp._defer)) = uintptr(unsafe.Pointer(d))

    return0()
    // No code can go here - the C return register has
    // been set and must not be clobbered.
}
```

```go
// Allocate a Defer, usually using per-P pool.
// Each defer must be released with freedefer.  The defer is not
// added to any defer chain yet.
// 在性能上，通过P或者调度器上的本地或全局defer池来复用已经在堆上分配的内存
func newdefer() *_defer {
    var d *_defer
    mp := acquirem()
    pp := mp.p.ptr()
    // p的池中没有，调度器还有，就从调度器获取
    if len(pp.deferpool) == 0 && sched.deferpool != nil {
        lock(&sched.deferlock)
        // 从全局池中获取一半defer，来填充p的本地资源
        for len(pp.deferpool) < cap(pp.deferpool)/2 && sched.deferpool != nil {
            d := sched.deferpool
            sched.deferpool = d.link
            d.link = nil
            pp.deferpool = append(pp.deferpool, d)
        }
        unlock(&sched.deferlock)
    }
    // P中有，那就直接取一个
    if n := len(pp.deferpool); n > 0 {
        d = pp.deferpool[n-1]
        pp.deferpool[n-1] = nil
        pp.deferpool = pp.deferpool[:n-1]
    }
    releasem(mp)
    mp, pp = nil, nil

    // 没有可用的缓存，直接从堆上分配
    if d == nil {
        // Allocate new defer.
        d = new(_defer)
    }
    d.heap = true
    return d
}

// 释放_defer结构体
// Free the given defer.
// The defer cannot be used after this call.
//
// This is nosplit because the incoming defer is in a perilous state.
// It's not on any defer list, so stack copying won't adjust stack
// pointers in it (namely, d.link). Hence, if we were to copy the
// stack, d could then contain a stale pointer.
//
//go:nosplit
func freedefer(d *_defer) {
    d.link = nil
    // After this point we can copy the stack.

    if d._panic != nil {
        freedeferpanic()
    }
    if d.fn != nil {
        freedeferfn()
    }
    // 不在堆上直接返回，清空栈
    if !d.heap {
        return
    }

    mp := acquirem()
    pp := mp.p.ptr()
    if len(pp.deferpool) == cap(pp.deferpool) {
        // Transfer half of local cache to the central cache.
        // 将一半的本地池存到全局
        var first, last *_defer
        for len(pp.deferpool) > cap(pp.deferpool)/2 {
            n := len(pp.deferpool)
            d := pp.deferpool[n-1]
            pp.deferpool[n-1] = nil
            pp.deferpool = pp.deferpool[:n-1]
            if first == nil {
                first = d
            } else {
                last.link = d
            }
            last = d
        }
        lock(&sched.deferlock)
        last.link = sched.deferpool
        sched.deferpool = first
        unlock(&sched.deferlock)
    }

    *d = _defer{}

    pp.deferpool = append(pp.deferpool, d)

    releasem(mp)
    mp, pp = nil, nil
}
```

deferreturn被编译器插入到函数末尾，当跳转到它时，会将需要被defer的入口地址取出，然后跳转并执行：

```go
// src/cmd/compile/internal/ssagen/ssa.go
// exit processes any code that needs to be generated just before returning.
// It returns a BlockRet block that ends the control flow. Its control value
// will be set to the final memory state.
// 函数返回前的一些操作
func (s *state) exit() *ssa.Block {
    // 调用defer
    if s.hasdefer {
        if s.hasOpenDefers {
            if shareDeferExits && s.lastDeferExit != nil && len(s.openDefers) == s.lastDeferCount {
                if s.curBlock.Kind != ssa.BlockPlain {
                    panic("Block for an exit should be BlockPlain")
                }
                s.curBlock.AddEdgeTo(s.lastDeferExit)
                s.endBlock()
                return s.lastDeferFinalBlock
            }
            s.openDeferExit()
        } else {
            // 调用deferreturn
            s.rtcall(ir.Syms.Deferreturn, true, nil)
        }
    }

    var b *ssa.Block
    var m *ssa.Value
    // Do actual return.
    // These currently turn into self-copies (in many cases).
    resultFields := s.curfn.Type().Results().FieldSlice()
    results := make([]*ssa.Value, len(resultFields)+1, len(resultFields)+1)
    m = s.newValue0(ssa.OpMakeResult, s.f.OwnAux.LateExpansionResultType())
    // Store SSAable and heap-escaped PPARAMOUT variables back to stack locations.
    for i, f := range resultFields {
        n := f.Nname.(*ir.Name)
        if s.canSSA(n) { // result is in some SSA variable
            if !n.IsOutputParamInRegisters() && n.Type().HasPointers() {
                // We are about to store to the result slot.
                s.vars[memVar] = s.newValue1A(ssa.OpVarDef, types.TypeMem, n, s.mem())
            }
            results[i] = s.variable(n, n.Type())
        } else if !n.OnStack() { // result is actually heap allocated
            // We are about to copy the in-heap result to the result slot.
            if n.Type().HasPointers() {
                s.vars[memVar] = s.newValue1A(ssa.OpVarDef, types.TypeMem, n, s.mem())
            }
            ha := s.expr(n.Heapaddr)
            s.instrumentFields(n.Type(), ha, instrumentRead)
            results[i] = s.newValue2(ssa.OpDereference, n.Type(), ha, s.mem())
        } else { // result is not SSA-able; not escaped, so not on heap, but too large for SSA.
            // Before register ABI this ought to be a self-move, home=dest,
            // With register ABI, it's still a self-move if parameter is on stack (i.e., too big or overflowed)
            // No VarDef, as the result slot is already holding live value.
            results[i] = s.newValue2(ssa.OpDereference, n.Type(), s.addr(n), s.mem())
        }
    }

    // Run exit code. Today, this is just racefuncexit, in -race mode.
    // TODO(register args) this seems risky here with a register-ABI, but not clear it is right to do it earlier either.
    // Spills in register allocation might just fix it.
    s.stmtList(s.curfn.Exit)

    results[len(results)-1] = s.mem()
    m.AddArgs(results...)

    b = s.endBlock()
    b.Kind = ssa.BlockRet
    b.SetControl(m)
    if s.hasdefer && s.hasOpenDefers {
        s.lastDeferFinalBlock = b
    }
    return b
}

// deferreturn runs deferred functions for the caller's frame.
// The compiler inserts a call to this at the end of any
// function which calls defer.
func deferreturn() {
    gp := getg()
    for {
        d := gp._defer
        if d == nil {
            return
        }
        // 确定defer的调用方是不是当前deferreturn的调用方
        sp := getcallersp()
        if d.sp != sp {
            return
        }
        // 是否是开放编码
        if d.openDefer {
            done := runOpenDeferFrame(d)
            if !done {
                throw("unfinished open-coded defers in deferreturn")
            }
            gp._defer = d.link
            freedefer(d)
            // If this frame uses open defers, then this
            // must be the only defer record for the
            // frame, so we can just return.
            return
        }

        // 获得被延迟调用的函数fn的入口地址，将_defer结构体释放掉
      	// 闭包函数指针
        fn := d.fn
        d.fn = nil
        gp._defer = d.link
        freedefer(d)
        // 执行
        fn()
    }
}
```

开放式编码defer

在函数末尾直接对延迟函数进行调用，不需要额外开销。

```go
// src/cmd/compile/internal/ssagen/ssa.go

// 开放式编码defer条件判断
    // 1、没有禁用编译优化选项，即没有设置 -gcflags "-N"
    // 2、存在defer调用
    // 3、当前函数是否允许开放式编码
    s.hasOpenDefers = base.Flag.N == 0 && s.hasdefer && !s.curfn.OpenCodedDeferDisallowed()
    switch {
    case base.Debug.NoOpenDefer != 0:
        // 4、debug选项没有禁用
        s.hasOpenDefers = false
    case s.hasOpenDefers && (base.Ctxt.Flag_shared || base.Ctxt.Flag_dynlink) && base.Ctxt.Arch.Name == "386":
        // Don't support open-coded defers for 386 ONLY when using shared
        // libraries, because there is extra code (added by rewriteToUseGot())
        // preceding the deferreturn/ret code that we don't track correctly.
        // 5、386架构，如果使用共享库或动态链接，则禁用开放编码的defer。在这种情况下，前置代码会干扰deferreturn/ret代码段
        s.hasOpenDefers = false
    }
    if s.hasOpenDefers && len(s.curfn.Exit) > 0 {
        // Skip doing open defers if there is any extra exit code (likely
        // race detection), since we will not generate that code in the
        // case of the extra deferreturn/ret segment.
        // 6、如果当前函数有额外的退出代码（可能是静态检测），则禁用开放编码的defer，这些代码不会在deferreturn/ret段中生成
        s.hasOpenDefers = false
    }
    if s.hasOpenDefers {
        // Similarly, skip if there are any heap-allocated result
        // parameters that need to be copied back to their stack slots.
        // 有任何需要从堆复制回栈的结果参数，则禁用开放编码
        for _, f := range s.curfn.Type().Results().FieldSlice() {
            if !f.Nname.(*ir.Name).OnStack() {
                s.hasOpenDefers = false
                break
            }
        }
    }
    if s.hasOpenDefers &&
        s.curfn.NumReturns*s.curfn.NumDefers > 15 {
        // Since we are generating defer calls at every exit for
        // open-coded defers, skip doing open-coded defers if there are
        // too many returns (especially if there are multiple defers).
        // Open-coded defers are most important for improving performance
        // for smaller functions (which don't have many returns).
        // 如果返回语句和defer语句的数量乘积超过15，则禁用开放编码的defer。
        // 因为在每个退出点生成defer调用，对于有大量返回点的函数来说会增加开销
        // 开放编码更适用于较小的函数。
        s.hasOpenDefers = false
    }
```

```go
// src/cmd/compile/internal/walk/stmt.go
func walkStmt(n ir.Node) ir.Node {
	switch n.Op() {
	case ir.ODEFER:
        n := n.(*ir.GoDeferStmt)
        ir.CurFunc.SetHasDefer(true)
        ir.CurFunc.NumDefers++
        if ir.CurFunc.NumDefers > maxOpenDefers {
            // Don't allow open-coded defers if there are more than
            // 8 defers in the function, since we use a single
            // byte to record active defers.
            // 超过 8 个 defer 时，禁用对 defer 进行开放编码
            ir.CurFunc.SetOpenCodedDeferDisallowed(true)
        }
        // 存在循环语句中的 defer，禁用对 defer 进行开放编码。
        // 是否有 defer 发生在循环语句内，会在 SSA 之前的逃逸分析中进行判断，
        // 逃逸分析会检查是否存在循环（loopDepth）：
        // if where.Op == ODEFER && e.loopDepth == 1 {
        // 	where.Esc = EscNever
        // 	...
        // }
        if n.Esc() != ir.EscNever {
            // If n.Esc is not EscNever, then this defer occurs in a loop,
            // so open-coded defers cannot be used in this function.
            ir.CurFunc.SetOpenCodedDeferDisallowed(true)
        }
        fallthrough
	}
}
```



正常编写的defer可以直接被编译器分析得出，但在开放编码defer中，需要在编译期完全确定，而不能依靠运行时，这个时候需要引入延迟比特。

比如在条件语句中，需要在编译期确定在条件成立时被正确执行，这就需要一种机制，能够记录存在延迟语句的条件分支是否被执行，这种机制在Go中叫做延迟比特。

在创建延迟调用阶段，首先通过延迟比特的特定位置记录哪些带条件的defer被触发。这个延迟比特是一个长度为8位的二进制码，<span style='color:red'>因为开放编码的defer最多允许8个，以每一位是否被设置为1，来判断延迟语句是否在运行时被设置，如果设置，则发生调用。</span>

1）创建一个长度为8位的临时变量

```go
// src/cmd/compile/internal/ssagen/ssa.go
func buildssa(fn *Node, worker int) *ssa.Func {
	...
	if s.hasOpenDefers {
        // Create the deferBits variable and stack slot.  deferBits is a
        // bitmask showing which of the open-coded defers in this function
        // have been activated.
        // 延迟bit，创建deferbits变量
        // 开放式编码的数量不能超过8个，所以延迟bit被设置为8位
        deferBitsTemp := typecheck.TempAt(src.NoXPos, s.curfn, types.Types[types.TUINT8])
        deferBitsTemp.SetAddrtaken(true)
        s.deferBitsTemp = deferBitsTemp
        // For this value, AuxInt is initialized to zero by default
        // 初始化为0
        startDeferBits := s.entryNewValue0(ssa.OpConst8, types.Types[types.TUINT8])
        s.vars[deferBitsVar] = startDeferBits
        s.deferBitsAddr = s.addr(deferBitsTemp)
        s.store(types.Types[types.TUINT8], s.deferBitsAddr, startDeferBits)
        // Make sure that the deferBits stack slot is kept alive (for use
        // by panics) and stores to deferBits are not eliminated, even if
        // all checking code on deferBits in the function exit can be
        // eliminated, because the defer statements were all
        // unconditional.
        s.vars[memVar] = s.newValue1Apos(ssa.OpVarLive, types.TypeMem, deferBitsTemp, s.mem(), false)
    }
	...
	s.stmtList(fn.Nbody) // 调用 s.stmt
	...
}
```

2）针对出现的defer语句，进行编码

```go
// src/cmd/compile/internal/ssagen/ssa.go
func (s *state) stmt(n *Node) {
	...
	switch n.Op {
	case ODEFER:
		// 开放编码式 defer
		if s.hasOpenDefers {
			s.openDeferRecord(n.Left)
		} else { ... }
	case ...
	}
	...
}

// Information about each open-coded defer.
// 存储每个开放式编码的defer信息
type openDeferInfo struct {
    // The node representing the call of the defer
    n *ir.CallExpr
    // If defer call is closure call, the address of the argtmp where the
    // closure is stored.
    closure *ssa.Value
    // The node representing the argtmp where the closure is stored - used for
    // function, method, or interface call, to store a closure that panic
    // processing can use for this defer.
    closureNode *ir.Name
}

// openDeferRecord adds code to evaluate and store the function for an open-code defer
// call, and records info about the defer, so we can generate proper code on the
// exit paths. n is the sub-node of the defer node that is the actual function
// call. We will also record funcdata information on where the function is stored
// (as well as the deferBits variable), and this will enable us to run the proper
// defer calls during panics.
func (s *state) openDeferRecord(n *ir.CallExpr) {
    if len(n.Args) != 0 || n.Op() != ir.OCALLFUNC || n.X.Type().NumResults() != 0 {
        s.Fatalf("defer call with arguments or results: %v", n)
    }

    // 记录defer相关信息
    opendefer := &openDeferInfo{
        n: n,
    }
    fn := n.X
    // We must always store the function value in a stack slot for the
    // runtime panic code to use. But in the defer exit code, we will
    // call the function directly if it is a static function.
    // 立即求值并存储
    closureVal := s.expr(fn)
    closure := s.openDeferSave(fn.Type(), closureVal)
    // 函数指针存储
    opendefer.closureNode = closure.Aux.(*ir.Name)
    // 记录函数地址
    if !(fn.Op() == ir.ONAME && fn.(*ir.Name).Class == ir.PFUNC) {
        opendefer.closure = closure
    }
    index := len(s.openDefers)
    s.openDefers = append(s.openDefers, opendefer)

    // Update deferBits only after evaluation and storage to stack of
    // the function is successful.
    // 每多出现一个 defer，len(defers) 会增加，进而
    // 延迟比特 deferBits |= 1<<len(defers) 被设置在不同的位上
    bitvalue := s.constInt8(types.Types[types.TUINT8], 1<<uint(index))
    newDeferBits := s.newValue2(ssa.OpOr8, types.Types[types.TUINT8], s.variable(deferBitsVar, types.Types[types.TUINT8]), bitvalue)
    s.vars[deferBitsVar] = newDeferBits
    s.store(types.Types[types.TUINT8], s.deferBitsAddr, newDeferBits)
}
```

3）在函数返回退出前，state的exit函数会依次倒序创建对延迟比特的检查代码，从而顺序调用被延迟的函数调用：

```go
// src/cmd/compile/internal/ssagen/ssa.go
func (s *state) exit() *ssa.Block {
	if s.hasdefer {
		if s.hasOpenDefers {
			...
			s.openDeferExit()
		} else {
			...
		}
	}
	...
}

// openDeferExit generates SSA for processing all the open coded defers at exit.
// The code involves loading deferBits, and checking each of the bits to see if
// the corresponding defer statement was executed. For each bit that is turned
// on, the associated defer call is made.
func (s *state) openDeferExit() {
    deferExit := s.f.NewBlock(ssa.BlockPlain)
    s.endBlock().AddEdgeTo(deferExit)
    s.startBlock(deferExit)
    s.lastDeferExit = deferExit
    s.lastDeferCount = len(s.openDefers)
    zeroval := s.constInt8(types.Types[types.TUINT8], 0)
    // Test for and run defers in reverse order
    // 倒序检查
    for i := len(s.openDefers) - 1; i >= 0; i-- {
        r := s.openDefers[i]
        bCond := s.f.NewBlock(ssa.BlockPlain)
        bEnd := s.f.NewBlock(ssa.BlockPlain)

        // 检查deferbits
        deferBits := s.variable(deferBitsVar, types.Types[types.TUINT8])
        // Generate code to check if the bit associated with the current
        // defer is set.
        bitval := s.constInt8(types.Types[types.TUINT8], 1<<uint(i))
        andval := s.newValue2(ssa.OpAnd8, types.Types[types.TUINT8], deferBits, bitval)
        eqVal := s.newValue2(ssa.OpEq8, types.Types[types.TBOOL], andval, zeroval)
        b := s.endBlock()
        b.Kind = ssa.BlockIf
        b.SetControl(eqVal)
        b.AddEdgeTo(bEnd)
        b.AddEdgeTo(bCond)
        bCond.AddEdgeTo(bEnd)
        s.startBlock(bCond)

        // Clear this bit in deferBits and force store back to stack, so
        // we will not try to re-run this defer call if this defer call panics.
        nbitval := s.newValue1(ssa.OpCom8, types.Types[types.TUINT8], bitval)
        maskedval := s.newValue2(ssa.OpAnd8, types.Types[types.TUINT8], deferBits, nbitval)
        s.store(types.Types[types.TUINT8], s.deferBitsAddr, maskedval)
        // Use this value for following tests, so we keep previous
        // bits cleared.
        s.vars[deferBitsVar] = maskedval

        // Generate code to call the function call of the defer, using the
        // closure that were stored in argtmps at the point of the defer
        // statement.
        // 延迟处理函数调用
        fn := r.n.X
        stksize := fn.Type().ArgWidth()
        var callArgs []*ssa.Value
        var call *ssa.Value
        if r.closure != nil {
            v := s.load(r.closure.Type.Elem(), r.closure)
            s.maybeNilCheckClosure(v, callDefer)
            codeptr := s.rawLoad(types.Types[types.TUINTPTR], v)
            aux := ssa.ClosureAuxCall(s.f.ABIDefault.ABIAnalyzeTypes(nil, nil, nil))
            call = s.newValue2A(ssa.OpClosureLECall, aux.LateExpansionResultType(), aux, codeptr, v)
        } else {
            // 静态函数直接使用函数指针
            aux := ssa.StaticAuxCall(fn.(*ir.Name).Linksym(), s.f.ABIDefault.ABIAnalyzeTypes(nil, nil, nil))
            call = s.newValue0A(ssa.OpStaticLECall, aux.LateExpansionResultType(), aux)
        }
        callArgs = append(callArgs, s.mem())
        call.AddArgs(callArgs...)
        call.AuxInt = stksize
        s.vars[memVar] = s.newValue1I(ssa.OpSelectN, types.TypeMem, 0, call)
        // Make sure that the stack slots with pointers are kept live
        // through the call (which is a pre-emption point). Also, we will
        // use the first call of the last defer exit to compute liveness
        // for the deferreturn, so we want all stack slots to be live.
        if r.closureNode != nil {
            s.vars[memVar] = s.newValue1Apos(ssa.OpVarLive, types.TypeMem, r.closureNode, s.mem(), false)
        }

        s.endBlock()
        s.startBlock(bEnd)
    }
}
```

注意：defer在编译期被统一为闭包处理。

​	1.	**统一处理**：将所有的 defer 调用都当作闭包来处理，可以简化编译器的实现。编译器只需要一种机制来处理所有的 defer 调用，无论它们是否是闭包。这种统一处理方式避免了编译器在处理 defer 调用时，需要区分普通函数调用和闭包调用。

​	2.	**延迟执行上下文**：

​	即使是普通的函数调用，defer 也需要记录函数指针和调用的上下文（例如参数值）。将其作为闭包处理，可以方便地将这些信息保存在一起。

​	这也确保了在处理 panic 或函数退出时，可以正确地恢复和执行延迟调用。

## 2、panic

整体流程：

1. 对当前panic类型进行判断，看看是否可以恢复
2. 创建_panic结构体，并加入到协程的panic链表中
3. 逐一调用当前goroutine的defer方法，检查用户态代码是否需要对panic进行恢复

当panic可以从运行时进行恢复，会创建一个_panic实例，并定义一个这个结构体的链表：

```go
// src/runtime/runtime2.go
// A _panic holds information about an active panic.
//
// A _panic value must only ever live on the stack.
//
// The argp and link fields are stack pointers, but don't need special
// handling during stack growth: because they are pointer-typed and
// _panic values only live on the stack, regular stack pointer
// adjustment takes care of them.
// 保存一个活跃的panic，且这个结构体的实例只能分配到栈上
type _panic struct {
    // panic期间defer调用参数的指针
    argp unsafe.Pointer // pointer to arguments of deferred call run during panic; cannot move - known to liblink
    arg  any            // argument to panic panic的指针
    link *_panic        // link to earlier panic 指向更早的panic的指针
    // panic结束返回到运行时的下一个指令
    pc        uintptr        // where to return to in runtime if this panic is bypassed
    sp        unsafe.Pointer // where to return to in runtime if this panic is bypassed
    recovered bool           // whether this panic is over panic是否结束
    aborted   bool           // the panic was aborted panic是否可以被忽略
    goexit    bool
}
```

panic关键字其实是一个gopanic调用，接受一个参数，在处理panic期间，会先判断当前panic的类型，确定panic是否可恢复

```go
// src/runtime/panic.go
// panic的实现
// The implementation of the predeclared function panic.
func gopanic(e any) {
    gp := getg()

    // 判断在系统栈上还是用户栈上
    // 如果执行在系统或信号栈时，getg()会返回当前m的g0或gsignal
    // 因此可以通过m的当前栈是不是绑定的用户栈来判断所在栈
    // 系统栈上的panic无法恢复
    if gp.m.curg != gp {
        print("panic: ")
        printany(e)
        print("\n")
        throw("panic on system stack")
    }

    // 正在进行堆分配，同样无法恢复
    if gp.m.mallocing != 0 {
        print("panic: ")
        printany(e)
        print("\n")
        throw("panic during malloc")
    }
    // 在禁止抢占时发生panic也无法恢复
    if gp.m.preemptoff != "" {
        print("panic: ")
        printany(e)
        print("\n")
        print("preempt off reason: ")
        print(gp.m.preemptoff)
        print("\n")
        throw("panic during preemptoff")
    }
    // 在g锁在m上时，发生panic无法恢复
    if gp.m.locks != 0 {
        print("panic: ")
        printany(e)
        print("\n")
        throw("panic holding locks")
    }

    var p _panic
    p.arg = e
    p.link = gp._panic
    // 头添加
    gp._panic = (*_panic)(noescape(unsafe.Pointer(&p)))

    runningPanicDefers.Add(1)

    // By calculating getcallerpc/getcallersp here, we avoid scanning the
    // gopanic frame (stack scanning is slow...)
    // 将当前帧的开放式编码添加到链表中
    addOneOpenDeferFrame(gp, getcallerpc(), unsafe.Pointer(getcallersp()))

    for {
        // 开始逐个取当前的defer进行调用
        d := gp._defer
        // 没有了，跳出循环
        if d == nil {
            break
        }

        // If defer was started by earlier panic or Goexit (and, since we're back here, that triggered a new panic),
        // take defer off list. An earlier panic will not continue running, but we will make sure below that an
        // earlier Goexit does continue running.
        // 如果defer是由更早的panic或Goexit开始的（并且回到这里引发了新的panic）
        // 则将defer移除链表，更早的panic或Goexit无法继续进行，但我们将在下面确保较早的 Goexit 确实继续运行。
        if d.started {
            // defer已经开始
            // 之前的panic或Goexit导致了新的panic
            if d._panic != nil {
                // 更早的panic终止
                d._panic.aborted = true
            }
            d._panic = nil
            if !d.openDefer {
                // For open-coded defers, we need to process the
                // defer again, in case there are any other defers
                // to call in the frame (not including the defer
                // call that caused the panic).
                // 不是开放编码的话，移除链表，继续下一个defer
                d.fn = nil
                gp._defer = d.link
                freedefer(d)
                continue
            }
        }

        // Mark defer as started, but keep on list, so that traceback
        // can find and update the defer's argument frame if stack growth
        // or a garbage collection happens before executing d.fn.
        // 标记defer语句开始执行，但仍然将其保留在链表上
        // 如果在执行 d.fn 之前发生堆栈增长或垃圾收集，则回溯可以找到并更新 defer 的参数框架。
        d.started = true

        // Record the panic that is running the defer.
        // If there is a new panic during the deferred call, that panic
        // will find d in the list and will mark d._panic (this panic) aborted.
        // 记录正在运行defer的panic，如果在defer调用期间出现新的panic，
        // 该panic将在列表中找到d并标记d._panic终止
        d._panic = (*_panic)(noescape(unsafe.Pointer(&p)))

        done := true
        if d.openDefer {
            done = runOpenDeferFrame(d)
            // 特殊情况处理：panic被终止，此时没有被recover，则需要把栈上剩余的defer加到链表中执行
            if done && !d._panic.recovered {
                addOneOpenDeferFrame(gp, 0, nil)
            }
        } else {
            // 不是开放编码，直接调用函数
            p.argp = unsafe.Pointer(getargp())
            d.fn()
        }
        p.argp = nil

        // Deferred function did not panic. Remove d.
        // 移除已经完成的defer
        if gp._defer != d {
            throw("bad defer entry in panic")
        }
        d._panic = nil

        // trigger shrinkage to test stack copy. See stack_test.go:TestStackPanic
        // GC()

        pc := d.pc
        sp := unsafe.Pointer(d.sp) // must be pointer so it gets adjusted during stack copy
        if done {
            d.fn = nil
            gp._defer = d.link
            freedefer(d)
        }
        // 处理恢复
        if p.recovered {
            // 当前panic处理完毕，更新为下一个panic
            gp._panic = p.link
            // 当前panic遇到一个Goexit调用，并且这个Goexit被终止，系统会重新进入Goexit的处理循环。
            // 正常的recover会跳过或终止exit，这种情况下需要确保返回goexit
            if gp._panic != nil && gp._panic.goexit && gp._panic.aborted {
                // A normal recover would bypass/abort the Goexit.  Instead,
                // we return to the processing loop of the Goexit.
                gp.sigcode0 = uintptr(gp._panic.sp)
                gp.sigcode1 = uintptr(gp._panic.pc)
                mcall(recovery)
                throw("bypassed recovery failed") // mcall should not return
            }
            runningPanicDefers.Add(-1)

            // 清理未开始的开放编码的defer
            // 对应的defer将会在正常执行过程中内联执行
            // 这些条目在运行对应的defer并退出相关栈帧之后将变得无效
            // After a recover, remove any remaining non-started,
            // open-coded defer entries, since the corresponding defers
            // will be executed normally (inline). Any such entry will
            // become stale once we run the corresponding defers inline
            // and exit the associated stack frame. We only remove up to
            // the first started (in-progress) open defer entry, not
            // including the current frame, since any higher entries will
            // be from a higher panic in progress, and will still be
            // needed.
            d := gp._defer
            var prev *_defer
            // 当前帧的defer尚未完成
            if !done {
                // Skip our current frame, if not done. It is
                // needed to complete any remaining defers in
                // deferreturn()
                // 跳过，在deferreturn中完成
                prev = d
                d = d.link
            }
            for d != nil {
                if d.started {
                    // 已经开始的defer不要移除
                    // This defer is started but we
                    // are in the middle of a
                    // defer-panic-recover inside of
                    // it, so don't remove it or any
                    // further defer entries
                    break
                }
                // 移除所有的开放编码defer
                // 非开放编码的defer直接跳过
                if d.openDefer {
                    if prev == nil {
                        gp._defer = d.link
                    } else {
                        prev.link = d.link
                    }
                    newd := d.link
                    freedefer(d)
                    d = newd
                } else {
                    prev = d
                    d = d.link
                }
            }

            gp._panic = p.link
            // Aborted panics are marked but remain on the g.panic list.
            // Remove them from the list.
            // 移除终止的panic
            for gp._panic != nil && gp._panic.aborted {
                gp._panic = gp._panic.link
            }
            // todo 清除信号
            if gp._panic == nil { // must be done with signal
                gp.sig = 0
            }
            // Pass information about recovering frame to recovery.
            // 恢复帧的sp和pc信息，调用recovery函数，恢复程序运行，继续运行剩余的代码或defer语句
            gp.sigcode0 = uintptr(sp)
            gp.sigcode1 = pc
            mcall(recovery)
            throw("recovery failed") // mcall should not return
        }
    }

    // ran out of deferred calls - old-school panic now
    // Because it is unsafe to call arbitrary user code after freezing
    // the world, we call preprintpanics to invoke all necessary Error
    // and String methods to prepare the panic strings before startpanic.
    // 在程序冻结时，运行用户代码并不安全，因此需要调用必要的Error和String方法在开始panic之前
    preprintpanics(gp._panic)

    // 打印栈信息
    fatalpanic(gp._panic) // should not return
    *(*int)(nil) = 0      // not reached
}
```

当panic发生时，如果错误是可恢复的错误，那么会逐一遍历该goroutine对应defer链表中的defer函数链表，直到defer遍历完毕、或者再次进入调度循环（recover的mcall调用）后才会停止。

```go
// src/runtime/panic.go
// Unwind the stack after a deferred function calls recover
// after a panic. Then arrange to continue running as though
// the caller of the deferred function returned normally.
// 在发生panic后defer函数调用recover后展开栈，然后安排继续运行
// 就像defer函数的调用方正常返回一样
func recovery(gp *g) {
    // Info about defer passed in G struct.
    // 传递G结构的defer信息
    sp := gp.sigcode0
    pc := gp.sigcode1

    // d's arguments need to be in the stack.
    // 确保 sp 在当前 goroutine 的栈范围内。如果不在范围内，说明恢复过程有问题，抛出错误。
    if sp != 0 && (sp < gp.stack.lo || gp.stack.hi < sp) {
        print("recover: ", hex(sp), " not in [", hex(gp.stack.lo), ", ", hex(gp.stack.hi), "]\n")
        throw("bad recovery")
    }

    // Make the deferproc for this d return again,
    // this time returning 1. The calling function will
    // jump to the standard return epilogue.
    gp.sched.sp = sp
    gp.sched.pc = pc
    gp.sched.lr = 0
    gp.sched.ret = 1
    gogo(&gp.sched)
}
```

panic的上下文中没有defer调用recover，则打印函数栈并崩溃

```go
// src/runtime/panic.go
// Call all Error and String methods before freezing the world.
// Used when crashing with panicking.
// 在停止前调用所有的 Error 和 String 方法
func preprintpanics(p *_panic) {
    defer func() {
        text := "panic while printing panic value"
        switch r := recover().(type) {
        case nil:
            // nothing to do
        case string:
            throw(text + ": " + r)
        default:
            throw(text + ": type " + efaceOf(&r)._type.string())
        }
    }()
    for p != nil {
        switch v := p.arg.(type) {
        case error:
            p.arg = v.Error()
        case stringer:
            p.arg = v.String()
        }
        p = p.link
    }
}

// fatalpanic implements an unrecoverable panic. It is like fatalthrow, except
// that if msgs != nil, fatalpanic also prints panic messages and decrements
// runningPanicDefers once main is blocked from exiting.
//
// fatalpanic 实现了不可恢复的 panic。类似于 fatalthrow，
// 要求如果 msgs != nil，则 fatalpanic 仍然能够打印 panic 的消息并在 main 在退出时候减少 runningPanicDefers。
//go:nosplit
func fatalpanic(msgs *_panic) {
    pc := getcallerpc()
    sp := getcallersp()
    gp := getg()
    var docrash bool
    // Switch to the system stack to avoid any stack growth, which
    // may make things worse if the runtime is in a bad state.
    // 切换到系统栈来避免栈增长，如果运行时状态较差则可能导致更糟糕的事情
    systemstack(func() {
        if startpanic_m() && msgs != nil {
            // There were panic messages and startpanic_m
            // says it's okay to try to print them.

            // startpanic_m set panicking, which will
            // block main from exiting, so now OK to
            // decrement runningPanicDefers.
            // 有 panic 消息和 startpanic_m 则可以尝试打印它们

            // startpanic_m 设置 panic 会从阻止 main 的退出，
            // 因此现在可以开始减少 runningPanicDefers 了
            runningPanicDefers.Add(-1)

            printpanics(msgs)
        }

        docrash = dopanic_m(gp, pc, sp)
    })

    if docrash {
        // By crashing outside the above systemstack call, debuggers
        // will not be confused when generating a backtrace.
        // Function crash is marked nosplit to avoid stack growth.
        // 通过在上述 systemstack 调用之外崩溃，调试器在生成回溯时不会混淆。
        // 函数崩溃标记为 nosplit 以避免堆栈增长。
        crash()
    }

    // 系统栈退出
    systemstack(func() {
        exit(2)
    })

    *(*int)(nil) = 0 // not reached
}
```



## 3、recover

<span style='color:red'>在GO语言中，recover必须在defer函数调用时才生效，recover是用于恢复panic的机制，它可以捕获并处理panic引起的崩溃。</span>

为什么需要在defer中调用recover

1）捕获panic

- 当panic被调用时，程序的控制流会立即停止，并开始在调用栈上向上返回，直到遇到defer函数，如果这个defer函数调用了recover，它就会捕获panic，并停止继续传播。
- 如果recover没有在defer中调用，它将无法捕获到panic，因为panic会在到达defer函数之前就会导致程序终止。

2）确保清理和资源释放

- 使用defer确保函数在退出之前执行一些必要的清理工作，比如释放资源、关闭文件等，当panic发生时仍可以确保执行defer函数，保证程序资源的正确管理。

```go
// src/runtime/panic.go
// The implementation of the predeclared function recover.
// Cannot split the stack because it needs to reliably
// find the stack segment of its caller.
//
// TODO(rsc): Once we commit to CopyStackAlways,
// this doesn't need to be nosplit.
//
// 预先声明的函数recover的实现
// 不允许分段栈
//go:nosplit
func gorecover(argp uintptr) any {
    // Must be in a function running as part of a deferred call during the panic.
    // Must be called from the topmost function of the call
    // (the function used in the defer statement).
    // p.argp is the argument pointer of that topmost deferred function call.
    // Compare against argp reported by caller.
    // If they match, the caller is the one who can recover.
    // 必须在panic期间作为defer调用的一部分在函数中运行
    // 必须从调用的最顶层函数（defer语句中使用的函数）调用
    // p.argp是最顶层defer函数调用的参数指针
    // 比较调用方报告的 argp，如果匹配，则调用者可以恢复。
    gp := getg()
    p := gp._panic
    if p != nil && !p.goexit && !p.recovered && argp == uintptr(p.argp) {
        p.recovered = true
        return p.arg
    }
    return nil
}
```

recover恢复的条件：

1. 确保当前存在panic
2. 确保panic不是由Goexit引起的。
3. 确保panic还没有被恢复过。
4. 检查recover在调用时的argp是否与panic时记录的argp相同，确保recover是在正确的defer调用中执行的。

为什么argp必须相等

1. 唯一性检查：每个defer调用都可以包含一个recover，但只有在引发panic的上下文相关联的defer调用中的recover才能恢复。通过检查recover调用时的argp是否与panic时记录的argp相同，可以确保recover是在正确的defer中调用。
2. 防止错误恢复：如果没有这种检查机制，不相关的defer调用中的recover也可能尝试恢复panic，导致逻辑错误。
3. 调用栈一致性：panic和recover的设计是为了维护调用栈的一致性。只有在正确的调用栈帧中调用 recover 才能恢复 panic，确保程序的执行逻辑和栈帧管理一致。

不相等的情况

<span style='color:red'>recover只能恢复当前的panic，不能恢复更高层次的panic。</span>

```go
package main

import "fmt"

func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in defer:", r)
        }
    }()
    defer func() {
        panic("inner panic")
    }()
    panic("outer panic")
}
```

<span style='color:red'>argp 检查机制确保 recover 调用只能在最顶层的 defer 中恢复 panic，这样可以避免在多个嵌套的 defer 函数中错误地恢复 panic。</span>

没有 argp 检查机制，间接调用 recover 的函数可能会错误地尝试恢复 panic，导致逻辑错误。通过 argp 检查机制，Go 运行时确保了 panic 只能由最顶层的 defer 函数恢复，从而保证了代码逻辑的正确性。

```go
package main

import "fmt"

func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in defer 1:", r)
        }
    }()
    
    defer func() {
        // This defer does not call recover directly,
        // but it calls a function that might contain recover.
        intermediaryRecover()
    }()
    
    panic("outer panic")
}

func intermediaryRecover() {
    recover()  // Attempt to recover the panic
}

// 当 panic 触发时，Go 运行时会首先调用第二个 defer 函数。由于 intermediaryRecover 函数的 argp 与 panic 的 argp 不同，recover 调用将不会恢复 panic。
//	然后，Go 运行时会调用第一个 defer 函数。由于这个 defer 函数的 argp 与 panic 的 argp 相同，recover 调用将成功恢复 panic。
// 最后，打印出 Recovered in defer 1: outer panic。
```

