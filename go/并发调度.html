
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>并发调度 · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../node/" />
    
    
    <link rel="prev" href="内存一致模型.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    介绍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="./">
            
                <a href="./">
            
                    
                    Go
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="go 内存逃逸.html">
            
                <a href="go 内存逃逸.html">
            
                    
                    内存逃逸
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="go闭包.html">
            
                <a href="go闭包.html">
            
                    
                    闭包
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="go embed.html">
            
                <a href="go embed.html">
            
                    
                    embed
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="编译指令.html">
            
                <a href="编译指令.html">
            
                    
                    编译指令
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="工具链.html">
            
                <a href="工具链.html">
            
                    
                    工具链
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="反射.html">
            
                <a href="反射.html">
            
                    
                    反射
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="unsafe.html">
            
                <a href="unsafe.html">
            
                    
                    unsafe
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="interface.html">
            
                <a href="interface.html">
            
                    
                    接口
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="环境变量.html">
            
                <a href="环境变量.html">
            
                    
                    环境变量
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="plan9.html">
            
                <a href="plan9.html">
            
                    
                    plan9汇编
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="相关问题.html">
            
                <a href="相关问题.html">
            
                    
                    相关问题
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="编译流程.html">
            
                <a href="编译流程.html">
            
                    
                    编译流程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13" data-path="runtime.html">
            
                <a href="runtime.html">
            
                    
                    运行时
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.14" data-path="内置关键字.html">
            
                <a href="内置关键字.html">
            
                    
                    内置关键字
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.15" data-path="类型.html">
            
                <a href="类型.html">
            
                    
                    类型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.16" data-path="内部包.html">
            
                <a href="内部包.html">
            
                    
                    内部包
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.17" data-path="内存一致模型.html">
            
                <a href="内存一致模型.html">
            
                    
                    内存一致模型
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.18" data-path="并发调度.html">
            
                <a href="并发调度.html">
            
                    
                    并发调度
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../node/">
            
                <a href="../node/">
            
                    
                    Node
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../node/相关问题.html">
            
                <a href="../node/相关问题.html">
            
                    
                    相关问题
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../Linux/">
            
                <a href="../Linux/">
            
                    
                    Linux
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../Linux/基本概念.html">
            
                <a href="../Linux/基本概念.html">
            
                    
                    基本概念
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../Project/">
            
                <a href="../Project/">
            
                    
                    Project
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../Project/oauth2.html">
            
                <a href="../Project/oauth2.html">
            
                    
                    oauth2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../Project/web.html">
            
                <a href="../Project/web.html">
            
                    
                    网络协议
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../Project/后端.html">
            
                <a href="../Project/后端.html">
            
                    
                    后端
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../Project/敏感词处理.html">
            
                <a href="../Project/敏感词处理.html">
            
                    
                    敏感词处理
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../算法/">
            
                <a href="../算法/">
            
                    
                    算法
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../算法/数据结构.html">
            
                <a href="../算法/数据结构.html">
            
                    
                    数据结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../算法/算法.html">
            
                <a href="../算法/算法.html">
            
                    
                    算法
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../中间件/">
            
                <a href="../中间件/">
            
                    
                    中间件
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../中间件/mysql.html">
            
                <a href="../中间件/mysql.html">
            
                    
                    mysql
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../常见问题/">
            
                <a href="../常见问题/">
            
                    
                    常见问题
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../常见问题/Go语言.html">
            
                <a href="../常见问题/Go语言.html">
            
                    
                    GO语言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../常见问题/mysql.html">
            
                <a href="../常见问题/mysql.html">
            
                    
                    mysql
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../常见问题/redis.html">
            
                <a href="../常见问题/redis.html">
            
                    
                    redis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="../常见问题/Linux.html">
            
                <a href="../常见问题/Linux.html">
            
                    
                    Linux
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >并发调度</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="&#x5E76;&#x53D1;&#x8C03;&#x5EA6;">&#x5E76;&#x53D1;&#x8C03;&#x5EA6;</h1>
<h2 id="1&#x3001;&#x5DE5;&#x4F5C;&#x5171;&#x4EAB;&#x548C;&#x5DE5;&#x4F5C;&#x7A83;&#x53D6;">1&#x3001;&#x5DE5;&#x4F5C;&#x5171;&#x4EAB;&#x548C;&#x5DE5;&#x4F5C;&#x7A83;&#x53D6;</h2>
<p>&#x5728;&#x5DE5;&#x4F5C;&#x5171;&#x4EAB;&#x4E2D;&#xFF0C;&#x53EA;&#x8981;&#x5904;&#x7406;&#x5668;&#x751F;&#x6210;&#x65B0;&#x7EBF;&#x7A0B;&#xFF0C;&#x8C03;&#x5EA6;&#x7A0B;&#x5E8F;&#x5C31;&#x4F1A;&#x5C1D;&#x8BD5;&#x5C06;&#x5176;&#x4E2D;&#x4E00;&#x4E9B;&#x7EBF;&#x7A0B;&#x8FC1;&#x79FB;&#x5230;&#x5176;&#x4ED6;&#x5904;&#x7406;&#x5668;&#xFF0C;&#x4EE5;&#x671F;&#x5C06;&#x5DE5;&#x4F5C;&#x5206;&#x914D;&#x7ED9;&#x672A;&#x5145;&#x5206;&#x5229;&#x7528;&#x7684;&#x5904;&#x7406;&#x5668;&#x3002;</p>
<p>&#x5728;&#x5DE5;&#x4F5C;&#x7A83;&#x53D6;&#x4E2D;&#xFF0C;&#x672A;&#x5145;&#x5206;&#x5229;&#x7528;&#x7684;&#x5904;&#x7406;&#x5668;&#x91C7;&#x53D6;&#x4E3B;&#x52A8;&#xFF0C;&#x5B83;&#x4EEC;&#x8BD5;&#x56FE;&#x4ECE;&#x5176;&#x4ED6;&#x5904;&#x7406;&#x5668;&#x7A83;&#x53D6;&#x7EBF;&#x7A0B;&#x3002;</p>
<p>&#x7EBF;&#x7A0B;&#x8FC1;&#x79FB;&#x5728;&#x5DE5;&#x4F5C;&#x7A83;&#x53D6;&#x4E2D;&#x7684;&#x53D1;&#x751F;&#x9891;&#x7387;&#x4F4E;&#x4E8E;&#x5DE5;&#x4F5C;&#x5171;&#x4EAB;&#xFF0C;&#x56E0;&#x4E3A;&#x5F53;&#x6240;&#x6709;&#x5904;&#x7406;&#x5668;&#x90FD;&#x6709;&#x5DE5;&#x4F5C;&#x8981;&#x505A;&#x65F6;&#xFF0C;&#x5DE5;&#x4F5C;&#x7A83;&#x53D6;&#x8C03;&#x5EA6;&#x7A0B;&#x5E8F;&#x4E0D;&#x4F1A;&#x8FC1;&#x79FB;&#x4EFB;&#x4F55;&#x7EBF;&#x7A0B;&#xFF0C;&#x4F46;&#x7EBF;&#x7A0B;&#x603B;&#x662F;&#x53D7;&#x5230;&#x5DE5;&#x4F5C;&#x5171;&#x4EAB;&#x8C03;&#x5EA6;&#x7A0B;&#x5E8F;&#x8FC1;&#x79FB;&#x3002;</p>
<h2 id="2&#x3001;mpg&#x5E76;&#x53D1;&#x6A21;&#x578B;&#x4E0E;&#x5E76;&#x53D1;&#x8C03;&#x5EA6;&#x5355;&#x5143;">2&#x3001;MPG&#x5E76;&#x53D1;&#x6A21;&#x578B;&#x4E0E;&#x5E76;&#x53D1;&#x8C03;&#x5EA6;&#x5355;&#x5143;</h2>
<p>G&#xFF1A;Goroutine&#xFF0C;&#x5373;&#x5728;Go&#x7A0B;&#x5E8F;&#x4E2D;&#x4F7F;&#x7528;go&#x5173;&#x952E;&#x5B57;&#x521B;&#x5EFA;&#x7684;&#x6267;&#x884C;&#x4F53;&#x3002;</p>
<p>M&#xFF1A;Machine&#xFF0C;&#x6216;worker thread&#xFF0C;&#x5373;&#x4F20;&#x7EDF;&#x610F;&#x4E49;&#x4E0A;&#x8FDB;&#x7A0B;&#x7684;&#x7EBF;&#x7A0B;&#x3002;</p>
<p>P&#xFF1A;Processor&#xFF0C;&#x4E00;&#x79CD;&#x4EBA;&#x4E3A;&#x62BD;&#x8C61;&#x7684;&#x3001;&#x7528;&#x4E8E;&#x6267;&#x884C;Go&#x4EE3;&#x7801;&#x88AB;&#x8981;&#x6C42;&#x7684;&#x5C40;&#x90E8;&#x8D44;&#x6E90;&#x3002;&#x53EA;&#x6709;&#x5F53;M&#x4E0E;&#x4E00;&#x4E2A;P&#x5173;&#x8054;&#x540E;&#x624D;&#x80FD;&#x6267;&#x884C;Go&#x4EE3;&#x7801;&#x3002;&#x9664;&#x975E;M&#x53D1;&#x751F;&#x963B;&#x585E;&#x6216;&#x5728;&#x8FDB;&#x884C;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x7684;&#x65F6;&#x95F4;&#x8FC7;&#x957F;&#x65F6;&#xFF0C;&#x6CA1;&#x6709;&#x4E0E;&#x4E4B;&#x5173;&#x8054;&#x7684;P&#x3002;</p>
<p>&#x96BE;&#x70B9;&#xFF1A;</p>
<p>1&#x3001;&#x5728;&#x591A;&#x4E2A;M&#x4E4B;&#x95F4;&#x4E0D;&#x4F7F;&#x7528;&#x5C4F;&#x969C;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x5F97;&#x51FA;&#x8C03;&#x5EA6;&#x5668;&#x4E2D;&#x591A;&#x4E2A;M&#x7684;&#x5168;&#x5C40;&#x72B6;&#x6001;&#x662F;&#x4E0D;&#x53EF;&#x80FD;&#x7684;&#x3002;</p>
<p>2&#x3001;&#x4E3A;&#x4E86;&#x83B7;&#x5F97;&#x6700;&#x4F73;&#x7684;&#x7EBF;&#x7A0B;&#x7BA1;&#x7406;&#xFF0C;&#x6211;&#x4EEC;&#x5FC5;&#x987B;&#x83B7;&#x5F97;&#x672A;&#x6765;&#x7684;&#x4FE1;&#x606F;&#xFF0C;&#x5373;&#x5F53;&#x4E00;&#x4E2A;&#x65B0;&#x7684;G&#x5373;&#x5C06;&#x5C31;&#x7EEA;&#x65F6;&#xFF0C;&#x5219;&#x4E0D;&#x518D;&#x6682;&#x505C;&#x4E00;&#x4E2A;&#x5DE5;&#x4F5C;&#x7EBF;&#x7A0B;&#x3002;</p>
<p>&#x4E09;&#x79CD;&#x5E73;&#x51E1;&#x7684;&#x505A;&#x6CD5;&#xFF1A;</p>
<p>1&#x3001;&#x96C6;&#x4E2D;&#x5F0F;&#x7BA1;&#x7406;&#x6240;&#x6709;&#x72B6;&#x6001;</p>
<p>&#x8FD9;&#x79CD;&#x505A;&#x6CD5;&#x662F;&#x4E0D;&#x53EF;&#x53D6;&#x7684;&#xFF0C;&#x5728;&#x591A;&#x4E2A;&#x5E76;&#x53D1;&#x5B9E;&#x4F53;&#x4E4B;&#x95F4;&#x96C6;&#x4E2D;&#x7BA1;&#x7406;&#x6240;&#x6709;&#x72B6;&#x6001;&#x8FD9;&#x4E00;&#x5171;&#x4EAB;&#x8D44;&#x6E90;&#xFF0C;&#x9700;&#x8981;&#x9501;&#x7684;&#x652F;&#x6301;&#xFF0C;&#x5F53;&#x5E76;&#x53D1;&#x5B9E;&#x4F53;&#x7684;&#x6570;&#x91CF;&#x589E;&#x5927;&#x65F6;&#xFF0C;&#x5C06;&#x9650;&#x5236;&#x8C03;&#x5EA6;&#x5668;&#x7684;&#x53EF;&#x6269;&#x5C55;&#x6027;&#x3002;</p>
<p>2&#x3001;&#x6BCF;&#x5F53;&#x9700;&#x8981;&#x5C31;&#x7EEA;&#x4E00;&#x4E2A;G1&#x65F6;&#xFF0C;&#x90FD;&#x8BA9;&#x51FA;&#x4E00;&#x4E2A;P&#xFF0C;&#x76F4;&#x63A5;&#x5207;&#x6362;&#x51FA;G2&#xFF0C;&#x518D;&#x5F00;&#x59CB;&#x4E00;&#x4E2A;M&#x6765;&#x6267;&#x884C;G2&#x3002;</p>
<p>&#x56E0;&#x4E3A;&#x5F00;&#x59CB;&#x7684;M&#x53EF;&#x80FD;&#x5728;&#x4E0B;&#x4E00;&#x4E2A;&#x77AC;&#x95F4;&#x53C8;&#x6CA1;&#x6709;&#x8C03;&#x5EA6;&#x4EFB;&#x52A1;&#xFF0C;&#x5219;&#x4F1A;&#x53D1;&#x751F;&#x7EBF;&#x7A0B;&#x98A0;&#x7C38;&#xFF0C;&#x8FDB;&#x800C;&#x53C8;&#x9700;&#x8981;&#x505C;&#x6B62;&#x8FD9;&#x4E2A;&#x7EBF;&#x7A0B;&#x3002;</p>
<p>&#x53E6;&#x4E00;&#x65B9;&#x9762;&#xFF0C;&#x6211;&#x4EEC;&#x5E0C;&#x671B;&#x5728;&#x76F8;&#x540C;&#x7684;&#x7EBF;&#x7A0B;&#x5185;&#x4FDD;&#x5B58;&#x7EF4;&#x62A4;G&#xFF0C;&#x8FD9;&#x79CD;&#x65B9;&#x5F0F;&#x8FD8;&#x4F1A;&#x7834;&#x574F;&#x8BA1;&#x7B97;&#x7684;&#x5C40;&#x90E8;&#x6027;&#x539F;&#x7406;&#x3002;</p>
<p>3&#x3001;&#x4EFB;&#x4F55;&#x65F6;&#x5019;&#x5F53;&#x5C31;&#x7EEA;&#x4E00;&#x4E2A;G&#xFF0C;&#x4E5F;&#x5B58;&#x5728;&#x4E00;&#x4E2A;&#x7A7A;&#x95F2;&#x7684;P&#x65F6;&#xFF0C;&#x90FD;&#x5F00;&#x59CB;&#x4E00;&#x4E2A;&#x989D;&#x5916;&#x7684;&#x7EBF;&#x7A0B;&#xFF0C;&#x4E0D;&#x8FDB;&#x884C;&#x5207;&#x6362;&#x3002;</p>
<p>&#x56E0;&#x4E3A;&#x8FD9;&#x4E2A;&#x989D;&#x5916;&#x7EBF;&#x7A0B;&#x4F1A;&#x5728;&#x6CA1;&#x6709;&#x68C0;&#x67E5;&#x4EFB;&#x4F55;&#x5DE5;&#x4F5C;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x7ACB;&#x5373;&#x8FDB;&#x884C;&#x505C;&#x6B62;&#xFF0C;&#x6700;&#x7EC8;&#x5BFC;&#x81F4;&#x5927;&#x91CF;M&#x7684;&#x505C;&#x6B62;&#x548C;&#x5F00;&#x59CB;&#x884C;&#x4E3A;&#xFF0C;&#x4EA7;&#x751F;&#x5927;&#x91CF;&#x5F00;&#x9500;&#x3002;</p>
<h3 id="&#x76EE;&#x524D;&#x7684;go&#x7684;&#x8C03;&#x5EA6;&#x5668;&#x5B9E;&#x73B0;&#x4E2D;&#x8BBE;&#x8BA1;&#x4E86;&#x5DE5;&#x4F5C;&#x7EBF;&#x7A0B;&#x7684;&#x81EA;&#x65CB;&#x72B6;&#x6001;">&#x76EE;&#x524D;&#x7684;Go&#x7684;&#x8C03;&#x5EA6;&#x5668;&#x5B9E;&#x73B0;&#x4E2D;&#x8BBE;&#x8BA1;&#x4E86;&#x5DE5;&#x4F5C;&#x7EBF;&#x7A0B;&#x7684;&#x81EA;&#x65CB;&#x72B6;&#x6001;</h3>
<p>1&#x3001;&#x5982;&#x679C;&#x4E00;&#x4E2A;&#x5DE5;&#x4F5C;&#x7EBF;&#x7A0B;&#x7684;&#x672C;&#x5730;&#x961F;&#x5217;&#x3001;&#x5168;&#x5C40;&#x8FD0;&#x884C;&#x961F;&#x5217;&#x6216;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x5668;&#x4E2D;&#x5747;&#x6CA1;&#x6709;&#x53EF;&#x8C03;&#x5EA6;&#x7684;&#x4EFB;&#x52A1;&#xFF0C;&#x5219;&#x8BE5;&#x7EBF;&#x7A0B;&#x4E3A;&#x81EA;&#x65CB;&#x7EBF;&#x7A0B;&#x3002;</p>
<p>2&#x3001;&#x6EE1;&#x8DB3;&#x8BE5;&#x6761;&#x4EF6;&#x3001;&#x88AB;&#x5F00;&#x59CB;&#x7684;&#x7EBF;&#x7A0B;&#x4E5F;&#x88AB;&#x79F0;&#x4E3A;&#x81EA;&#x65CB;&#x7EBF;&#x7A0B;&#xFF0C;&#x5BF9;&#x4E8E;&#x8FD9;&#x79CD;&#x7EBF;&#x7A0B;&#xFF0C;&#x8FD0;&#x884C;&#x65F6;&#x4E0D;&#x505A;&#x4EFB;&#x4F55;&#x4E8B;&#x60C5;&#x3002;</p>
<p>&#x81EA;&#x65CB;&#x7EBF;&#x7A0B;&#x5728;&#x8FDB;&#x884C;&#x505C;&#x6B62;&#x4E4B;&#x524D;&#xFF0C;&#x4F1A;&#x5C1D;&#x8BD5;&#x4ECE;&#x4EFB;&#x52A1;&#x961F;&#x5217;&#x4E2D;&#x5BFB;&#x627E;&#x4EFB;&#x52A1;&#x3002;&#x5F53;&#x53D1;&#x73B0;&#x4EFB;&#x52A1;&#x65F6;&#xFF0C;&#x5219;&#x4F1A;&#x5207;&#x6362;&#x6210;&#x975E;&#x81EA;&#x65CB;&#x72B6;&#x6001;&#xFF0C;&#x5F00;&#x59CB;&#x6267;&#x884C;&#x534F;&#x7A0B;&#xFF0C;&#x627E;&#x4E0D;&#x5230;&#x4EFB;&#x52A1;&#x65F6;&#xFF0C;&#x4F1A;&#x505C;&#x6B62;&#x3002;</p>
<p>&#x5F53;&#x4E00;&#x4E2A; Goroutine &#x51C6;&#x5907;&#x5C31;&#x7EEA;&#x65F6;&#xFF0C;&#x4F1A;&#x9996;&#x5148;&#x68C0;&#x67E5;&#x81EA;&#x65CB;&#x7EBF;&#x7A0B;&#x7684;&#x6570;&#x91CF;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x53BB;&#x590D;&#x59CB;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x7EBF;&#x7A0B;&#x3002;</p>
<p>&#x5982;&#x679C;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x81EA;&#x65CB;&#x7EBF;&#x7A0B;&#x53D1;&#x73B0;&#x5DE5;&#x4F5C;&#x5E76;&#x4E14;&#x505C;&#x6B62;&#x81EA;&#x65CB;&#x65F6;&#xFF0C;&#x5219;&#x590D;&#x59CB;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x81EA;&#x65CB;&#x7EBF;&#x7A0B;&#x3002; &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x6D88;&#x9664;&#x4E86;&#x4E0D;&#x5408;&#x7406;&#x7684;&#x7EBF;&#x7A0B;&#x590D;&#x59CB;&#x5CF0;&#x503C;&#xFF0C;&#x4E14;&#x540C;&#x65F6;&#x4FDD;&#x8BC1;&#x6700;&#x7EC8;&#x7684;&#x6700;&#x5927; CPU &#x5E76;&#x884C;&#x5EA6;&#x5229;&#x7528;&#x7387;&#x3002;</p>
<p>&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x4E0B;&#x56FE;&#x6765;&#x76F4;&#x89C2;&#x7406;&#x89E3;&#x5DE5;&#x4F5C;&#x7EBF;&#x7A0B;&#x7684;&#x72B6;&#x6001;&#x8F6C;&#x6362;&#xFF1A;</p>
<pre><code>  &#x5982;&#x679C;&#x5B58;&#x5728;&#x7A7A;&#x95F2;&#x7684; P&#xFF0C;&#x4E14;&#x5B58;&#x5728;&#x6682;&#x6B62;&#x7684; M&#xFF0C;&#x5E76;&#x5C31;&#x7EEA; G
          +------+
          v      |
&#x6267;&#x884C; --&gt; &#x81EA;&#x65CB; --&gt; &#x6682;&#x6B62;
 ^        |
 +--------+
  &#x5982;&#x679C;&#x53D1;&#x73B0;&#x5DE5;&#x4F5C;
</code></pre><p>&#x603B;&#x7684;&#x6765;&#x8BF4;&#xFF0C;&#x8C03;&#x5EA6;&#x5668;&#x7684;&#x65B9;&#x5F0F;&#x53EF;&#x4EE5;&#x6982;&#x62EC;&#x4E3A;&#xFF1A; <strong>&#x5982;&#x679C;&#x5B58;&#x5728;&#x4E00;&#x4E2A;&#x7A7A;&#x95F2;&#x7684; P &#x5E76;&#x4E14;&#x6CA1;&#x6709;&#x81EA;&#x65CB;&#x72B6;&#x6001;&#x7684;&#x5DE5;&#x4F5C;&#x7EBF;&#x7A0B; M&#xFF0C;&#x5219;&#x5F53;&#x5C31;&#x7EEA;&#x4E00;&#x4E2A; G &#x65F6;&#xFF0C;&#x5C31;&#x590D;&#x59CB;&#x4E00;&#x4E2A;&#x989D;&#x5916;&#x7684;&#x7EBF;&#x7A0B; M&#x3002;</strong> &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x6D88;&#x9664;&#x4E86;&#x4E0D;&#x5408;&#x7406;&#x7684;&#x7EBF;&#x7A0B;&#x590D;&#x59CB;&#x5CF0;&#x503C;&#xFF0C;&#x4E14;&#x540C;&#x65F6;&#x4FDD;&#x8BC1;&#x6700;&#x7EC8;&#x7684;&#x6700;&#x5927; CPU &#x5E76;&#x884C;&#x5EA6;&#x5229;&#x7528;&#x7387;&#x3002;</p>
<p>&#x8FD9;&#x79CD;&#x8BBE;&#x8BA1;&#x7684;&#x5B9E;&#x73B0;&#x590D;&#x6742;&#x6027;&#x8868;&#x73B0;&#x5728;&#x8FDB;&#x884C;&#x81EA;&#x65CB;&#x4E0E;&#x975E;&#x81EA;&#x65CB;&#x7EBF;&#x7A0B;&#x72B6;&#x6001;&#x8F6C;&#x6362;&#x65F6;&#x5FC5;&#x987B;&#x975E;&#x5E38;&#x5C0F;&#x5FC3;&#x3002; &#x8FD9;&#x79CD;&#x8F6C;&#x6362;&#x5728;&#x63D0;&#x4EA4;&#x4E00;&#x4E2A;&#x65B0;&#x7684; G &#x65F6;&#x53D1;&#x751F;&#x7ADE;&#x4E89;&#xFF0C;&#x6700;&#x7EC8;&#x5BFC;&#x81F4;&#x4EFB;&#x4F55;&#x4E00;&#x4E2A;&#x5DE5;&#x4F5C;&#x7EBF;&#x7A0B;&#x90FD;&#x9700;&#x8981;&#x6682;&#x6B62;&#x5BF9;&#x65B9;&#x3002; &#x5982;&#x679C;&#x53CC;&#x65B9;&#x5747;&#x53D1;&#x751F;&#x5931;&#x8D25;&#xFF0C;&#x5219;&#x4F1A;&#x4EE5;&#x534A;&#x9759;&#x6001; CPU &#x5229;&#x7528;&#x4E0D;&#x8DB3;&#x800C;&#x7ED3;&#x675F;&#x8C03;&#x5EA6;&#x3002;</p>
<p>&#x56E0;&#x6B64;&#xFF0C;&#x5C31;&#x7EEA;&#x4E00;&#x4E2A; G &#x7684;&#x901A;&#x7528;&#x6D41;&#x7A0B;&#x4E3A;&#xFF1A;</p>
<ul>
<li>&#x63D0;&#x4EA4;&#x4E00;&#x4E2A; G &#x5230; per-P &#x7684;&#x672C;&#x5730;&#x5DE5;&#x4F5C;&#x961F;&#x5217;</li>
<li>&#x6267;&#x884C; StoreLoad &#x98CE;&#x683C;&#x7684;&#x5199;&#x5C4F;&#x969C;</li>
<li>&#x68C0;&#x67E5; <code>sched.nmspinning</code> &#x6570;&#x91CF;</li>
</ul>
<p>&#x800C;&#x4ECE;&#x81EA;&#x65CB;&#x5230;&#x975E;&#x81EA;&#x65CB;&#x8F6C;&#x6362;&#x7684;&#x4E00;&#x822C;&#x6D41;&#x7A0B;&#x4E3A;&#xFF1A;</p>
<ul>
<li>&#x51CF;&#x5C11; <code>nmspinning</code> &#x7684;&#x6570;&#x91CF;</li>
<li>&#x6267;&#x884C; StoreLoad &#x98CE;&#x683C;&#x7684;&#x5199;&#x5C4F;&#x969C;</li>
<li>&#x5728;&#x6240;&#x6709; per-P &#x672C;&#x5730;&#x4EFB;&#x52A1;&#x961F;&#x5217;&#x68C0;&#x67E5;&#x65B0;&#x7684;&#x5DE5;&#x4F5C;</li>
</ul>
<p>&#x5F53;&#x7136;&#xFF0C;&#x6B64;&#x79CD;&#x590D;&#x6742;&#x6027;&#x5728;&#x5168;&#x5C40;&#x4EFB;&#x52A1;&#x961F;&#x5217;&#x5BF9;&#x5168;&#x5C40;&#x961F;&#x5217;&#x5E76;&#x4E0D;&#x9002;&#x7528;&#x7684;&#xFF0C;&#x56E0;&#x4E3A;&#x5F53;&#x7ED9;&#x4E00;&#x4E2A;&#x5168;&#x5C40;&#x961F;&#x5217;&#x63D0;&#x4EA4;&#x5DE5;&#x4F5C;&#x65F6;&#xFF0C; &#x4E0D;&#x8FDB;&#x884C;&#x7EBF;&#x7A0B;&#x7684;&#x590D;&#x59CB;&#x64CD;&#x4F5C;&#x3002;</p>
<h2 id="3&#x3001;&#x4E3B;&#x8981;&#x7ED3;&#x6784;">3&#x3001;&#x4E3B;&#x8981;&#x7ED3;&#x6784;</h2>
<h3 id="m&#x7684;&#x7ED3;&#x6784;">M&#x7684;&#x7ED3;&#x6784;</h3>
<p>M &#x662F; OS &#x7EBF;&#x7A0B;&#x7684;&#x5B9E;&#x4F53;&#x3002;&#x6211;&#x4EEC;&#x4ECB;&#x7ECD;&#x51E0;&#x4E2A;&#x6BD4;&#x8F83;&#x91CD;&#x8981;&#x7684;&#x5B57;&#x6BB5;&#xFF0C;&#x5305;&#x62EC;&#xFF1A;</p>
<ul>
<li>&#x6301;&#x6709;&#x7528;&#x4E8E;&#x6267;&#x884C;&#x8C03;&#x5EA6;&#x5668;&#x7684; g0</li>
<li>&#x6301;&#x6709;&#x7528;&#x4E8E;&#x4FE1;&#x53F7;&#x5904;&#x7406;&#x7684; gsignal</li>
<li>&#x6301;&#x6709;&#x7EBF;&#x7A0B;&#x672C;&#x5730;&#x5B58;&#x50A8; tls</li>
<li>&#x6301;&#x6709;&#x5F53;&#x524D;&#x6B63;&#x5728;&#x8FD0;&#x884C;&#x7684; curg</li>
<li>&#x6301;&#x6709;&#x8FD0;&#x884C; Goroutine &#x65F6;&#x9700;&#x8981;&#x7684;&#x672C;&#x5730;&#x8D44;&#x6E90; p</li>
<li>&#x8868;&#x793A;&#x81EA;&#x8EAB;&#x7684;&#x81EA;&#x65CB;&#x548C;&#x975E;&#x81EA;&#x65CB;&#x72B6;&#x6001; spining</li>
<li>&#x7BA1;&#x7406;&#x5728;&#x5B83;&#x8EAB;&#x4E0A;&#x6267;&#x884C;&#x7684; cgo &#x8C03;&#x7528;</li>
<li>&#x5C06;&#x81EA;&#x5DF1;&#x4E0E;&#x5176;&#x4ED6;&#x7684; M &#x8FDB;&#x884C;&#x4E32;&#x8054;</li>
<li>&#x6301;&#x6709;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E0A;&#x8FDB;&#x884C;&#x5185;&#x5B58;&#x5206;&#x914D;&#x7684;&#x672C;&#x5730;&#x7F13;&#x5B58; mcache</li>
</ul>
<p>&#x7B49;&#x7B49;&#x5176;&#x4ED6;&#x4E94;&#x5341;&#x591A;&#x4E2A;&#x5B57;&#x6BB5;&#xFF0C;&#x5305;&#x62EC;&#x5173;&#x4E8E; M &#x7684;&#x4E00;&#x4E9B;&#x8C03;&#x5EA6;&#x7EDF;&#x8BA1;&#x3001;&#x8C03;&#x8BD5;&#x4FE1;&#x606F;&#x7B49;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// src/runtime/runtime2.go</span>
<span class="hljs-keyword">type</span> m <span class="hljs-keyword">struct</span> {
    g0      *g     <span class="hljs-comment">// goroutine with scheduling stack &#x6267;&#x884C;&#x8C03;&#x5EA6;&#x6307;&#x4EE4;&#x7684;&#x534F;&#x7A0B;</span>
    morebuf gobuf  <span class="hljs-comment">// gobuf arg to morestack</span>
    divmod  <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// div/mod denominator for arm - known to liblink</span>
    _       <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// align next field to 8 bytes</span>

    <span class="hljs-comment">// Fields not known to debuggers.</span>
    procid        <span class="hljs-keyword">uint64</span>            <span class="hljs-comment">// for debuggers, but offset not hard-coded</span>
    gsignal       *g                <span class="hljs-comment">// signal-handling g &#x5904;&#x7406;signal&#x7684;g</span>
    goSigStack    gsignalStack      <span class="hljs-comment">// Go-allocated signal handling stack</span>
    sigmask       sigset            <span class="hljs-comment">// storage for saved signal mask</span>
    tls           [tlsSlots]<span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// thread-local storage (for x86 extern register) &#x7EBF;&#x7A0B;&#x672C;&#x5730;&#x5B58;&#x50A8;</span>
    mstartfn      <span class="hljs-keyword">func</span>()
    curg          *g       <span class="hljs-comment">// current running goroutine &#x5F53;&#x524D;&#x6B63;&#x5728;&#x8FD0;&#x884C;&#x7684;&#x534F;&#x7A0B;</span>
    caughtsig     guintptr <span class="hljs-comment">// goroutine running during fatal signal</span>
    p             puintptr <span class="hljs-comment">// attached p for executing go code (nil if not executing go code) &#x6267;&#x884C;go&#x4EE3;&#x7801;&#x65F6;&#x6301;&#x6709;&#x7684;p</span>
    nextp         puintptr
    oldp          puintptr <span class="hljs-comment">// the p that was attached before executing a syscall</span>
    id            <span class="hljs-keyword">int64</span>
    mallocing     <span class="hljs-keyword">int32</span>
    throwing      throwType
    preemptoff    <span class="hljs-keyword">string</span> <span class="hljs-comment">// if != &quot;&quot;, keep curg running on this m</span>
    locks         <span class="hljs-keyword">int32</span>
    dying         <span class="hljs-keyword">int32</span>
    profilehz     <span class="hljs-keyword">int32</span>
    spinning      <span class="hljs-keyword">bool</span> <span class="hljs-comment">// m is out of work and is actively looking for work m &#x5F53;&#x524D;&#x6CA1;&#x6709;&#x8FD0;&#x884C; work &#x4E14;&#x6B63;&#x5904;&#x4E8E;&#x5BFB;&#x627E; work &#x7684;&#x6D3B;&#x8DC3;&#x72B6;&#x6001;</span>
    blocked       <span class="hljs-keyword">bool</span> <span class="hljs-comment">// m is blocked on a note</span>
    newSigstack   <span class="hljs-keyword">bool</span> <span class="hljs-comment">// minit on C thread called sigaltstack</span>
    printlock     <span class="hljs-keyword">int8</span>
    incgo         <span class="hljs-keyword">bool</span>          <span class="hljs-comment">// m is executing a cgo call</span>
    isextra       <span class="hljs-keyword">bool</span>          <span class="hljs-comment">// m is an extra m</span>
    freeWait      atomic.Uint32 <span class="hljs-comment">// Whether it is safe to free g0 and delete m (one of freeMRef, freeMStack, freeMWait)</span>
    fastrand      <span class="hljs-keyword">uint64</span>
    needextram    <span class="hljs-keyword">bool</span>
    traceback     <span class="hljs-keyword">uint8</span>
    ncgocall      <span class="hljs-keyword">uint64</span>        <span class="hljs-comment">// number of cgo calls in total</span>
    ncgo          <span class="hljs-keyword">int32</span>         <span class="hljs-comment">// number of cgo calls currently in progress</span>
    cgoCallersUse atomic.Uint32 <span class="hljs-comment">// if non-zero, cgoCallers in use temporarily</span>
    cgoCallers    *cgoCallers   <span class="hljs-comment">// cgo traceback if crashing in cgo call cgo &#x8C03;&#x7528;&#x5D29;&#x6E83;&#x7684; cgo &#x56DE;&#x6EAF;</span>
    park          note
    alllink       *m <span class="hljs-comment">// on allm &#x5728; allm &#x4E0A;</span>
    schedlink     muintptr
    lockedg       guintptr
    createstack   [<span class="hljs-number">32</span>]<span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// stack that created this thread.</span>
    lockedExt     <span class="hljs-keyword">uint32</span>      <span class="hljs-comment">// tracking for external LockOSThread</span>
    lockedInt     <span class="hljs-keyword">uint32</span>      <span class="hljs-comment">// tracking for internal lockOSThread</span>
    nextwaitm     muintptr    <span class="hljs-comment">// next m waiting for lock</span>
    waitunlockf   <span class="hljs-keyword">func</span>(*g, unsafe.Pointer) <span class="hljs-keyword">bool</span>
    waitlock      unsafe.Pointer
    waittraceev   <span class="hljs-keyword">byte</span>
    waittraceskip <span class="hljs-keyword">int</span>
    startingtrace <span class="hljs-keyword">bool</span>
    syscalltick   <span class="hljs-keyword">uint32</span>
    freelink      *m <span class="hljs-comment">// on sched.freem</span>

    <span class="hljs-comment">// these are here because they are too large to be on the stack</span>
    <span class="hljs-comment">// of low-level NOSPLIT functions.</span>
    libcall   libcall
    libcallpc <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// for cpu profiler</span>
    libcallsp <span class="hljs-keyword">uintptr</span>
    libcallg  guintptr
    syscall   libcall <span class="hljs-comment">// stores syscall parameters on windows</span>

    vdsoSP <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// SP for traceback while in VDSO call (0 if not in call)</span>
    vdsoPC <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// PC for traceback while in VDSO call</span>

    <span class="hljs-comment">// preemptGen counts the number of completed preemption</span>
    <span class="hljs-comment">// signals. This is used to detect when a preemption is</span>
    <span class="hljs-comment">// requested, but fails.</span>
    preemptGen atomic.Uint32

    <span class="hljs-comment">// Whether this is a pending preemption signal on this M.</span>
    signalPending atomic.Uint32

    dlogPerM

    mOS

    <span class="hljs-comment">// Up to 10 locks held by this m, maintained by the lock ranking code.</span>
    locksHeldLen <span class="hljs-keyword">int</span>
    locksHeld    [<span class="hljs-number">10</span>]heldLockInfo
}
</code></pre>
<h3 id="p&#x7684;&#x7ED3;&#x6784;">P&#x7684;&#x7ED3;&#x6784;</h3>
<p>P &#x53EA;&#x662F;&#x5904;&#x7406;&#x5668;&#x7684;&#x62BD;&#x8C61;&#xFF0C;&#x800C;&#x975E;&#x5904;&#x7406;&#x5668;&#x672C;&#x8EAB;&#xFF0C;&#x5B83;&#x5B58;&#x5728;&#x7684;&#x610F;&#x4E49;&#x5728;&#x4E8E;&#x5B9E;&#x73B0;&#x5DE5;&#x4F5C;&#x7A83;&#x53D6;&#xFF08;work stealing&#xFF09;&#x7B97;&#x6CD5;&#x3002; &#x7B80;&#x5355;&#x6765;&#x8BF4;&#xFF0C;&#x6BCF;&#x4E2A; P &#x6301;&#x6709;&#x4E00;&#x4E2A; G &#x7684;&#x672C;&#x5730;&#x961F;&#x5217;&#x3002;</p>
<p><span style="color: red">P &#x662F; M &#x6267;&#x884C; Goroutine &#x6240;&#x9700;&#x7684;&#x8D44;&#x6E90;&#x3002;</span></p>
<p>P&#x4F1A;&#x7BA1;&#x7406;&#x672C;&#x5730;&#x7684;&#x534F;&#x7A0B;&#x961F;&#x5217;&#x4EE5;&#x53CA;&#x4E0E;M&#x4E4B;&#x95F4;&#x7684;&#x4EFB;&#x52A1;&#x5206;&#x914D;&#x3002;</p>
<p>&#x5728;&#x6CA1;&#x6709; P &#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x6240;&#x6709;&#x7684; G &#x53EA;&#x80FD;&#x653E;&#x5728;&#x4E00;&#x4E2A;&#x5168;&#x5C40;&#x7684;&#x961F;&#x5217;&#x4E2D;&#x3002; &#x5F53; M &#x6267;&#x884C;&#x5B8C; G &#x800C;&#x6CA1;&#x6709; G &#x53EF;&#x6267;&#x884C;&#x65F6;&#xFF0C;&#x5FC5;&#x987B;&#x5C06;&#x961F;&#x5217;&#x9501;&#x4F4F;&#x4ECE;&#x800C;&#x53D6;&#x503C;&#x3002;</p>
<p>&#x5F53;&#x5F15;&#x5165;&#x4E86; P &#x4E4B;&#x540E;&#xFF0C;P &#x6301;&#x6709; G &#x7684;&#x672C;&#x5730;&#x961F;&#x5217;&#xFF0C;&#x800C;&#x6301;&#x6709; P &#x7684; M &#x6267;&#x884C;&#x5B8C; G &#x540E;&#x5728; P &#x672C;&#x5730;&#x961F;&#x5217;&#x4E2D;&#x6CA1;&#x6709; &#x53D1;&#x73B0;&#x5176;&#x4ED6; G &#x53EF;&#x4EE5;&#x6267;&#x884C;&#x65F6;&#xFF0C;&#x867D;&#x7136;&#x4ECD;&#x7136;&#x4F1A;&#x5148;&#x68C0;&#x67E5;&#x5168;&#x5C40;&#x961F;&#x5217;&#x3001;&#x7F51;&#x7EDC;&#xFF0C;&#x4F46;&#x8FD9;&#x65F6;&#x589E;&#x52A0;&#x4E86;&#x4E00;&#x4E2A;&#x4ECE;&#x5176;&#x4ED6; P &#x7684; &#x961F;&#x5217;&#x5077;&#x53D6;&#xFF08;steal&#xFF09;&#x4E00;&#x4E2A; G &#x6765;&#x6267;&#x884C;&#x7684;&#x8FC7;&#x7A0B;&#x3002;&#x4F18;&#x5148;&#x7EA7;&#x4E3A;&#x672C;&#x5730; &gt; &#x5168;&#x5C40; &gt; &#x7F51;&#x7EDC; &gt; &#x5077;&#x53D6;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> {
    id          <span class="hljs-keyword">int32</span>
    status      <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// one of pidle/prunning/... p&#x7684;&#x72B6;&#x6001;</span>
    link        puintptr
    schedtick   <span class="hljs-keyword">uint32</span>     <span class="hljs-comment">// incremented on every scheduler call</span>
    syscalltick <span class="hljs-keyword">uint32</span>     <span class="hljs-comment">// incremented on every system call</span>
    sysmontick  sysmontick <span class="hljs-comment">// last tick observed by sysmon</span>
    m           muintptr   <span class="hljs-comment">// back-link to associated m (nil if idle) &#x53CD;&#x5411;&#x94FE;&#x63A5;&#x5230;&#x5173;&#x8054;&#x7684;M</span>
    mcache      *mcache
    pcache      pageCache
    raceprocctx <span class="hljs-keyword">uintptr</span>

    <span class="hljs-comment">// &#x4E0D;&#x540C;&#x5927;&#x5C0F;&#x7684;&#x672C;&#x5730;defer&#x6C60;</span>
    deferpool    []*_defer <span class="hljs-comment">// pool of available defer structs (see panic.go) // &#x4E0D;&#x540C;&#x5927;&#x5C0F;&#x7684;&#x53EF;&#x7528;&#x7684; defer &#x7ED3;&#x6784;&#x6C60;</span>
    deferpoolbuf [<span class="hljs-number">32</span>]*_defer

    <span class="hljs-comment">// Cache of goroutine ids, amortizes accesses to runtime&#xB7;sched.goidgen.</span>
    goidcache    <span class="hljs-keyword">uint64</span>
    goidcacheend <span class="hljs-keyword">uint64</span>

    <span class="hljs-comment">// Queue of runnable goroutines. Accessed without lock.</span>
    <span class="hljs-comment">// &#x53EF;&#x8FD0;&#x884C;&#x7684; Goroutine &#x961F;&#x5217;&#xFF0C;&#x53EF;&#x65E0;&#x9501;&#x8BBF;&#x95EE;</span>
    runqhead <span class="hljs-keyword">uint32</span>
    runqtail <span class="hljs-keyword">uint32</span>
    runq     [<span class="hljs-number">256</span>]guintptr
    <span class="hljs-comment">// runnext, if non-nil, is a runnable G that was ready&apos;d by</span>
    <span class="hljs-comment">// the current G and should be run next instead of what&apos;s in</span>
    <span class="hljs-comment">// runq if there&apos;s time remaining in the running G&apos;s time</span>
    <span class="hljs-comment">// slice. It will inherit the time left in the current time</span>
    <span class="hljs-comment">// slice. If a set of goroutines is locked in a</span>
    <span class="hljs-comment">// communicate-and-wait pattern, this schedules that set as a</span>
    <span class="hljs-comment">// unit and eliminates the (potentially large) scheduling</span>
    <span class="hljs-comment">// latency that otherwise arises from adding the ready&apos;d</span>
    <span class="hljs-comment">// goroutines to the end of the run queue.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Note that while other P&apos;s may atomically CAS this to zero,</span>
    <span class="hljs-comment">// only the owner P can CAS it to a valid G.</span>
    runnext guintptr

    <span class="hljs-comment">// Available G&apos;s (status == Gdead)</span>
    gFree <span class="hljs-keyword">struct</span> {
        gList
        n <span class="hljs-keyword">int32</span>
    }

    sudogcache []*sudog
    sudogbuf   [<span class="hljs-number">128</span>]*sudog

    <span class="hljs-comment">// Cache of mspan objects from the heap.</span>
    mspancache <span class="hljs-keyword">struct</span> {
        <span class="hljs-comment">// We need an explicit length here because this field is used</span>
        <span class="hljs-comment">// in allocation codepaths where write barriers are not allowed,</span>
        <span class="hljs-comment">// and eliminating the write barrier/keeping it eliminated from</span>
        <span class="hljs-comment">// slice updates is tricky, moreso than just managing the length</span>
        <span class="hljs-comment">// ourselves.</span>
        <span class="hljs-built_in">len</span> <span class="hljs-keyword">int</span>
        buf [<span class="hljs-number">128</span>]*mspan
    }

    tracebuf traceBufPtr

    <span class="hljs-comment">// traceSweep indicates the sweep events should be traced.</span>
    <span class="hljs-comment">// This is used to defer the sweep start event until a span</span>
    <span class="hljs-comment">// has actually been swept.</span>
    traceSweep <span class="hljs-keyword">bool</span>
    <span class="hljs-comment">// traceSwept and traceReclaimed track the number of bytes</span>
    <span class="hljs-comment">// swept and reclaimed by sweeping in the current sweep loop.</span>
    traceSwept, traceReclaimed <span class="hljs-keyword">uintptr</span>

    palloc persistentAlloc <span class="hljs-comment">// per-P to avoid mutex</span>

    <span class="hljs-comment">// The when field of the first entry on the timer heap.</span>
    <span class="hljs-comment">// This is 0 if the timer heap is empty.</span>
    timer0When atomic.Int64

    <span class="hljs-comment">// The earliest known nextwhen field of a timer with</span>
    <span class="hljs-comment">// timerModifiedEarlier status. Because the timer may have been</span>
    <span class="hljs-comment">// modified again, there need not be any timer with this value.</span>
    <span class="hljs-comment">// This is 0 if there are no timerModifiedEarlier timers.</span>
    timerModifiedEarliest atomic.Int64

    <span class="hljs-comment">// Per-P GC state</span>
    gcAssistTime         <span class="hljs-keyword">int64</span> <span class="hljs-comment">// Nanoseconds in assistAlloc</span>
    gcFractionalMarkTime <span class="hljs-keyword">int64</span> <span class="hljs-comment">// Nanoseconds in fractional mark worker (atomic)</span>

    <span class="hljs-comment">// limiterEvent tracks events for the GC CPU limiter.</span>
    limiterEvent limiterEvent

    <span class="hljs-comment">// gcMarkWorkerMode is the mode for the next mark worker to run in.</span>
    <span class="hljs-comment">// That is, this is used to communicate with the worker goroutine</span>
    <span class="hljs-comment">// selected for immediate execution by</span>
    <span class="hljs-comment">// gcController.findRunnableGCWorker. When scheduling other goroutines,</span>
    <span class="hljs-comment">// this field must be set to gcMarkWorkerNotWorker.</span>
    gcMarkWorkerMode gcMarkWorkerMode
    <span class="hljs-comment">// gcMarkWorkerStartTime is the nanotime() at which the most recent</span>
    <span class="hljs-comment">// mark worker started.</span>
    gcMarkWorkerStartTime <span class="hljs-keyword">int64</span>

    <span class="hljs-comment">// gcw is this P&apos;s GC work buffer cache. The work buffer is</span>
    <span class="hljs-comment">// filled by write barriers, drained by mutator assists, and</span>
    <span class="hljs-comment">// disposed on certain GC state transitions.</span>
    gcw gcWork

    <span class="hljs-comment">// wbBuf is this P&apos;s GC write barrier buffer.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Consider caching this in the running G.</span>
    wbBuf wbBuf

    runSafePointFn <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// if 1, run sched.safePointFn at next safe point</span>

    <span class="hljs-comment">// statsSeq is a counter indicating whether this P is currently</span>
    <span class="hljs-comment">// writing any stats. Its value is even when not, odd when it is.</span>
    statsSeq atomic.Uint32

    <span class="hljs-comment">// Lock for timers. We normally access the timers while running</span>
    <span class="hljs-comment">// on this P, but the scheduler can also do it from a different P.</span>
    timersLock mutex

    <span class="hljs-comment">// Actions to take at some time. This is used to implement the</span>
    <span class="hljs-comment">// standard library&apos;s time package.</span>
    <span class="hljs-comment">// Must hold timersLock to access.</span>
    timers []*timer

    <span class="hljs-comment">// Number of timers in P&apos;s heap.</span>
    numTimers atomic.Uint32

    <span class="hljs-comment">// Number of timerDeleted timers in P&apos;s heap.</span>
    deletedTimers atomic.Uint32

    <span class="hljs-comment">// Race context used while executing timer functions.</span>
    timerRaceCtx <span class="hljs-keyword">uintptr</span>

    <span class="hljs-comment">// maxStackScanDelta accumulates the amount of stack space held by</span>
    <span class="hljs-comment">// live goroutines (i.e. those eligible for stack scanning).</span>
    <span class="hljs-comment">// Flushed to gcController.maxStackScan once maxStackScanSlack</span>
    <span class="hljs-comment">// or -maxStackScanSlack is reached.</span>
    maxStackScanDelta <span class="hljs-keyword">int64</span>

    <span class="hljs-comment">// gc-time statistics about current goroutines</span>
    <span class="hljs-comment">// Note that this differs from maxStackScan in that this</span>
    <span class="hljs-comment">// accumulates the actual stack observed to be used at GC time (hi - sp),</span>
    <span class="hljs-comment">// not an instantaneous measure of the total stack size that might need</span>
    <span class="hljs-comment">// to be scanned (hi - lo).</span>
    scannedStackSize <span class="hljs-keyword">uint64</span> <span class="hljs-comment">// stack size of goroutines scanned by this P</span>
    scannedStacks    <span class="hljs-keyword">uint64</span> <span class="hljs-comment">// number of goroutines scanned by this P</span>

    <span class="hljs-comment">// preempt is set to indicate that this P should be enter the</span>
    <span class="hljs-comment">// scheduler ASAP (regardless of what G is running on it).</span>
    preempt <span class="hljs-keyword">bool</span>

    <span class="hljs-comment">// pageTraceBuf is a buffer for writing out page allocation/free/scavenge traces.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Used only if GOEXPERIMENT=pagetrace.</span>
    pageTraceBuf pageTraceBuf

    <span class="hljs-comment">// Padding is no longer needed. False sharing is now not a worry because p is large enough</span>
    <span class="hljs-comment">// that its size class is an integer multiple of the cache line size (for any of our architectures).</span>
}
</code></pre>
<h3 id="g&#x7684;&#x7ED3;&#x6784;">G&#x7684;&#x7ED3;&#x6784;</h3>
<p>G&#x662F;&#x534F;&#x7A0B;&#xFF0C;&#x5FC5;&#x7136;&#x9700;&#x8981;&#x5B9A;&#x4E49;&#x81EA;&#x8EAB;&#x7684;&#x6267;&#x884C;&#x6808;&#x3002;</p>
<p>&#x5C06;&#x9700;&#x8981;&#x6267;&#x884C;&#x7684;&#x51FD;&#x6570;&#x53C2;&#x6570;&#x8FDB;&#x884C;&#x4E86;&#x62F7;&#x8D1D;&#xFF0C;&#x4FDD;&#x5B58;&#x4E86;&#x8981;&#x6267;&#x884C;&#x7684;&#x51FD;&#x6570;&#x4F53;&#x7684;&#x5165;&#x53E3;&#x5730;&#x5740;&#xFF0C;&#x7528;&#x4E8E;&#x6267;&#x884C;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// Stack parameters.</span>
    <span class="hljs-comment">// stack describes the actual stack memory: [stack.lo, stack.hi).</span>
    <span class="hljs-comment">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span>
    <span class="hljs-comment">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span>
    <span class="hljs-comment">// stackguard1 is the stack pointer compared in the C stack growth prologue.</span>
    <span class="hljs-comment">// It is stack.lo+StackGuard on g0 and gsignal stacks.</span>
    <span class="hljs-comment">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</span>
    stack       stack   <span class="hljs-comment">// offset known to runtime/cgo &#x6808;&#x5185;&#x5B58;</span>
    stackguard0 <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// offset known to liblink</span>
    stackguard1 <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// offset known to liblink</span>

    _panic    *_panic <span class="hljs-comment">// innermost panic - offset known to liblink</span>
    _defer    *_defer <span class="hljs-comment">// innermost defer</span>
    m         *m      <span class="hljs-comment">// current m; offset known to arm liblink &#x5F53;&#x524D;m</span>
    sched     gobuf
    syscallsp <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span>
    syscallpc <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span>
    stktopsp  <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// expected sp at top of stack, to check in traceback // &#x671F;&#x671B; sp &#x4F4D;&#x4E8E;&#x6808;&#x9876;&#xFF0C;&#x7528;&#x4E8E;&#x56DE;&#x6EAF;&#x68C0;&#x67E5;</span>
    <span class="hljs-comment">// param is a generic pointer parameter field used to pass</span>
    <span class="hljs-comment">// values in particular contexts where other storage for the</span>
    <span class="hljs-comment">// parameter would be difficult to find. It is currently used</span>
    <span class="hljs-comment">// in three ways:</span>
    <span class="hljs-comment">// 1. When a channel operation wakes up a blocked goroutine, it sets param to</span>
    <span class="hljs-comment">//    point to the sudog of the completed blocking operation.</span>
    <span class="hljs-comment">// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed</span>
    <span class="hljs-comment">//    the GC cycle. It is unsafe to do so in any other way, because the goroutine&apos;s</span>
    <span class="hljs-comment">//    stack may have moved in the meantime.</span>
    <span class="hljs-comment">// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a</span>
    <span class="hljs-comment">//    closure in the runtime is forbidden.</span>
    param        unsafe.Pointer <span class="hljs-comment">// wakeup &#x5524;&#x9192;&#x65F6;&#x5019;&#x4F20;&#x9012;&#x7684;&#x53C2;&#x6570;</span>
    atomicstatus atomic.Uint32
    stackLock    <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// sigprof/scang lock; <span class="hljs-doctag">TODO:</span> fold in to atomicstatus</span>
    goid         <span class="hljs-keyword">uint64</span>
    schedlink    guintptr
    waitsince    <span class="hljs-keyword">int64</span>      <span class="hljs-comment">// approx time when the g become blocked</span>
    waitreason   waitReason <span class="hljs-comment">// if status==Gwaiting</span>

    preempt       <span class="hljs-keyword">bool</span> <span class="hljs-comment">// preemption signal, duplicates stackguard0 = stackpreempt // &#x62A2;&#x5360;&#x4FE1;&#x53F7;&#xFF0C;stackguard0 = stackpreempt &#x7684;&#x526F;&#x672C;</span>
    preemptStop   <span class="hljs-keyword">bool</span> <span class="hljs-comment">// transition to _Gpreempted on preemption; otherwise, just deschedule</span>
    preemptShrink <span class="hljs-keyword">bool</span> <span class="hljs-comment">// shrink stack at synchronous safe point</span>

    <span class="hljs-comment">// asyncSafePoint is set if g is stopped at an asynchronous</span>
    <span class="hljs-comment">// safe point. This means there are frames on the stack</span>
    <span class="hljs-comment">// without precise pointer information.</span>
    asyncSafePoint <span class="hljs-keyword">bool</span>

    paniconfault <span class="hljs-keyword">bool</span> <span class="hljs-comment">// panic (instead of crash) on unexpected fault address</span>
    gcscandone   <span class="hljs-keyword">bool</span> <span class="hljs-comment">// g has scanned stack; protected by _Gscan bit in status</span>
    throwsplit   <span class="hljs-keyword">bool</span> <span class="hljs-comment">// must not split stack</span>
    <span class="hljs-comment">// activeStackChans indicates that there are unlocked channels</span>
    <span class="hljs-comment">// pointing into this goroutine&apos;s stack. If true, stack</span>
    <span class="hljs-comment">// copying needs to acquire channel locks to protect these</span>
    <span class="hljs-comment">// areas of the stack.</span>
    activeStackChans <span class="hljs-keyword">bool</span>
    <span class="hljs-comment">// parkingOnChan indicates that the goroutine is about to</span>
    <span class="hljs-comment">// park on a chansend or chanrecv. Used to signal an unsafe point</span>
    <span class="hljs-comment">// for stack shrinking.</span>
    parkingOnChan atomic.Bool

    raceignore     <span class="hljs-keyword">int8</span>     <span class="hljs-comment">// ignore race detection events</span>
    sysblocktraced <span class="hljs-keyword">bool</span>     <span class="hljs-comment">// StartTrace has emitted EvGoInSyscall about this goroutine</span>
    tracking       <span class="hljs-keyword">bool</span>     <span class="hljs-comment">// whether we&apos;re tracking this G for sched latency statistics</span>
    trackingSeq    <span class="hljs-keyword">uint8</span>    <span class="hljs-comment">// used to decide whether to track this G</span>
    trackingStamp  <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// timestamp of when the G last started being tracked</span>
    runnableTime   <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// the amount of time spent runnable, cleared when running, only used when tracking</span>
    sysexitticks   <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// cputicks when syscall has returned (for tracing)</span>
    traceseq       <span class="hljs-keyword">uint64</span>   <span class="hljs-comment">// trace event sequencer</span>
    tracelastp     puintptr <span class="hljs-comment">// last P emitted an event for this goroutine</span>
    lockedm        muintptr
    sig            <span class="hljs-keyword">uint32</span>
    writebuf       []<span class="hljs-keyword">byte</span>
    sigcode0       <span class="hljs-keyword">uintptr</span>
    sigcode1       <span class="hljs-keyword">uintptr</span>
    sigpc          <span class="hljs-keyword">uintptr</span>
    gopc           <span class="hljs-keyword">uintptr</span>         <span class="hljs-comment">// pc of go statement that created this goroutine</span>
    ancestors      *[]ancestorInfo <span class="hljs-comment">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)</span>
    startpc        <span class="hljs-keyword">uintptr</span>         <span class="hljs-comment">// pc of goroutine function</span>
    racectx        <span class="hljs-keyword">uintptr</span>
    waiting        *sudog         <span class="hljs-comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span>
    cgoCtxt        []<span class="hljs-keyword">uintptr</span>      <span class="hljs-comment">// cgo traceback context</span>
    labels         unsafe.Pointer <span class="hljs-comment">// profiler labels</span>
    timer          *timer         <span class="hljs-comment">// cached timer for time.Sleep // &#x4E3A; time.Sleep &#x7F13;&#x5B58;&#x7684;&#x8BA1;&#x65F6;&#x5668;</span>
    selectDone     atomic.Uint32  <span class="hljs-comment">// are we participating in a select and did someone win the race?</span>

    <span class="hljs-comment">// goroutineProfiled indicates the status of this goroutine&apos;s stack for the</span>
    <span class="hljs-comment">// current in-progress goroutine profile</span>
    goroutineProfiled goroutineProfileStateHolder

    <span class="hljs-comment">// Per-G GC state</span>

    <span class="hljs-comment">// gcAssistBytes is this G&apos;s GC assist credit in terms of</span>
    <span class="hljs-comment">// bytes allocated. If this is positive, then the G has credit</span>
    <span class="hljs-comment">// to allocate gcAssistBytes bytes without assisting. If this</span>
    <span class="hljs-comment">// is negative, then the G must correct this by performing</span>
    <span class="hljs-comment">// scan work. We track this in bytes to make it fast to update</span>
    <span class="hljs-comment">// and check for debt in the malloc hot path. The assist ratio</span>
    <span class="hljs-comment">// determines how this corresponds to scan work debt.</span>
    gcAssistBytes <span class="hljs-keyword">int64</span>
}
</code></pre>
<h3 id="&#x8C03;&#x5EA6;&#x5668;&#x7ED3;&#x6784;">&#x8C03;&#x5EA6;&#x5668;&#x7ED3;&#x6784;</h3>
<p>&#x8C03;&#x5EA6;&#x5668;&#xFF0C;&#x6240;&#x6709; Goroutine &#x88AB;&#x8C03;&#x5EA6;&#x7684;&#x6838;&#x5FC3;&#xFF0C;&#x5B58;&#x653E;&#x4E86;&#x8C03;&#x5EA6;&#x5668;&#x6301;&#x6709;&#x7684;&#x5168;&#x5C40;&#x8D44;&#x6E90;&#xFF0C;&#x8BBF;&#x95EE;&#x8FD9;&#x4E9B;&#x8D44;&#x6E90;&#x9700;&#x8981;&#x6301;&#x6709;&#x9501;&#xFF1A;</p>
<ul>
<li>&#x7BA1;&#x7406;&#x4E86;&#x80FD;&#x591F;&#x5C06; G &#x548C; M &#x8FDB;&#x884C;&#x7ED1;&#x5B9A;&#x7684; M &#x961F;&#x5217;</li>
<li>&#x7BA1;&#x7406;&#x4E86;&#x7A7A;&#x95F2;&#x7684; P &#x94FE;&#x8868;&#xFF08;&#x961F;&#x5217;&#xFF09;</li>
<li>&#x7BA1;&#x7406;&#x4E86; G &#x7684;&#x5168;&#x5C40;&#x961F;&#x5217;</li>
<li>&#x7BA1;&#x7406;&#x4E86;&#x53EF;&#x88AB;&#x590D;&#x7528;&#x7684; G &#x7684;&#x5168;&#x5C40;&#x7F13;&#x5B58;</li>
<li>&#x7BA1;&#x7406;&#x4E86; defer &#x6C60;</li>
</ul>
<pre><code class="lang-go"><span class="hljs-keyword">type</span> schedt <span class="hljs-keyword">struct</span> {
    goidgen   atomic.Uint64
    lastpoll  atomic.Int64 <span class="hljs-comment">// time of last network poll, 0 if currently polling</span>
    pollUntil atomic.Int64 <span class="hljs-comment">// time to which current poll is sleeping</span>

    lock mutex

    <span class="hljs-comment">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be</span>
    <span class="hljs-comment">// sure to call checkdead().</span>

    midle        muintptr <span class="hljs-comment">// idle m&apos;s waiting for work</span>
    nmidle       <span class="hljs-keyword">int32</span>    <span class="hljs-comment">// number of idle m&apos;s waiting for work</span>
    nmidlelocked <span class="hljs-keyword">int32</span>    <span class="hljs-comment">// number of locked m&apos;s waiting for work</span>
    mnext        <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// number of m&apos;s that have been created and next M ID</span>
    maxmcount    <span class="hljs-keyword">int32</span>    <span class="hljs-comment">// maximum number of m&apos;s allowed (or die)</span>
    nmsys        <span class="hljs-keyword">int32</span>    <span class="hljs-comment">// number of system m&apos;s not counted for deadlock</span>
    nmfreed      <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// cumulative number of freed m&apos;s</span>

    ngsys atomic.Int32 <span class="hljs-comment">// number of system goroutines</span>

    pidle        puintptr      <span class="hljs-comment">// idle p&apos;s &#x7A7A;&#x95F2; p &#x94FE;&#x8868;</span>
    npidle       atomic.Int32  <span class="hljs-comment">// &#x7A7A;&#x95F2; p &#x6570;&#x91CF;</span>
    nmspinning   atomic.Int32  <span class="hljs-comment">// See &quot;Worker thread parking/unparking&quot; comment in proc.go. // &#x81EA;&#x65CB;&#x72B6;&#x6001;&#x7684; M &#x7684;&#x6570;&#x91CF;</span>
    needspinning atomic.Uint32 <span class="hljs-comment">// See &quot;Delicate dance&quot; comment in proc.go. Boolean. Must hold sched.lock to set to 1.</span>

    <span class="hljs-comment">// Global runnable queue.</span>
    runq     gQueue <span class="hljs-comment">// &#x5168;&#x5C40; runnable G &#x961F;&#x5217;</span>
    runqsize <span class="hljs-keyword">int32</span>

    <span class="hljs-comment">// disable controls selective disabling of the scheduler.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Use schedEnableUser to control this.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// disable is protected by sched.lock.</span>
    disable <span class="hljs-keyword">struct</span> {
        <span class="hljs-comment">// user disables scheduling of user goroutines.</span>
        user     <span class="hljs-keyword">bool</span>
        runnable gQueue <span class="hljs-comment">// pending runnable Gs</span>
        n        <span class="hljs-keyword">int32</span>  <span class="hljs-comment">// length of runnable</span>
    }

    <span class="hljs-comment">// Global cache of dead G&apos;s.</span>
    <span class="hljs-comment">// &#x6709;&#x6548; dead G &#x7684;&#x5168;&#x5C40;&#x7F13;&#x5B58;.</span>
    gFree <span class="hljs-keyword">struct</span> {
        lock    mutex
        stack   gList <span class="hljs-comment">// Gs with stacks // &#x5305;&#x542B;&#x6808;&#x7684; Gs</span>
        noStack gList <span class="hljs-comment">// Gs without stacks // &#x6CA1;&#x6709;&#x6808;&#x7684; Gs</span>
        n       <span class="hljs-keyword">int32</span>
    }

    <span class="hljs-comment">// Central cache of sudog structs.</span>
    <span class="hljs-comment">// sudog &#x7ED3;&#x6784;&#x7684;&#x96C6;&#x4E2D;&#x7F13;&#x5B58;</span>
    sudoglock  mutex
    sudogcache *sudog

    <span class="hljs-comment">// Central pool of available defer structs.</span>
    <span class="hljs-comment">// &#x4E0D;&#x540C;&#x5927;&#x5C0F;&#x7684;&#x5168;&#x5C40;defer&#x6C60;</span>
    deferlock mutex
    deferpool *_defer

    <span class="hljs-comment">// freem is the list of m&apos;s waiting to be freed when their</span>
    <span class="hljs-comment">// m.exited is set. Linked through m.freelink.</span>
    freem *m

    gcwaiting  atomic.Bool <span class="hljs-comment">// gc is waiting to run</span>
    stopwait   <span class="hljs-keyword">int32</span>
    stopnote   note
    sysmonwait atomic.Bool
    sysmonnote note

    <span class="hljs-comment">// safepointFn should be called on each P at the next GC</span>
    <span class="hljs-comment">// safepoint if p.runSafePointFn is set.</span>
    safePointFn   <span class="hljs-keyword">func</span>(*p)
    safePointWait <span class="hljs-keyword">int32</span>
    safePointNote note

    profilehz <span class="hljs-keyword">int32</span> <span class="hljs-comment">// cpu profiling rate</span>

    procresizetime <span class="hljs-keyword">int64</span> <span class="hljs-comment">// nanotime() of last change to gomaxprocs</span>
    totaltime      <span class="hljs-keyword">int64</span> <span class="hljs-comment">// &#x222B;gomaxprocs dt up to procresizetime</span>

    <span class="hljs-comment">// sysmonlock protects sysmon&apos;s actions on the runtime.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Acquire and hold this mutex to block sysmon from interacting</span>
    <span class="hljs-comment">// with the rest of the runtime.</span>
    sysmonlock mutex

    <span class="hljs-comment">// timeToRun is a distribution of scheduling latencies, defined</span>
    <span class="hljs-comment">// as the sum of time a G spends in the _Grunnable state before</span>
    <span class="hljs-comment">// it transitions to _Grunning.</span>
    timeToRun timeHistogram

    <span class="hljs-comment">// idleTime is the total CPU time Ps have &quot;spent&quot; idle.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Reset on each GC cycle.</span>
    idleTime atomic.Int64

    <span class="hljs-comment">// totalMutexWaitTime is the sum of time goroutines have spent in _Gwaiting</span>
    <span class="hljs-comment">// with a waitreason of the form waitReasonSync{RW,}Mutex{R,}Lock.</span>
    totalMutexWaitTime atomic.Int64
}
</code></pre>
<p>&#x8C03;&#x5EA6;&#x5668;&#x521D;&#x59CB;&#x5316;&#x7684;&#x6B65;&#x9AA4;</p>
<pre><code class="lang-go"><span class="hljs-comment">// runtime/proc.go</span>
<span class="hljs-keyword">func</span> schedinit() {
    _g_ := getg()
    (...)

    <span class="hljs-comment">// M &#x521D;&#x59CB;&#x5316;</span>
    mcommoninit(_g_.m)
    (...)

    <span class="hljs-comment">// P &#x521D;&#x59CB;&#x5316;</span>
    <span class="hljs-keyword">if</span> procresize(procs) != <span class="hljs-literal">nil</span> {
        throw(<span class="hljs-string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)
    }
    (...)
}
</code></pre>
<pre><code>TEXT runtime&#xB7;rt0_go(SB),NOSPLIT,$0
    (...)
    CALL    runtime&#xB7;schedinit(SB) // M, P &#x521D;&#x59CB;&#x5316;
    MOVQ    $runtime&#xB7;mainPC(SB), AX
    PUSHQ    AX
    PUSHQ    $0
    CALL    runtime&#xB7;newproc(SB) // G &#x521D;&#x59CB;&#x5316;
    POPQ    AX
    POPQ    AX
    (...)
    RET

DATA    runtime&#xB7;mainPC+0(SB)/8,$runtime&#xB7;main(SB)
GLOBL    runtime&#xB7;mainPC(SB),RODATA,$8
</code></pre><p><img src="../image/&#x8C03;&#x5EA6;&#x5668;&#x521D;&#x59CB;&#x5316;.png" alt="gobuild"></p>
<h4 id="m&#x7684;&#x521D;&#x59CB;&#x5316;">M&#x7684;&#x521D;&#x59CB;&#x5316;</h4>
<p>M&#x5176;&#x5B9E;&#x5C31;&#x662F;OS&#x7EBF;&#x7A0B;&#xFF0C;&#x5B83;&#x53EA;&#x6709;&#x4E24;&#x4E2A;&#x72B6;&#x6001;&#xFF1A;&#x81EA;&#x65CB;&#x3001;&#x975E;&#x81EA;&#x65CB;&#x3002;&#x5728;&#x8C03;&#x5EA6;&#x5668;&#x521D;&#x59CB;&#x5316;&#x9636;&#x6BB5;&#xFF0C;&#x53EA;&#x6709;&#x4E00;&#x4E2A;M&#xFF0C;&#x90A3;&#x5C31;&#x662F;&#x4E3B;OS&#x7EBF;&#x7A0B;&#xFF0C;&#x8FD9;&#x65F6;&#x4EC5;&#x4EC5;&#x5BF9;M&#x8FDB;&#x884C;&#x4E00;&#x4E2A;&#x521D;&#x6B65;&#x7684;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x8BE5;&#x521D;&#x59CB;&#x5316;&#x5305;&#x542B;&#x5BF9;M&#x53CA;&#x7528;&#x4E8E;&#x5904;&#x7406;M&#x4FE1;&#x53F7;&#x7684;G&#x7684;&#x76F8;&#x5173;&#x8FD0;&#x7B97;&#x64CD;&#x4F5C;&#xFF0C;&#x672A;&#x6D89;&#x53CA;&#x5DE5;&#x4F5C;&#x7EBF;&#x7A0B;&#x7684;&#x6682;&#x6B62;&#x548C;&#x590D;&#x59CB;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// src/runtime/proc.go</span>
<span class="hljs-keyword">func</span> mcommoninit(mp *m, id <span class="hljs-keyword">int64</span>) {
    gp := getg()

    <span class="hljs-comment">// g0 stack won&apos;t make sense for user (and is not necessary unwindable).</span>
    <span class="hljs-keyword">if</span> gp != gp.m.g0 {
        callers(<span class="hljs-number">1</span>, mp.createstack[:])
    }

    lock(&amp;sched.lock)

    <span class="hljs-keyword">if</span> id &gt;= <span class="hljs-number">0</span> {
        mp.id = id
    } <span class="hljs-keyword">else</span> {
        mp.id = mReserveID()
    }

    lo := <span class="hljs-keyword">uint32</span>(int64Hash(<span class="hljs-keyword">uint64</span>(mp.id), fastrandseed))
    hi := <span class="hljs-keyword">uint32</span>(int64Hash(<span class="hljs-keyword">uint64</span>(cputicks()), ^fastrandseed))
    <span class="hljs-keyword">if</span> lo|hi == <span class="hljs-number">0</span> {
        hi = <span class="hljs-number">1</span>
    }
    <span class="hljs-comment">// Same behavior as for 1.17.</span>
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Simplify ths.</span>
    <span class="hljs-keyword">if</span> goarch.BigEndian {
        mp.fastrand = <span class="hljs-keyword">uint64</span>(lo)&lt;&lt;<span class="hljs-number">32</span> | <span class="hljs-keyword">uint64</span>(hi)
    } <span class="hljs-keyword">else</span> {
        mp.fastrand = <span class="hljs-keyword">uint64</span>(hi)&lt;&lt;<span class="hljs-number">32</span> | <span class="hljs-keyword">uint64</span>(lo)
    }

    <span class="hljs-comment">// &#x521D;&#x59CB;&#x5316;gsignal&#xFF0C;&#x7528;&#x4E8E;&#x5904;&#x7406;m&#x4E0A;&#x7684;&#x4FE1;&#x53F7;</span>
    mpreinit(mp)
    <span class="hljs-keyword">if</span> mp.gsignal != <span class="hljs-literal">nil</span> {
        mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard
    }

    <span class="hljs-comment">// Add to allm so garbage collector doesn&apos;t free g-&gt;m</span>
    <span class="hljs-comment">// when it is just in a register or thread-local storage.</span>
    <span class="hljs-comment">// &#x6DFB;&#x52A0;&#x5230; allm &#x4E2D;&#xFF0C;&#x4ECE;&#x800C;&#x5F53;&#x5B83;&#x521A;&#x4FDD;&#x5B58;&#x5230;&#x5BC4;&#x5B58;&#x5668;&#x6216;&#x672C;&#x5730;&#x7EBF;&#x7A0B;&#x5B58;&#x50A8;&#x65F6;&#x5019; GC &#x4E0D;&#x4F1A;&#x91CA;&#x653E; g.m</span>
    mp.alllink = allm

    <span class="hljs-comment">// NumCgoCall() iterates over allm w/o schedlock,</span>
    <span class="hljs-comment">// so we need to publish it safely.</span>
    <span class="hljs-comment">// NumCgoCall() &#x4F1A;&#x5728;&#x6CA1;&#x6709;&#x4F7F;&#x7528; schedlock &#x65F6;&#x904D;&#x5386; allm&#xFF0C;&#x7B49;&#x4EF7;&#x4E8E; allm = mp</span>
    atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))
    unlock(&amp;sched.lock)

    <span class="hljs-comment">// Allocate memory to hold a cgo traceback if the cgo call crashes.</span>
    <span class="hljs-keyword">if</span> iscgo || GOOS == <span class="hljs-string">&quot;solaris&quot;</span> || GOOS == <span class="hljs-string">&quot;illumos&quot;</span> || GOOS == <span class="hljs-string">&quot;windows&quot;</span> {
        mp.cgoCallers = <span class="hljs-built_in">new</span>(cgoCallers)
    }
}
</code></pre>
<h4 id="p&#x7684;&#x521D;&#x59CB;&#x5316;">P&#x7684;&#x521D;&#x59CB;&#x5316;</h4>
<p>&#x901A;&#x5E38;&#x60C5;&#x51B5;&#x4E0B;&#xFF08;&#x5728;&#x7A0B;&#x5E8F;&#x8FD0;&#x884C;&#x65F6;&#x4E0D;&#x8C03;&#x6574;P&#x7684;&#x4E2A;&#x6570;&#xFF09;&#xFF0C;P&#x53EA;&#x4F1A;&#x5728;&#x56DB;&#x79CD;&#x72B6;&#x6001;&#x4E0B;&#x8FDB;&#x884C;&#x5207;&#x6362;&#x3002;&#x5F53;&#x7A0B;&#x5E8F;&#x521A;&#x5F00;&#x59CB;&#x8FD0;&#x884C;&#x521D;&#x59CB;&#x5316;&#x65F6;&#xFF0C;&#x6240;&#x6709;&#x7684;P&#x90FD;&#x5904;&#x4E8E;Pgcstop&#x72B6;&#x6001;&#xFF0C;&#x968F;&#x7740;P&#x7684;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x4F1A;&#x88AB;&#x7F6E;&#x4E3A;Pidle&#x72B6;&#x6001;&#x3002;</p>
<p><img src="../image/P&#x7684;&#x72B6;&#x6001;&#x8F6C;&#x6362;.png" alt="gobuild"></p>
<p>&#x5F53; M &#x9700;&#x8981;&#x8FD0;&#x884C;&#x65F6;&#xFF0C;&#x4F1A; <code>runtime.acquirep</code>&#xFF0C;&#x5E76;&#x901A;&#x8FC7; <code>runtime.releasep</code> &#x6765;&#x91CA;&#x653E;&#x3002; &#x5F53; G &#x6267;&#x884C;&#x65F6;&#x9700;&#x8981;&#x8FDB;&#x5165;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x65F6;&#xFF0C;P &#x4F1A;&#x88AB;&#x8BBE;&#x7F6E;&#x4E3A; <code>_Psyscall</code>&#xFF0C; &#x5982;&#x679C;&#x8FD9;&#x4E2A;&#x65F6;&#x5019;&#x88AB;&#x7CFB;&#x7EDF;&#x76D1;&#x63A7;&#x62A2;&#x593A;&#xFF08;<code>runtime.retake</code>&#xFF09;&#xFF0C;&#x5219; P &#x4F1A;&#x88AB;&#x91CD;&#x65B0;&#x4FEE;&#x6539;&#x4E3A; <code>_Pidle</code>&#x3002; &#x5982;&#x679C;&#x5728;&#x7A0B;&#x5E8F;&#x8FD0;&#x884C;&#x4E2D;&#x53D1;&#x751F; GC&#xFF0C;&#x5219; P &#x4F1A;&#x88AB;&#x8BBE;&#x7F6E;&#x4E3A; <code>_Pgcstop</code>&#xFF0C; &#x5E76;&#x5728; <code>runtime.startTheWorld</code> &#x65F6;&#x91CD;&#x65B0;&#x8C03;&#x6574;&#x4E3A; <code>_Pidle</code> &#x6216;&#x8005; <code>_Prunning</code>&#x3002;</p>
<p><span style="color: red">GOMAXPROCS-&gt;startTheWorld-&gt;procresize,&#xFF0C;&#x5728;&#x8981;&#x6C42;&#x51CF;&#x5C11;P&#x65F6;&#x4F1A;&#x8C03;&#x6574;&#x4E3A;Pdead&#xFF0C;&#x5426;&#x5219;&#x5728;&#x8981;&#x6C42;&#x589E;&#x52A0;&#x65F6;&#x4F1A;&#x7531;Pdead&#x76F4;&#x63A5;&#x8C03;&#x6574;&#x4E3A;Pidle&#x3002;</span></p>
<p>procresize&#x51FD;&#x6570;&#x7684;&#x6D41;&#x7A0B;&#xFF1A;</p>
<ol>
<li>&#x8C03;&#x7528;&#x65F6;&#x5DF2;&#x7ECF;stop the world&#xFF0C;&#x8BB0;&#x5F55;&#x8C03;&#x6574;P&#x7684;&#x65F6;&#x95F4;&#x3002;</li>
<li>&#x6309;&#x9700;&#x8C03;&#x6574;allp&#x7684;&#x5927;&#x5C0F;</li>
<li>&#x6309;&#x9700;&#x521D;&#x59CB;&#x5316;allp&#x4E2D;&#x7684;P</li>
<li>&#x5982;&#x679C;&#x5F53;&#x524D;&#x7684;P&#x8FD8;&#x53EF;&#x4EE5;&#x7EE7;&#x7EED;&#x4F7F;&#x7528;&#xFF0C;&#x5219;&#x5C06;P&#x8BBE;&#x7F6E;&#x4E3A;Prunning</li>
<li>&#x5426;&#x5219;&#x5C06;&#x7B2C;&#x4E00;&#x4E2A;P&#x62A2;&#x8FC7;&#x6765;&#x7ED9;&#x5F53;&#x524D;G&#x7684;M&#x8FDB;&#x884C;&#x7ED1;&#x5B9A;</li>
<li>&#x4ECE;allp&#x79FB;&#x9664;&#x4E0D;&#x9700;&#x8981;&#x7684;P&#xFF0C;&#x5C06;&#x91CA;&#x653E;&#x7684;P&#x961F;&#x5217;&#x4E2D;&#x7684;&#x4EFB;&#x52A1;&#x6254;&#x8FDB;&#x5168;&#x5C40;&#x961F;&#x5217;&#x3002;</li>
<li>&#x6700;&#x540E;&#x6328;&#x4E2A;&#x68C0;&#x67E5;P&#xFF0C;&#x5C06;&#x6CA1;&#x6709;&#x4EFB;&#x52A1;&#x7684;P&#x653E;&#x5165;idle&#x961F;&#x5217;&#x3002;</li>
<li>&#x9664;&#x53BB;&#x5F53;&#x524D;P&#x4E4B;&#x5916;&#xFF0C;&#x5C06;&#x6709;&#x4EFB;&#x52A1;&#x7684;P&#x5F7C;&#x6B64;&#x4E32;&#x8054;&#x6210;&#x94FE;&#x8868;&#xFF0C;&#x5C06;&#x6CA1;&#x6709;&#x4EFB;&#x52A1;&#x7684;P&#x653E;&#x56DE;&#x5230;idle&#x94FE;&#x8868;&#x4E2D;&#x3002;</li>
</ol>
<p>&#x5728;P&#x521D;&#x59CB;&#x5316;&#x4E4B;&#x524D;&#xFF0C;&#x5148;&#x521D;&#x59CB;&#x5316;&#x4E86;M&#xFF0C;&#x56E0;&#x6B64;&#x5728;&#x521D;&#x59CB;&#x5316;&#x8FC7;&#x7A0B;&#x4E2D;procresize&#x51FD;&#x6570;&#x4E2D;&#x7ED1;&#x5B9A;M&#x4F1A;&#x5C06;&#x5F53;&#x524D;&#x7684;P&#x7ED1;&#x5B9A;&#x5230;&#x521D;&#x59CB;M&#x4E0A;&#xFF0C;&#x7531;&#x4E8E;&#x7A0B;&#x5E8F;&#x521A;&#x521A;&#x5F00;&#x59CB;&#xFF0C;P&#x7684;&#x961F;&#x5217;&#x662F;&#x7A7A;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#x4ED6;&#x4EEC;&#x4F1A;&#x88AB;&#x94FE;&#x63A5;&#x5230;&#x53EF;&#x8FD0;&#x884C;&#x7684;P&#x94FE;&#x8868;&#x4E0A;&#x5904;&#x4E8E;Pidle&#x72B6;&#x6001;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// init initializes pp, which may be a freshly allocated p or a</span>
<span class="hljs-comment">// previously destroyed p, and transitions it to status _Pgcstop.</span>
<span class="hljs-keyword">func</span> (pp *p) init(id <span class="hljs-keyword">int32</span>) {
    <span class="hljs-comment">// p &#x7684; id &#x5C31;&#x662F;&#x5B83;&#x5728; allp &#x4E2D;&#x7684;&#x7D22;&#x5F15;</span>
    pp.id = id
    <span class="hljs-comment">// &#x65B0;&#x521B;&#x5EFA;&#x7684; p &#x5904;&#x4E8E; _Pgcstop &#x72B6;&#x6001;</span>
    pp.status = _Pgcstop
    pp.sudogcache = pp.sudogbuf[:<span class="hljs-number">0</span>]
    pp.deferpool = pp.deferpoolbuf[:<span class="hljs-number">0</span>]
    pp.wbBuf.reset()
    <span class="hljs-comment">// &#x4E3A;P&#x5206;&#x914D;cache&#x5BF9;&#x8C61;</span>
    <span class="hljs-keyword">if</span> pp.mcache == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// &#x5982;&#x679C; old == 0 &#x4E14; i == 0 &#x8BF4;&#x660E;&#x8FD9;&#x662F;&#x5F15;&#x5BFC;&#x9636;&#x6BB5;&#x521D;&#x59CB;&#x5316;&#x7B2C;&#x4E00;&#x4E2A; p</span>
        <span class="hljs-keyword">if</span> id == <span class="hljs-number">0</span> {
            <span class="hljs-keyword">if</span> mcache0 == <span class="hljs-literal">nil</span> {
                throw(<span class="hljs-string">&quot;missing mcache?&quot;</span>)
            }
            <span class="hljs-comment">// Use the bootstrap mcache0. Only one P will get</span>
            <span class="hljs-comment">// mcache0: the one with ID 0.</span>
            pp.mcache = mcache0
        } <span class="hljs-keyword">else</span> {
            pp.mcache = allocmcache()
        }
    }
    <span class="hljs-keyword">if</span> raceenabled &amp;&amp; pp.raceprocctx == <span class="hljs-number">0</span> {
        <span class="hljs-keyword">if</span> id == <span class="hljs-number">0</span> {
            pp.raceprocctx = raceprocctx0
            raceprocctx0 = <span class="hljs-number">0</span> <span class="hljs-comment">// bootstrap</span>
        } <span class="hljs-keyword">else</span> {
            pp.raceprocctx = raceproccreate()
        }
    }
    lockInit(&amp;pp.timersLock, lockRankTimers)

    <span class="hljs-comment">// This P may get timers when it starts running. Set the mask here</span>
    <span class="hljs-comment">// since the P may not go through pidleget (notably P 0 on startup).</span>
    timerpMask.set(id)
    <span class="hljs-comment">// Similarly, we may not go through pidleget before this P starts</span>
    <span class="hljs-comment">// running if it is P 0 on startup.</span>
    idlepMask.clear(id)
}

<span class="hljs-comment">// destroy releases all of the resources associated with pp and</span>
<span class="hljs-comment">// transitions it to status _Pdead.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// sched.lock must be held and the world must be stopped.</span>
<span class="hljs-comment">// &#x91CA;&#x653E;&#x672A;&#x4F7F;&#x7528;&#x7684; P&#xFF0C;&#x4E00;&#x822C;&#x60C5;&#x51B5;&#x4E0B;&#x4E0D;&#x4F1A;&#x6267;&#x884C;&#x8FD9;&#x6BB5;&#x4EE3;&#x7801;</span>
<span class="hljs-keyword">func</span> (pp *p) destroy() {
    assertLockHeld(&amp;sched.lock)
    assertWorldStopped()

    <span class="hljs-comment">// Move all runnable goroutines to the global queue</span>
    <span class="hljs-comment">// &#x5C06;&#x6240;&#x6709; runnable Goroutine &#x79FB;&#x52A8;&#x81F3;&#x5168;&#x5C40;&#x961F;&#x5217;</span>
    <span class="hljs-keyword">for</span> pp.runqhead != pp.runqtail {
        <span class="hljs-comment">// Pop from tail of local queue</span>
        <span class="hljs-comment">// &#x4ECE;&#x672C;&#x5730;&#x961F;&#x5217;&#x4E2D; pop</span>
        pp.runqtail--
        gp := pp.runq[pp.runqtail%<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()
        <span class="hljs-comment">// Push onto head of global queue</span>
        <span class="hljs-comment">// push &#x5230;&#x5168;&#x5C40;&#x961F;&#x5217;&#x4E2D;</span>
        globrunqputhead(gp)
    }
    <span class="hljs-keyword">if</span> pp.runnext != <span class="hljs-number">0</span> {
        globrunqputhead(pp.runnext.ptr())
        pp.runnext = <span class="hljs-number">0</span>
    }
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pp.timers) &gt; <span class="hljs-number">0</span> {
        plocal := getg().m.p.ptr()
        <span class="hljs-comment">// The world is stopped, but we acquire timersLock to</span>
        <span class="hljs-comment">// protect against sysmon calling timeSleepUntil.</span>
        <span class="hljs-comment">// This is the only case where we hold the timersLock of</span>
        <span class="hljs-comment">// more than one P, so there are no deadlock concerns.</span>
        lock(&amp;plocal.timersLock)
        lock(&amp;pp.timersLock)
        moveTimers(plocal, pp.timers)
        pp.timers = <span class="hljs-literal">nil</span>
        pp.numTimers.Store(<span class="hljs-number">0</span>)
        pp.deletedTimers.Store(<span class="hljs-number">0</span>)
        pp.timer0When.Store(<span class="hljs-number">0</span>)
        unlock(&amp;pp.timersLock)
        unlock(&amp;plocal.timersLock)
    }
    <span class="hljs-comment">// Flush p&apos;s write barrier buffer.</span>
    <span class="hljs-keyword">if</span> gcphase != _GCoff {
        wbBufFlush1(pp)
        pp.gcw.dispose()
    }
    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pp.sudogbuf {
        pp.sudogbuf[i] = <span class="hljs-literal">nil</span>
    }
    pp.sudogcache = pp.sudogbuf[:<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> pp.deferpoolbuf {
        pp.deferpoolbuf[j] = <span class="hljs-literal">nil</span>
    }
    pp.deferpool = pp.deferpoolbuf[:<span class="hljs-number">0</span>]
    systemstack(<span class="hljs-keyword">func</span>() {
        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; pp.mspancache.<span class="hljs-built_in">len</span>; i++ {
            <span class="hljs-comment">// Safe to call since the world is stopped.</span>
            mheap_.spanalloc.free(unsafe.Pointer(pp.mspancache.buf[i]))
        }
        pp.mspancache.<span class="hljs-built_in">len</span> = <span class="hljs-number">0</span>
        lock(&amp;mheap_.lock)
        pp.pcache.flush(&amp;mheap_.pages)
        unlock(&amp;mheap_.lock)
    })
    freemcache(pp.mcache)
    pp.mcache = <span class="hljs-literal">nil</span>
    <span class="hljs-comment">// &#x5C06;&#x5F53;&#x524D; P &#x7684;&#x7A7A;&#x95F2;&#x7684; G &#x590D;&#x94FE;&#x8F6C;&#x79FB;&#x5230;&#x5168;&#x5C40;</span>
    gfpurge(pp)
    traceProcFree(pp)
    <span class="hljs-keyword">if</span> raceenabled {
        <span class="hljs-keyword">if</span> pp.timerRaceCtx != <span class="hljs-number">0</span> {
            <span class="hljs-comment">// The race detector code uses a callback to fetch</span>
            <span class="hljs-comment">// the proc context, so arrange for that callback</span>
            <span class="hljs-comment">// to see the right thing.</span>
            <span class="hljs-comment">// This hack only works because we are the only</span>
            <span class="hljs-comment">// thread running.</span>
            mp := getg().m
            phold := mp.p.ptr()
            mp.p.set(pp)

            racectxend(pp.timerRaceCtx)
            pp.timerRaceCtx = <span class="hljs-number">0</span>

            mp.p.set(phold)
        }
        raceprocdestroy(pp.raceprocctx)
        pp.raceprocctx = <span class="hljs-number">0</span>
    }
    pp.gcAssistTime = <span class="hljs-number">0</span>
    pp.status = _Pdead
}

<span class="hljs-comment">// Change number of processors.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// sched.lock must be held, and the world must be stopped.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcworkbufs must not be being modified by either the GC or the write barrier</span>
<span class="hljs-comment">// code, so the GC must not be running if the number of Ps actually changes.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Returns list of Ps with local work, they need to be scheduled by the caller.</span>
<span class="hljs-keyword">func</span> procresize(nprocs <span class="hljs-keyword">int32</span>) *p {
    assertLockHeld(&amp;sched.lock)
    assertWorldStopped()

    <span class="hljs-comment">// &#x83B7;&#x53D6;&#x4E4B;&#x524D;P&#x7684;&#x4E2A;&#x6570;</span>
    old := gomaxprocs
    <span class="hljs-keyword">if</span> old &lt; <span class="hljs-number">0</span> || nprocs &lt;= <span class="hljs-number">0</span> {
        throw(<span class="hljs-string">&quot;procresize: invalid arg&quot;</span>)
    }
    <span class="hljs-keyword">if</span> trace.enabled {
        traceGomaxprocs(nprocs)
    }

    <span class="hljs-comment">// update statistics</span>
    <span class="hljs-comment">// &#x8BB0;&#x5F55;&#x4E00;&#x4E0B;&#x4FEE;&#x6539;P&#x7684;&#x65F6;&#x95F4;</span>
    now := nanotime()
    <span class="hljs-keyword">if</span> sched.procresizetime != <span class="hljs-number">0</span> {
        sched.totaltime += <span class="hljs-keyword">int64</span>(old) * (now - sched.procresizetime)
    }
    sched.procresizetime = now

    maskWords := (nprocs + <span class="hljs-number">31</span>) / <span class="hljs-number">32</span>

    <span class="hljs-comment">// Grow allp if necessary.</span>
    <span class="hljs-comment">// &#x5FC5;&#x8981;&#x65F6;&#x589E;&#x52A0;allp</span>
    <span class="hljs-comment">// &#x8FD9;&#x4E2A;&#x65F6;&#x5019;&#x672C;&#x8D28;&#x4E0A;&#x662F;&#x5728;&#x68C0;&#x67E5;&#x7528;&#x6237;&#x4EE3;&#x7801;&#x662F;&#x5426;&#x6709;&#x8C03;&#x7528;&#x8FC7; runtime.MAXGOPROCS &#x8C03;&#x6574; p &#x7684;&#x6570;&#x91CF;</span>
    <span class="hljs-comment">// &#x6B64;&#x5904;&#x591A;&#x4E00;&#x6B65;&#x68C0;&#x67E5;&#x662F;&#x4E3A;&#x4E86;&#x907F;&#x514D;&#x5185;&#x90E8;&#x7684;&#x9501;&#xFF0C;&#x5982;&#x679C; nprocs &#x660E;&#x663E;&#x5C0F;&#x4E8E; allp &#x7684;&#x53EF;&#x89C1;&#x6570;&#x91CF;&#xFF08;&#x56E0;&#x4E3A; len&#xFF09;</span>
    <span class="hljs-comment">// &#x5219;&#x4E0D;&#x9700;&#x8981;&#x8FDB;&#x884C;&#x52A0;&#x9501;</span>
    <span class="hljs-keyword">if</span> nprocs &gt; <span class="hljs-keyword">int32</span>(<span class="hljs-built_in">len</span>(allp)) {
        <span class="hljs-comment">// Synchronize with retake, which could be running</span>
        <span class="hljs-comment">// concurrently since it doesn&apos;t run on a P.</span>
        <span class="hljs-comment">// &#x6B64;&#x5904;&#x4E0E; retake &#x540C;&#x6B65;&#xFF0C;&#x5B83;&#x53EF;&#x4EE5;&#x540C;&#x65F6;&#x8FD0;&#x884C;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4E0D;&#x4F1A;&#x5728; P &#x4E0A;&#x8FD0;&#x884C;&#x3002;</span>
        lock(&amp;allpLock)
        <span class="hljs-keyword">if</span> nprocs &lt;= <span class="hljs-keyword">int32</span>(<span class="hljs-built_in">cap</span>(allp)) {
            <span class="hljs-comment">// &#x5982;&#x679C; nprocs &#x88AB;&#x8C03;&#x5C0F;&#x4E86;&#xFF0C;&#x6254;&#x6389;&#x591A;&#x4F59;&#x7684; p</span>
            allp = allp[:nprocs]
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// &#x5426;&#x5219;&#xFF08;&#x8C03;&#x5927;&#x4E86;&#xFF09;&#x521B;&#x5EFA;&#x66F4;&#x591A;&#x7684; p</span>
            nallp := <span class="hljs-built_in">make</span>([]*p, nprocs)
            <span class="hljs-comment">// Copy everything up to allp&apos;s cap so we</span>
            <span class="hljs-comment">// never lose old allocated Ps.</span>
            <span class="hljs-comment">// &#x5C06;&#x539F;&#x6709;&#x7684; p &#x590D;&#x5236;&#x5230;&#x65B0;&#x521B;&#x5EFA;&#x7684; new all p &#x4E2D;&#xFF0C;&#x4E0D;&#x6D6A;&#x8D39;&#x65E7;&#x7684; p</span>
            <span class="hljs-built_in">copy</span>(nallp, allp[:<span class="hljs-built_in">cap</span>(allp)])
            allp = nallp
        }

        <span class="hljs-keyword">if</span> maskWords &lt;= <span class="hljs-keyword">int32</span>(<span class="hljs-built_in">cap</span>(idlepMask)) {
            idlepMask = idlepMask[:maskWords]
            timerpMask = timerpMask[:maskWords]
        } <span class="hljs-keyword">else</span> {
            nidlepMask := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">uint32</span>, maskWords)
            <span class="hljs-comment">// No need to copy beyond len, old Ps are irrelevant.</span>
            <span class="hljs-built_in">copy</span>(nidlepMask, idlepMask)
            idlepMask = nidlepMask

            ntimerpMask := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">uint32</span>, maskWords)
            <span class="hljs-built_in">copy</span>(ntimerpMask, timerpMask)
            timerpMask = ntimerpMask
        }
        unlock(&amp;allpLock)
    }

    <span class="hljs-comment">// initialize new P&apos;s</span>
    <span class="hljs-comment">// &#x521D;&#x59CB;&#x5316;&#x65B0;&#x7684;P</span>
    <span class="hljs-keyword">for</span> i := old; i &lt; nprocs; i++ {
        pp := allp[i]
        <span class="hljs-comment">// &#x5982;&#x679C;P&#x662F;&#x65B0;&#x521B;&#x5EFA;&#x7684;&#xFF0C;&#x5219;&#x7533;&#x8BF7;&#x65B0;&#x7684;P&#x5BF9;&#x8C61;</span>
        <span class="hljs-keyword">if</span> pp == <span class="hljs-literal">nil</span> {
            pp = <span class="hljs-built_in">new</span>(p)
        }
        pp.init(i)
        <span class="hljs-comment">// allp[i] = pp</span>
        atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))
    }

    gp := getg()
    <span class="hljs-keyword">if</span> gp.m.p != <span class="hljs-number">0</span> &amp;&amp; gp.m.p.ptr().id &lt; nprocs {
        <span class="hljs-comment">// continue to use the current P</span>
        <span class="hljs-comment">// &#x7EE7;&#x7EED;&#x4F7F;&#x7528;&#x5F53;&#x524D; P</span>
        gp.m.p.ptr().status = _Prunning
        gp.m.p.ptr().mcache.prepareForSweep()
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// &#x5C06;&#x7B2C;&#x4E00;&#x4E2A; P &#x62A2;&#x8FC7;&#x6765;&#x7ED9;&#x5F53;&#x524D; G &#x7684; M &#x8FDB;&#x884C;&#x7ED1;&#x5B9A;</span>
        <span class="hljs-comment">// release the current P and acquire allp[0].</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// We must do this before destroying our current P</span>
        <span class="hljs-comment">// because p.destroy itself has write barriers, so we</span>
        <span class="hljs-comment">// need to do that from a valid P.</span>
        <span class="hljs-comment">// &#x91CA;&#x653E;&#x5F53;&#x524D;P&#xFF0C;&#x56E0;&#x4E3A;&#x5DF2;&#x7ECF;&#x5931;&#x6548;</span>
        <span class="hljs-keyword">if</span> gp.m.p != <span class="hljs-number">0</span> {
            <span class="hljs-keyword">if</span> trace.enabled {
                <span class="hljs-comment">// Pretend that we were descheduled</span>
                <span class="hljs-comment">// and then scheduled again to keep</span>
                <span class="hljs-comment">// the trace sane.</span>
                traceGoSched()
                traceProcStop(gp.m.p.ptr())
            }
            gp.m.p.ptr().m = <span class="hljs-number">0</span>
        }
        gp.m.p = <span class="hljs-number">0</span>
        <span class="hljs-comment">// &#x66F4;&#x65B0;&#x5230;allp[0]</span>
        pp := allp[<span class="hljs-number">0</span>]
        pp.m = <span class="hljs-number">0</span>
        pp.status = _Pidle
        acquirep(pp) <span class="hljs-comment">// &#x76F4;&#x63A5;&#x5C06;allp[0]&#x7ED1;&#x5B9A;&#x5230;&#x5F53;&#x524D;M</span>
        <span class="hljs-keyword">if</span> trace.enabled {
            traceGoStart()
        }
    }

    <span class="hljs-comment">// g.m.p is now set, so we no longer need mcache0 for bootstrapping.</span>
    mcache0 = <span class="hljs-literal">nil</span>

    <span class="hljs-comment">// release resources from unused P&apos;s</span>
    <span class="hljs-comment">// &#x4ECE;&#x672A;&#x4F7F;&#x7528;&#x7684;P&#x91CA;&#x653E;&#x8D44;&#x6E90;</span>
    <span class="hljs-keyword">for</span> i := nprocs; i &lt; old; i++ {
        pp := allp[i]
        pp.destroy()
        <span class="hljs-comment">// can&apos;t free P itself because it can be referenced by an M in syscall</span>
        <span class="hljs-comment">// &#x4E0D;&#x80FD;&#x91CA;&#x653E; p &#x672C;&#x8EAB;&#xFF0C;&#x56E0;&#x4E3A;&#x4ED6;&#x53EF;&#x80FD;&#x5728; m &#x8FDB;&#x5165;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x65F6;&#x88AB;&#x5F15;&#x7528;</span>
    }

    <span class="hljs-comment">// Trim allp.</span>
    <span class="hljs-comment">// &#x6E05;&#x7406;&#x5B8C;&#x6BD5;&#x540E;&#xFF0C;&#x4FEE;&#x526A; allp, nprocs &#x4E2A;&#x6570;&#x4E4B;&#x5916;&#x7684;&#x6240;&#x6709; P</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">int32</span>(<span class="hljs-built_in">len</span>(allp)) != nprocs {
        lock(&amp;allpLock)
        allp = allp[:nprocs]
        idlepMask = idlepMask[:maskWords]
        timerpMask = timerpMask[:maskWords]
        unlock(&amp;allpLock)
    }

    <span class="hljs-comment">// &#x5C06;&#x6CA1;&#x6709;&#x672C;&#x5730;&#x4EFB;&#x52A1;&#x7684; P &#x653E;&#x5230;&#x7A7A;&#x95F2;&#x94FE;&#x8868;&#x4E2D;</span>
    <span class="hljs-keyword">var</span> runnablePs *p
    <span class="hljs-keyword">for</span> i := nprocs - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- {
        pp := allp[i]
        <span class="hljs-comment">// &#x786E;&#x4FDD;&#x4E0D;&#x662F;&#x5F53;&#x524D;&#x6B63;&#x5728;&#x4F7F;&#x7528;&#x7684; P</span>
        <span class="hljs-keyword">if</span> gp.m.p.ptr() == pp {
            <span class="hljs-keyword">continue</span>
        }
        <span class="hljs-comment">// &#x5C06; p &#x8BBE;&#x4E3A; idle</span>
        pp.status = _Pidle
        <span class="hljs-keyword">if</span> runqempty(pp) {
            <span class="hljs-comment">// &#x653E;&#x5165; idle &#x94FE;&#x8868;</span>
            pidleput(pp, now)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// &#x5982;&#x679C;&#x6709;&#x672C;&#x5730;&#x4EFB;&#x52A1;&#xFF0C;&#x5219;&#x4E3A;&#x5176;&#x7ED1;&#x5B9A;&#x4E00;&#x4E2A; M</span>
            pp.m.set(mget())
            <span class="hljs-comment">// &#x6784;&#x5EFA;&#x53EF;&#x8FD0;&#x884C;&#x7684; p &#x94FE;&#x8868;</span>
            pp.link.set(runnablePs)
            runnablePs = pp
        }
    }
    stealOrder.reset(<span class="hljs-keyword">uint32</span>(nprocs))
    <span class="hljs-comment">// gomaxprocs = nprocs</span>
    <span class="hljs-keyword">var</span> int32p *<span class="hljs-keyword">int32</span> = &amp;gomaxprocs <span class="hljs-comment">// make compiler check that gomaxprocs is an int32</span>
    atomic.Store((*<span class="hljs-keyword">uint32</span>)(unsafe.Pointer(int32p)), <span class="hljs-keyword">uint32</span>(nprocs))
    <span class="hljs-keyword">if</span> old != nprocs {
        <span class="hljs-comment">// Notify the limiter that the amount of procs has changed.</span>
        gcCPULimiter.resetCapacity(now, nprocs)
    }
    <span class="hljs-comment">// &#x8FD4;&#x56DE;&#x6240;&#x6709;&#x5305;&#x542B;&#x672C;&#x5730;&#x4EFB;&#x52A1;&#x7684; P &#x94FE;&#x8868;</span>
    <span class="hljs-keyword">return</span> runnablePs
}
</code></pre>
<p>&#x4E3A;&#x4E86;&#x5411;&#x7528;&#x6237;&#x5C42;&#x63D0;&#x4F9B;&#x5BF9;&#x8C03;&#x5EA6;&#x5668;&#x7684;&#x63A7;&#x5236;&#xFF0C;runtime&#x5305;&#x4E2D;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x4E9B;&#x65B9;&#x6CD5;&#x8FBE;&#x5230;&#x4E86;&#x8FD9;&#x4E00;&#x76EE;&#x7684;&#x3002;</p>
<p>&#x5927;&#x90E8;&#x5206;&#x7684;&#x65F6;&#x95F4;&#x91CC;&#xFF0C;P&#x7684;&#x6570;&#x91CF;&#x4E0D;&#x4F1A;&#x88AB;&#x52A8;&#x6001;&#x8C03;&#x6574;&#x7684;&#x3002;&#x4F46;&#x662F;runtime.GOMAXPROCS&#x80FD;&#x591F;&#x5728;&#x8FD0;&#x884C;&#x65F6;&#x52A8;&#x6001;&#x8C03;&#x6574;P&#x7684;&#x6570;&#x91CF;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// src/runtime/debug.go</span>
<span class="hljs-comment">// GOMAXPROCS sets the maximum number of CPUs that can be executing</span>
<span class="hljs-comment">// simultaneously and returns the previous setting. It defaults to</span>
<span class="hljs-comment">// the value of runtime.NumCPU. If n &lt; 1, it does not change the current setting.</span>
<span class="hljs-comment">// This call will go away when the scheduler improves.</span>
<span class="hljs-comment">// GOMAXPROCS &#x8BBE;&#x7F6E;&#x53EF;&#x4EE5;&#x540C;&#x65F6;&#x6267;&#x884C;&#x7684; CPU &#x7684;&#x6700;&#x5927;&#x6570;&#x91CF;&#x5E76;&#x8FD4;&#x56DE;&#x4E4B;&#x524D;&#x7684;&#x8BBE;&#x7F6E;&#x3002;</span>
<span class="hljs-comment">// &#x5B83;&#x9ED8;&#x8BA4;&#x4E3A;runtime.NumCPU &#x7684;&#x503C;&#x3002;&#x5982;&#x679C; n &lt; 1&#xFF0C;&#x5219;&#x4E0D;&#x4F1A;&#x66F4;&#x6539;&#x5F53;&#x524D;&#x8BBE;&#x7F6E;&#x3002;</span>
<span class="hljs-comment">// &#x5F53;&#x8C03;&#x5EA6;&#x7A0B;&#x5E8F;&#x6539;&#x8FDB;&#x65F6;&#xFF0C;&#x8FD9;&#x4E2A;&#x8C03;&#x7528;&#x5C31;&#x4F1A;&#x6D88;&#x5931;&#x3002;</span>
<span class="hljs-keyword">func</span> GOMAXPROCS(n <span class="hljs-keyword">int</span>) <span class="hljs-keyword">int</span> {
    <span class="hljs-keyword">if</span> GOARCH == <span class="hljs-string">&quot;wasm&quot;</span> &amp;&amp; n &gt; <span class="hljs-number">1</span> {
        n = <span class="hljs-number">1</span> <span class="hljs-comment">// WebAssembly has no threads yet, so only one CPU is possible.</span>
    }

    <span class="hljs-comment">// &#x5F53;&#x8C03;&#x6574; P &#x7684;&#x6570;&#x91CF;&#x65F6;&#xFF0C;&#x8C03;&#x5EA6;&#x5668;&#x4F1A;&#x88AB;&#x9501;&#x4F4F;</span>
    lock(&amp;sched.lock)
    ret := <span class="hljs-keyword">int</span>(gomaxprocs)
    unlock(&amp;sched.lock)
    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> || n == ret {
        <span class="hljs-keyword">return</span> ret
    }

    <span class="hljs-comment">// &#x505C;&#x6B62;&#x4E00;&#x5207;&#x4E8B;&#x7269;&#xFF0C;&#x5C06; STW &#x7684;&#x539F;&#x56E0;&#x8BBE;&#x7F6E;&#x4E3A; P &#x88AB;&#x8C03;&#x6574;</span>
    stopTheWorldGC(<span class="hljs-string">&quot;GOMAXPROCS&quot;</span>)

    <span class="hljs-comment">// newprocs will be processed by startTheWorld</span>
    <span class="hljs-comment">// STW &#x540E;&#xFF0C;&#x4FEE;&#x6539; P &#x7684;&#x6570;&#x91CF;</span>
    newprocs = <span class="hljs-keyword">int32</span>(n)

    <span class="hljs-comment">// &#x91CD;&#x65B0;&#x6062;&#x590D;</span>
    <span class="hljs-comment">// &#x5728;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;startTheWorld &#x4F1A;&#x8C03;&#x7528; procresize &#x8FDB;&#x800C;&#x52A8;&#x6001;&#x7684;&#x8C03;&#x6574; P &#x7684;&#x6570;&#x91CF;</span>
    startTheWorldGC()
    <span class="hljs-keyword">return</span> ret
}
</code></pre>
<h4 id="g&#x7684;&#x521D;&#x59CB;&#x5316;">G&#x7684;&#x521D;&#x59CB;&#x5316;</h4>
<p>&#x5728;P&#x521D;&#x59CB;&#x5316;&#x5B8C;&#x6210;&#x540E;&#xFF0C;&#x4E3B;&#x534F;&#x7A0B;&#x4F1A;&#x4EE5;&#x88AB;&#x8C03;&#x5EA6;&#x5668;&#x8C03;&#x5EA6;&#x7684;&#x65B9;&#x5F0F;&#x8FDB;&#x884C;&#x8FD0;&#x884C;&#xFF0C;&#x8FD9;&#x5C06;&#x7531;<code>runtime.newproc</code> &#x6765;&#x5B8C;&#x6210;&#x4E3B; Goroutine &#x7684;&#x521D;&#x59CB;&#x5316;&#x5DE5;&#x4F5C;&#x3002;</p>
<p>G&#x7684;&#x5404;&#x79CD;&#x5DE5;&#x4F5C;&#x72B6;&#x6001;&#x8F6C;&#x6362;</p>
<p><img src="../image/G&#x7684;&#x72B6;&#x6001;&#x8F6C;&#x6362;.png" alt="G&#x7684;&#x72B6;&#x6001;&#x8F6C;&#x6362;"></p>
<p>&#x521D;&#x59CB;&#x5316;&#x8FC7;&#x7A0B;&#xFF1A;</p>
<ol>
<li>&#x9996;&#x5148;&#x5C1D;&#x8BD5;&#x4ECE; P &#x672C;&#x5730; gfree &#x94FE;&#x8868;&#x6216;&#x5168;&#x5C40; gfree &#x961F;&#x5217;&#x83B7;&#x53D6;&#x5DF2;&#x7ECF;&#x6267;&#x884C;&#x8FC7;&#x7684; g</li>
<li>&#x521D;&#x59CB;&#x5316;&#x8FC7;&#x7A0B;&#x4E2D;&#x7A0B;&#x5E8F;&#x65E0;&#x8BBA;&#x662F;&#x672C;&#x5730;&#x961F;&#x5217;&#x8FD8;&#x662F;&#x5168;&#x5C40;&#x961F;&#x5217;&#x90FD;&#x4E0D;&#x53EF;&#x80FD;&#x83B7;&#x53D6;&#x5230; g&#xFF0C;&#x56E0;&#x6B64;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684; g&#xFF0C;&#x5E76;&#x4E3A;&#x5176;&#x5206;&#x914D;&#x8FD0;&#x884C;&#x7EBF;&#x7A0B;&#xFF08;&#x6267;&#x884C;&#x6808;&#xFF09;&#xFF0C;&#x8FD9;&#x65F6; g &#x5904;&#x4E8E; <code>_Gidle</code> &#x72B6;&#x6001;</li>
<li>&#x521B;&#x5EFA;&#x5B8C;&#x6210;&#x540E;&#xFF0C;g &#x88AB;&#x66F4;&#x6539;&#x4E3A; <code>_Gdead</code> &#x72B6;&#x6001;&#xFF0C;&#x5E76;&#x6839;&#x636E;&#x8981;&#x6267;&#x884C;&#x51FD;&#x6570;&#x7684;&#x5165;&#x53E3;&#x5730;&#x5740;&#x548C;&#x53C2;&#x6570;&#xFF0C;&#x521D;&#x59CB;&#x5316;&#x6267;&#x884C;&#x6808;&#x7684; SP &#x548C;&#x53C2;&#x6570;&#x7684;&#x5165;&#x6808;&#x4F4D;&#x7F6E;</li>
<li>&#x6839;&#x636E; SP&#x3001;&#x53C2;&#x6570;&#xFF0C;&#x5728; <code>g.sched</code> &#x4E2D;&#x4FDD;&#x5B58; SP &#x548C; PC &#x6307;&#x9488;&#x6765;&#x521D;&#x59CB;&#x5316; g &#x7684;&#x8FD0;&#x884C;&#x73B0;&#x573A;</li>
<li>&#x5C06;&#x8C03;&#x7528;&#x65B9;&#x3001;&#x8981;&#x6267;&#x884C;&#x7684;&#x51FD;&#x6570;&#x7684;&#x5165;&#x53E3; PC &#x8FDB;&#x884C;&#x4FDD;&#x5B58;&#xFF0C;&#x5E76;&#x5C06; g &#x7684;&#x72B6;&#x6001;&#x66F4;&#x6539;&#x4E3A; <code>_Grunnable</code></li>
<li>&#x7ED9; Goroutine &#x5206;&#x914D; id&#xFF0C;&#x5E76;&#x5C06;&#x5176;&#x653E;&#x5165; P &#x672C;&#x5730;&#x961F;&#x5217;&#x7684;&#x961F;&#x5934;&#x6216;&#x5168;&#x5C40;&#x961F;&#x5217;&#xFF08;&#x521D;&#x59CB;&#x5316;&#x9636;&#x6BB5;&#x961F;&#x5217;&#x80AF;&#x5B9A;&#x4E0D;&#x662F;&#x6EE1;&#x7684;&#xFF0C;&#x56E0;&#x6B64;&#x4E0D;&#x53EF;&#x80FD;&#x653E;&#x5165;&#x5168;&#x5C40;&#x961F;&#x5217;&#xFF09;</li>
<li>&#x68C0;&#x67E5;&#x7A7A;&#x95F2;&#x7684; P&#xFF0C;&#x5C06;&#x5176;&#x5524;&#x9192;&#xFF0C;&#x51C6;&#x5907;&#x6267;&#x884C; G&#xFF0C;&#x4F46;&#x6211;&#x4EEC;&#x76EE;&#x524D;&#x5904;&#x4E8E;&#x521D;&#x59CB;&#x5316;&#x9636;&#x6BB5;&#xFF0C;&#x4E3B; Goroutine &#x5C1A;&#x672A;&#x5F00;&#x59CB;&#x6267;&#x884C;&#xFF0C;&#x56E0;&#x6B64;&#x8FD9;&#x91CC;&#x4E0D;&#x4F1A;&#x5524;&#x9192; P&#x3002;</li>
</ol>
<pre><code class="lang-go"><span class="hljs-comment">// Create a new g running fn.</span>
<span class="hljs-comment">// Put it on the queue of g&apos;s waiting to run.</span>
<span class="hljs-comment">// The compiler turns a go statement into a call to this.</span>
<span class="hljs-comment">// &#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;g&#x53BB;&#x8FD0;&#x884C;&#x65B9;&#x6CD5;</span>
<span class="hljs-keyword">func</span> newproc(fn *funcval) {
    <span class="hljs-comment">// &#x83B7;&#x53D6;&#x5F53;&#x524D;&#x6B63;&#x5728;&#x6267;&#x884C;&#x7684;G</span>
    gp := getg()
    <span class="hljs-comment">// &#x83B7;&#x53D6;&#x8C03;&#x7528;&#x8005;&#x7684;&#x7A0B;&#x5E8F;&#x8BA1;&#x6570;&#x5668;PC&#xFF0C;&#x7528;&#x4E8E;&#x8C03;&#x8BD5;&#x548C;&#x8DDF;&#x8E2A;</span>
    pc := getcallerpc()
    systemstack(<span class="hljs-keyword">func</span>() {
        newg := newproc1(fn, gp, pc)

        <span class="hljs-comment">// &#x83B7;&#x53D6;&#x5F53;&#x524D;&#x7684;P</span>
        pp := getg().m.p.ptr()
        <span class="hljs-comment">// &#x5C06;&#x65B0;&#x521B;&#x5EFA;&#x7684;&#x534F;&#x7A0B;&#x653E;&#x5165;&#x5904;&#x7406;&#x5668;&#x7684;&#x8FD0;&#x884C;&#x961F;&#x5217;</span>
        <span class="hljs-comment">// next&#x4E3A;true&#x8868;&#x793A;&#x653E;&#x5728;&#x961F;&#x5217;&#x5C3E;&#x90E8;</span>
        runqput(pp, newg, <span class="hljs-literal">true</span>)

        <span class="hljs-comment">// &#x5982;&#x679C;&#x7A0B;&#x5E8F;&#x5DF2;&#x7ECF;&#x542F;&#x52A8;&#xFF08;main&#x51FD;&#x6570;&#x5DF2;&#x7ECF;&#x5F00;&#x59CB;&#x8FD0;&#x884C;&#xFF09;</span>
        <span class="hljs-comment">// &#x5524;&#x9192;&#x6B63;&#x5728;&#x4F11;&#x7720;&#x7684;&#x5904;&#x7406;&#x5668;&#x6765;&#x5904;&#x7406;&#x65B0;&#x52A0;&#x5165;&#x7684;&#x534F;&#x7A0B;</span>
        <span class="hljs-keyword">if</span> mainStarted {
            wakep()
        }
    })
}

<span class="hljs-comment">// Create a new g in state _Grunnable, starting at fn. callerpc is the</span>
<span class="hljs-comment">// address of the go statement that created this. The caller is responsible</span>
<span class="hljs-comment">// for adding the new g to the scheduler.</span>
<span class="hljs-comment">// &#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x5904;&#x4E8E;&#x53EF;&#x8FD0;&#x884C;&#x72B6;&#x6001;&#x7684;G&#x6765;&#x8FD0;&#x884C;&#x51FD;&#x6570;</span>
<span class="hljs-keyword">func</span> newproc1(fn *funcval, callergp *g, callerpc <span class="hljs-keyword">uintptr</span>) *g {
    <span class="hljs-keyword">if</span> fn == <span class="hljs-literal">nil</span> {
        fatal(<span class="hljs-string">&quot;go of nil func value&quot;</span>)
    }

    mp := acquirem() <span class="hljs-comment">// disable preemption because we hold M and P in local vars.</span>
    pp := mp.p.ptr()
    <span class="hljs-comment">// &#x6839;&#x636E;P&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x7A7A;&#x95F2;&#x7684;g</span>
    newg := gfget(pp)
    <span class="hljs-comment">// &#x521D;&#x59CB;&#x5316;&#x9636;&#x6BB5;&#xFF0C;gfget &#x662F;&#x4E0D;&#x53EF;&#x80FD;&#x627E;&#x5230; g &#x7684;</span>
    <span class="hljs-comment">// &#x4E5F;&#x53EF;&#x80FD;&#x8FD0;&#x884C;&#x4E2D;&#x672C;&#x6765;&#x5C31;&#x5DF2;&#x7ECF;&#x8017;&#x5C3D;&#x4E86;</span>
    <span class="hljs-keyword">if</span> newg == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// &#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x62E5;&#x6709; _StackMin &#x5927;&#x5C0F;&#x7684;&#x6808;&#x7684; g</span>
        newg = malg(_StackMin)
        <span class="hljs-comment">// &#x5C06;&#x65B0;&#x521B;&#x5EFA;&#x7684; g &#x4ECE; _Gidle &#x66F4;&#x65B0;&#x4E3A; _Gdead &#x72B6;&#x6001;</span>
        casgstatus(newg, _Gidle, _Gdead)
        <span class="hljs-comment">// &#x5C06; Gdead &#x72B6;&#x6001;&#x7684; g &#x6DFB;&#x52A0;&#x5230; allg&#xFF0C;&#x8FD9;&#x6837; GC &#x4E0D;&#x4F1A;&#x626B;&#x63CF;&#x672A;&#x521D;&#x59CB;&#x5316;&#x7684;&#x6808;</span>
        allgadd(newg) <span class="hljs-comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn&apos;t look at uninitialized stack.</span>
    }
    <span class="hljs-keyword">if</span> newg.stack.hi == <span class="hljs-number">0</span> {
        throw(<span class="hljs-string">&quot;newproc1: newg missing stack&quot;</span>)
    }

    <span class="hljs-keyword">if</span> readgstatus(newg) != _Gdead {
        throw(<span class="hljs-string">&quot;newproc1: new g is not Gdead&quot;</span>)
    }

    <span class="hljs-comment">// &#x8BA1;&#x7B97;&#x8FD0;&#x884C;&#x7A7A;&#x95F4;&#x7684;&#x5927;&#x5C0F;</span>
    totalSize := <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">4</span>*goarch.PtrSize + sys.MinFrameSize) <span class="hljs-comment">// extra space in case of reads slightly beyond frame</span>
    totalSize = alignUp(totalSize, sys.StackAlign)
    <span class="hljs-comment">// &#x786E;&#x5B9A; sp &#x548C;&#x53C2;&#x6570;&#x5165;&#x6808;&#x4F4D;&#x7F6E;</span>
    sp := newg.stack.hi - totalSize
    spArg := sp
    <span class="hljs-keyword">if</span> usesLR {
        <span class="hljs-comment">// caller&apos;s LR</span>
        *(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="hljs-number">0</span>
        prepGoExitFrame(sp)
        spArg += sys.MinFrameSize
    }

    <span class="hljs-comment">// &#x6E05;&#x7406;&#x521B;&#x5EFA;&#x5E76;&#x521D;&#x59CB;&#x5316;g&#x7684;&#x8FD0;&#x884C;&#x73B0;&#x573A;</span>
    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))
    newg.sched.sp = sp
    newg.stktopsp = sp
    newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum <span class="hljs-comment">// +PCQuantum so that previous instruction is in same function</span>
    newg.sched.g = guintptr(unsafe.Pointer(newg))
    gostartcallfn(&amp;newg.sched, fn)
    <span class="hljs-comment">// &#x521D;&#x59CB;&#x5316;g&#x7684;&#x57FA;&#x672C;&#x72B6;&#x6001;</span>
    newg.gopc = callerpc
    newg.ancestors = saveAncestors(callergp) <span class="hljs-comment">// &#x8C03;&#x8BD5;&#x76F8;&#x5173;&#xFF0C;&#x8FFD;&#x8E2A;&#x8C03;&#x7528;&#x65B9;</span>
    newg.startpc = fn.fn                     <span class="hljs-comment">// &#x5165;&#x53E3;pc</span>
    <span class="hljs-comment">// &#x5224;&#x65AD;&#x662F;&#x5426;&#x662F;&#x7CFB;&#x7EDF;&#x534F;&#x7A0B;</span>
    <span class="hljs-keyword">if</span> isSystemGoroutine(newg, <span class="hljs-literal">false</span>) {
        sched.ngsys.Add(<span class="hljs-number">1</span>)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Only user goroutines inherit pprof labels.</span>
        <span class="hljs-keyword">if</span> mp.curg != <span class="hljs-literal">nil</span> {
            newg.labels = mp.curg.labels
        }
        <span class="hljs-keyword">if</span> goroutineProfile.active {
            <span class="hljs-comment">// A concurrent goroutine profile is running. It should include</span>
            <span class="hljs-comment">// exactly the set of goroutines that were alive when the goroutine</span>
            <span class="hljs-comment">// profiler first stopped the world. That does not include newg, so</span>
            <span class="hljs-comment">// mark it as not needing a profile before transitioning it from</span>
            <span class="hljs-comment">// _Gdead.</span>
            newg.goroutineProfiled.Store(goroutineProfileSatisfied)
        }
    }
    <span class="hljs-comment">// Track initial transition?</span>
    newg.trackingSeq = <span class="hljs-keyword">uint8</span>(fastrand())
    <span class="hljs-keyword">if</span> newg.trackingSeq%gTrackingPeriod == <span class="hljs-number">0</span> {
        newg.tracking = <span class="hljs-literal">true</span>
    }
    <span class="hljs-comment">// &#x5C06;g&#x66F4;&#x6362;&#x4E3A;&#x53EF;&#x8FD0;&#x884C;&#x72B6;&#x6001;</span>
    casgstatus(newg, _Gdead, _Grunnable)
    gcController.addScannableStack(pp, <span class="hljs-keyword">int64</span>(newg.stack.hi-newg.stack.lo))

    <span class="hljs-comment">// &#x5206;&#x914D;goid</span>
    <span class="hljs-keyword">if</span> pp.goidcache == pp.goidcacheend {
        <span class="hljs-comment">// Sched.goidgen is the last allocated id,</span>
        <span class="hljs-comment">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span>
        <span class="hljs-comment">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span>
        <span class="hljs-comment">// Sched.goidgen &#x4E3A;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5206;&#x914D;&#x7684; id&#xFF0C;&#x76F8;&#x5F53;&#x4E8E;&#x4E00;&#x4E2A;&#x5168;&#x5C40;&#x8BA1;&#x6570;&#x5668;</span>
        <span class="hljs-comment">// &#x8FD9;&#x4E00;&#x6279;&#x5FC5;&#x987B;&#x4E3A; [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span>
        <span class="hljs-comment">// &#x542F;&#x52A8;&#x65F6; sched.goidgen=0, &#x56E0;&#x6B64;&#x4E3B; Goroutine &#x7684; goid &#x4E3A; 1</span>
        pp.goidcache = sched.goidgen.Add(_GoidCacheBatch)
        pp.goidcache -= _GoidCacheBatch - <span class="hljs-number">1</span>
        pp.goidcacheend = pp.goidcache + _GoidCacheBatch
    }
    newg.goid = pp.goidcache
    pp.goidcache++
    <span class="hljs-keyword">if</span> raceenabled {
        newg.racectx = racegostart(callerpc)
        newg.raceignore = <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> newg.labels != <span class="hljs-literal">nil</span> {
            <span class="hljs-comment">// See note in proflabel.go on labelSync&apos;s role in synchronizing</span>
            <span class="hljs-comment">// with the reads in the signal handler.</span>
            racereleasemergeg(newg, unsafe.Pointer(&amp;labelSync))
        }
    }
    <span class="hljs-keyword">if</span> trace.enabled {
        traceGoCreate(newg, newg.startpc)
    }
    releasem(mp)

    <span class="hljs-comment">// &#x8FD4;&#x56DE;&#x65B0;&#x521B;&#x5EFA;&#x7684;g</span>
    <span class="hljs-keyword">return</span> newg
}
</code></pre>
<p>&#x5728;&#x8C03;&#x5EA6;&#x5668;&#x7684;&#x521D;&#x59CB;&#x5316;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x9996;&#x5148;&#x901A;&#x8FC7; <code>mcommoninit</code> &#x5BF9; M &#x7684;&#x4FE1;&#x53F7; G &#x8FDB;&#x884C;&#x521D;&#x59CB;&#x5316;&#x3002; &#x800C;&#x540E;&#x901A;&#x8FC7; <code>procresize</code> &#x521B;&#x5EFA;&#x4E0E; CPU &#x6838;&#x5FC3;&#x6570; (&#x6216;&#x4E0E;&#x7528;&#x6237;&#x6307;&#x5B9A;&#x7684; GOMAXPROCS) &#x76F8;&#x540C;&#x7684; P&#x3002; &#x6700;&#x540E;&#x901A;&#x8FC7; <code>newproc</code> &#x521B;&#x5EFA;&#x5305;&#x542B;&#x53EF;&#x4EE5;&#x8FD0;&#x884C;&#x8981;&#x6267;&#x884C;&#x51FD;&#x6570;&#x7684;&#x6267;&#x884C;&#x6808;&#x3001;&#x8FD0;&#x884C;&#x73B0;&#x573A;&#x7684; G&#xFF0C;&#x5E76;&#x5C06;&#x521B;&#x5EFA;&#x7684; G &#x653E;&#x5165;&#x521A;&#x521B;&#x5EFA;&#x597D;&#x7684; P &#x7684;&#x672C;&#x5730;&#x53EF;&#x8FD0;&#x884C;&#x961F;&#x5217;&#xFF08;&#x7B2C;&#x4E00;&#x4E2A;&#x5165;&#x961F;&#x7684; G&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x4E3B; Goroutine &#x8981;&#x6267;&#x884C;&#x7684;&#x51FD;&#x6570;&#x4F53;&#xFF09;&#xFF0C; &#x5B8C;&#x6210; G &#x7684;&#x521B;&#x5EFA;&#x3002;</p>
<h2 id="4&#x3001;&#x8C03;&#x5EA6;&#x5FAA;&#x73AF;">4&#x3001;&#x8C03;&#x5EA6;&#x5FAA;&#x73AF;</h2>
<p>&#x5728;&#x521D;&#x59CB;&#x5316;&#x4E2D;&#xFF0C;G&#x7684;&#x6808;&#x8FB9;&#x754C;&#x662F;&#x8FD8;&#x6CA1;&#x6709;&#x521D;&#x59CB;&#x5316;&#x7684;&#xFF0C;&#x56E0;&#x6B64;&#x9700;&#x8981;&#x5728;&#x8C03;&#x5EA6;&#x5F00;&#x59CB;&#x524D;&#x8BA1;&#x7B97;&#x6808;&#x8FB9;&#x754C;&#x3002;</p>
<p>mstart0&#x662F;&#x6240;&#x6709;&#x65B0;&#x521B;&#x5EFA;&#x7684;M&#x7684;&#x8D77;&#x70B9;&#x3002;</p>
<p><span style="color: red">Goroutine&#x901A;&#x5E38;&#x4F7F;&#x7528;Go&#x8FD0;&#x884C;&#x65F6;&#x5206;&#x914D;&#x7684;&#x6808;&#xFF0C;&#x800C;g0&#x4F7F;&#x7528;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x5206;&#x914D;&#x7684;&#x6808;&#x3002;g0&#x662F;&#x6BCF;&#x4E2A;M&#x4E0A;&#x7684;&#x7279;&#x6B8A;&#x534F;&#x7A0B;&#xFF0C;&#x4E13;&#x95E8;&#x7528;&#x4E8E;&#x6267;&#x884C;&#x7CFB;&#x7EDF;&#x4EFB;&#x52A1;&#xFF0C;&#x5982;&#x5783;&#x573E;&#x56DE;&#x6536;&#xFF0C;&#x8C03;&#x5EA6;&#x7B49;</span></p>
<pre><code class="lang-go"><span class="hljs-comment">// mstart0 is the Go entry-point for new Ms.</span>
<span class="hljs-comment">// This must not split the stack because we may not even have stack</span>
<span class="hljs-comment">// bounds set up yet.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// May run during STW (because it doesn&apos;t have a P yet), so write</span>
<span class="hljs-comment">// barriers are not allowed.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-comment">//go:nowritebarrierrec</span>
<span class="hljs-keyword">func</span> mstart0() {
    gp := getg()

    <span class="hljs-comment">// &#x5F00;&#x59CB;&#x786E;&#x5B9A;&#x6267;&#x884C;&#x6808;&#x7684;&#x8FB9;&#x754C;&#x4E86;</span>
    <span class="hljs-comment">// &#x901A;&#x8FC7;&#x68C0;&#x67E5; g &#x6267;&#x884C;&#x6808;&#x7684;&#x8FB9;&#x754C;&#x6765;&#x786E;&#x5B9A;&#x662F;&#x5426;&#x4E3A;&#x7CFB;&#x7EDF;&#x6808;</span>
    osStack := gp.stack.lo == <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> osStack {
        <span class="hljs-comment">// Initialize stack bounds from system stack.</span>
        <span class="hljs-comment">// Cgo may have left stack size in stack.hi.</span>
        <span class="hljs-comment">// minit may update the stack bounds.</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// Note: these bounds may not be very accurate.</span>
        <span class="hljs-comment">// We set hi to &amp;size, but there are things above</span>
        <span class="hljs-comment">// it. The 1024 is supposed to compensate this,</span>
        <span class="hljs-comment">// but is somewhat arbitrary.</span>
        <span class="hljs-comment">// &#x7CFB;&#x7EDF;&#x6808;&#x9700;&#x8981;&#x624B;&#x52A8;&#x8BBE;&#x7F6E;&#x6808;&#x7684;&#x9AD8;&#x4F4E;&#x8FB9;&#x754C;</span>
        size := gp.stack.hi
        <span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> {
            <span class="hljs-comment">// &#x6808;&#x7684;&#x5927;&#x5C0F;&#x9ED8;&#x8BA4;&#x8BBE;&#x7F6E;&#x4E3A; 8192 * sys.StackGuardMultiplier</span>
            size = <span class="hljs-number">8192</span> * sys.StackGuardMultiplier
        }
        <span class="hljs-comment">// &#x9AD8;&#x5730;&#x5740;&#x8FB9;&#x754C; gp.stack.hi &#x8BBE;&#x7F6E;&#x4E3A;&#x5F53;&#x524D;&#x6808;&#x7684;&#x9AD8;&#x5730;&#x5740;&#x3002;</span>
        gp.stack.hi = <span class="hljs-keyword">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))
        <span class="hljs-comment">// &#x8C03;&#x6574;&#x4F4E;&#x5730;&#x5740;&#x8FB9;&#x754C; gp.stack.lo&#x3002;</span>
        gp.stack.lo = gp.stack.hi - size + <span class="hljs-number">1024</span>
    }
    <span class="hljs-comment">// Initialize stack guard so that we can start calling regular</span>
    <span class="hljs-comment">// Go code.</span>
    <span class="hljs-comment">// &#x521D;&#x59CB;&#x5316;&#x5806;&#x6808;&#x4FDD;&#x62A4;&#xFF0C;&#x4EE5;&#x4FBF;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x5F00;&#x59CB;&#x8C03;&#x7528;&#x5E38;&#x89C4; Go &#x4EE3;&#x7801;&#x3002;</span>
    <span class="hljs-comment">// &#x8BA1;&#x7B97;&#x6808;&#x7684;&#x4FDD;&#x62A4;&#x8FB9;&#x754C;</span>
    <span class="hljs-comment">// gp.stackguard0 &#x548C; gp.stackguard1 &#x90FD;&#x8BBE;&#x7F6E;&#x4E3A;&#x8DDD;&#x79BB;&#x6808;&#x5E95;&#x4E00;&#x5B9A;&#x8DDD;&#x79BB;&#xFF08;_StackGuard&#xFF09;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;</span>
    <span class="hljs-comment">// &#x8FD9;&#x4FDD;&#x8BC1;&#x4E86;&#x5728;&#x6808;&#x7A7A;&#x95F4;&#x4E0D;&#x8DB3;&#x65F6;&#x80FD;&#x591F;&#x68C0;&#x6D4B;&#x5230;&#x6808;&#x6EA2;&#x51FA;&#x5E76;&#x5904;&#x7406;&#x3002;</span>
    gp.stackguard0 = gp.stack.lo + _StackGuard
    <span class="hljs-comment">// This is the g0, so we can also call go:systemstack</span>
    <span class="hljs-comment">// functions, which check stackguard1.</span>
    <span class="hljs-comment">// &#x8FD9;&#x662F; g0&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4EEC;&#x8FD8;&#x53EF;&#x4EE5;&#x8C03;&#x7528; go:systemstack &#x51FD;&#x6570;&#x6765;&#x68C0;&#x67E5; stackguard1&#x3002;</span>
    gp.stackguard1 = gp.stackguard0
    <span class="hljs-comment">// &#x542F;&#x52A8;</span>
    mstart1()

    <span class="hljs-comment">// Exit this thread.</span>
    <span class="hljs-keyword">if</span> mStackIsSystemAllocated() {
        <span class="hljs-comment">// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate</span>
        <span class="hljs-comment">// the stack, but put it in gp.stack before mstart,</span>
        <span class="hljs-comment">// so the logic above hasn&apos;t set osStack yet.</span>
        <span class="hljs-comment">// &#x6839;&#x636E;&#x7CFB;&#x7EDF;&#x6808;&#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x63A8;&#x51FA;&#x7EBF;&#x7A0B;</span>
        osStack = <span class="hljs-literal">true</span>
    }
    <span class="hljs-comment">// &#x9000;&#x51FA;&#x7EBF;&#x7A0B;</span>
    mexit(osStack)
}
</code></pre>
<pre><code class="lang-go"><span class="hljs-comment">// The go:noinline is to guarantee the getcallerpc/getcallersp below are safe,</span>
<span class="hljs-comment">// so that we can set up g0.sched to return to the call of mstart1 above.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:noinline</span>
<span class="hljs-keyword">func</span> mstart1() {
    gp := getg()

    <span class="hljs-comment">// &#x68C0;&#x67E5;&#x662F;&#x5426;&#x4E3A;g0</span>
    <span class="hljs-keyword">if</span> gp != gp.m.g0 {
        throw(<span class="hljs-string">&quot;bad runtime&#xB7;mstart&quot;</span>)
    }

    <span class="hljs-comment">// Set up m.g0.sched as a label returning to just</span>
    <span class="hljs-comment">// after the mstart1 call in mstart0 above, for use by goexit0 and mcall.</span>
    <span class="hljs-comment">// We&apos;re never coming back to mstart1 after we call schedule,</span>
    <span class="hljs-comment">// so other calls can reuse the current frame.</span>
    <span class="hljs-comment">// And goexit0 does a gogo that needs to return from mstart1</span>
    <span class="hljs-comment">// and let mstart0 exit the thread.</span>
    <span class="hljs-comment">// &#x4E3A;&#x4E86;&#x5728; mcall &#x7684;&#x6808;&#x9876;&#x4F7F;&#x7528;&#x8C03;&#x7528;&#x65B9;&#x6765;&#x7ED3;&#x675F;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#xFF0C;&#x505A;&#x8BB0;&#x5F55;</span>
    <span class="hljs-comment">// &#x5F53;&#x8FDB;&#x5165; schedule &#x4E4B;&#x540E;&#xFF0C;&#x6211;&#x4EEC;&#x518D;&#x4E5F;&#x4E0D;&#x4F1A;&#x56DE;&#x5230; mstart1&#xFF0C;&#x6240;&#x4EE5;&#x5176;&#x4ED6;&#x8C03;&#x7528;&#x53EF;&#x4EE5;&#x590D;&#x7528;&#x5F53;&#x524D;&#x5E27;&#x3002;</span>
    <span class="hljs-comment">// &#x8BBE;&#x7F6E; g0 &#x7684; sched &#x5B57;&#x6BB5;&#xFF08;&#x8C03;&#x5EA6;&#x4FE1;&#x606F;&#xFF09;&#xFF0C;&#x4EE5;&#x4FBF;&#x7A0D;&#x540E;&#x5728;&#x9700;&#x8981;&#x65F6;&#x53EF;&#x4EE5;&#x4ECE;&#x5F53;&#x524D;&#x7684;&#x6808;&#x5E27;&#x8FD4;&#x56DE;</span>
    <span class="hljs-comment">// g0.sched.pc &#x8BBE;&#x7F6E;&#x4E3A;&#x8C03;&#x7528; mstart1 &#x65F6;&#x7684;&#x8C03;&#x7528;&#x5730;&#x5740;&#x3002;</span>
    <span class="hljs-comment">// g0.sched.sp &#x8BBE;&#x7F6E;&#x4E3A;&#x5F53;&#x524D;&#x6808;&#x7684;&#x6307;&#x9488;&#x3002;</span>
    <span class="hljs-comment">// &#x8FD9;&#x4E9B;&#x8BBE;&#x7F6E;&#x786E;&#x4FDD;&#x5728; goexit0 &#x6216; mcall &#x51FD;&#x6570;&#x8C03;&#x7528;&#x65F6;&#xFF0C;M &#x53EF;&#x4EE5;&#x6B63;&#x786E;&#x5730;&#x8FD4;&#x56DE;&#x5E76;&#x8BA9; mstart0 &#x9000;&#x51FA;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x3002;</span>
    gp.sched.g = guintptr(unsafe.Pointer(gp))
    gp.sched.pc = getcallerpc()
    gp.sched.sp = getcallersp()

    <span class="hljs-comment">// &#x6C47;&#x7F16;&#x5C42;&#x9762;&#x7684;&#x521D;&#x59CB;&#x5316;&#x5DE5;&#x4F5C;</span>
    asminit()
    <span class="hljs-comment">// minit() &#x662F;&#x7528;&#x4E8E;&#x521D;&#x59CB;&#x5316; M &#x7684;&#x5E73;&#x53F0;&#x76F8;&#x5173;&#x8BBE;&#x7F6E;&#xFF0C;&#x786E;&#x4FDD;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x53EF;&#x4EE5;&#x5904;&#x7406; Go &#x8FD0;&#x884C;&#x65F6;&#x6240;&#x9700;&#x7684;&#x73AF;&#x5883;&#x548C;&#x4FE1;&#x53F7;&#x3002;</span>
    minit()

    <span class="hljs-comment">// Install signal handlers; after minit so that minit can</span>
    <span class="hljs-comment">// prepare the thread to be able to handle the signals.</span>
    <span class="hljs-comment">// &#x8BBE;&#x7F6E;&#x4FE1;&#x53F7; handler&#xFF1B;&#x5728; minit &#x4E4B;&#x540E;&#xFF0C;&#x56E0;&#x4E3A; minit &#x53EF;&#x4EE5;&#x51C6;&#x5907;&#x5904;&#x7406;&#x4FE1;&#x53F7;&#x7684;&#x7684;&#x7EBF;&#x7A0B;</span>
    <span class="hljs-comment">// &#x5904;&#x7406;&#x4FE1;&#x53F7;&#x5904;&#x7406;&#x7A0B;&#x5E8F; (mstartm0)&#xFF1A;</span>
    <span class="hljs-keyword">if</span> gp.m == &amp;m0 {
        mstartm0()
    }

    <span class="hljs-comment">// &#x6267;&#x884C;&#x542F;&#x52A8;&#x51FD;&#x6570;</span>
    <span class="hljs-comment">// &#x4E00;&#x4E2A;&#x53EF;&#x9009;&#x7684;&#x521D;&#x59CB;&#x5316;&#x51FD;&#x6570;&#xFF0C;&#x53EF;&#x4EE5;&#x5728; M &#x542F;&#x52A8;&#x65F6;&#x6267;&#x884C;&#x3002;</span>
    <span class="hljs-keyword">if</span> fn := gp.m.mstartfn; fn != <span class="hljs-literal">nil</span> {
        fn()
    }

    <span class="hljs-comment">// &#x5982;&#x679C;&#x5F53;&#x524D; m &#x5E76;&#x975E; m0&#xFF0C;&#x5219;&#x8981;&#x6C42;&#x7ED1;&#x5B9A; p</span>
    <span class="hljs-keyword">if</span> gp.m != &amp;m0 {
        <span class="hljs-comment">// &#x7ED1;&#x5B9A; p</span>
        acquirep(gp.m.nextp.ptr())
        gp.m.nextp = <span class="hljs-number">0</span>
    }
    <span class="hljs-comment">// &#x5F7B;&#x5E95;&#x51C6;&#x5907;&#x597D;&#xFF0C;&#x5F00;&#x59CB;&#x8C03;&#x5EA6;&#xFF0C;&#x6C38;&#x4E0D;&#x8FD4;&#x56DE;</span>
    <span class="hljs-comment">// &#x8FDB;&#x5165; Go &#x7684;&#x8C03;&#x5EA6;&#x5FAA;&#x73AF;&#x3002;&#x8C03;&#x5EA6;&#x5668;&#x4F1A;&#x9009;&#x62E9;&#x5F85;&#x6267;&#x884C;&#x7684; Goroutine &#x5E76;&#x5728;&#x5F53;&#x524D;&#x7684; M &#x4E0A;&#x8FD0;&#x884C;&#x5B83;&#x3002;</span>
    <span class="hljs-comment">// &#x8FD9;&#x662F;&#x4E00;&#x4E2A;&#x6B7B;&#x5FAA;&#x73AF;&#xFF0C;&#x6267;&#x884C;&#x540E;&#x6C38;&#x4E0D;&#x8FD4;&#x56DE;&#xFF0C;&#x56E0;&#x6B64; M &#x5C06;&#x4E00;&#x76F4;&#x5728;&#x8C03;&#x5EA6; Goroutine&#x3002;</span>
    schedule()
}
</code></pre>
<ul>
<li>mstart&#x9664;&#x4E86;&#x5728;&#x7A0B;&#x5E8F;&#x5F15;&#x5BFC;&#x9636;&#x6BB5;&#x4F1A;&#x88AB;&#x8FD0;&#x884C;&#x4E4B;&#x5916;&#xFF0C;&#x4E5F;&#x53EF;&#x80FD;&#x5728;&#x6BCF;&#x4E2A;m&#x88AB;&#x521B;&#x5EFA;&#x65F6;&#x8FD0;&#x884C;&#x3002;</li>
<li>mstart&#x8FDB;&#x5165;mstart1&#x4E4B;&#x540E;&#xFF0C;&#x4F1A;&#x521D;&#x59CB;&#x5316;&#x81EA;&#x8EAB;&#x7528;&#x4E8E;&#x4FE1;&#x53F7;&#x5904;&#x7406;&#x7684;g</li>
<li>&#x8C03;&#x5EA6;&#x5FAA;&#x73AF; <code>schedule</code> &#x65E0;&#x6CD5;&#x8FD4;&#x56DE;&#xFF0C;&#x56E0;&#x6B64;&#x6700;&#x540E;&#x4E00;&#x4E2A; <code>mexit</code> &#x76EE;&#x524D;&#x8FD8;&#x4E0D;&#x4F1A;&#x88AB;&#x6267;&#x884C;&#xFF0C;&#x56E0;&#x6B64;&#x5F53;&#x4E0B;&#x6240;&#x6709;&#x7684; Go &#x7A0B;&#x5E8F;&#x521B;&#x5EFA;&#x7684;&#x7EBF;&#x7A0B;&#x90FD;&#x65E0;&#x6CD5;&#x88AB;&#x91CA;&#x653E; &#xFF08;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x7279;&#x4F8B;&#xFF0C;&#x5F53;&#x4F7F;&#x7528; <code>runtime.LockOSThread</code> &#x9501;&#x4F4F;&#x7684; G &#x9000;&#x51FA;&#x65F6;&#x4F1A;&#x4F7F;&#x7528; <code>gogo</code> &#x9000;&#x51FA; M</li>
</ul>
<h3 id="m&#x4E0E;p&#x7684;&#x7ED1;&#x5B9A;">M&#x4E0E;P&#x7684;&#x7ED1;&#x5B9A;</h3>
<p>M &#x4E0E; P &#x7684;&#x7ED1;&#x5B9A;&#x8FC7;&#x7A0B;&#x53EA;&#x662F;&#x7B80;&#x5355;&#x7684;&#x5C06; P &#x94FE;&#x8868;&#x4E2D;&#x7684; P &#xFF0C;&#x4FDD;&#x5B58;&#x5230; M &#x4E2D;&#x7684; P &#x6307;&#x9488;&#x4E0A;&#x3002; &#x7ED1;&#x5B9A;&#x524D;&#xFF0C;P &#x7684;&#x72B6;&#x6001;&#x4E00;&#x5B9A;&#x662F; <code>_Pidle</code>&#xFF0C;&#x7ED1;&#x5B9A;&#x540E; P &#x7684;&#x72B6;&#x6001;&#x4E00;&#x5B9A;&#x4E3A; <code>_Prunning</code>&#x3002;</p>
<pre><code class="lang-go">
<span class="hljs-comment">// Associate p and the current m.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// This function is allowed to have write barriers even if the caller</span>
<span class="hljs-comment">// isn&apos;t because it immediately acquires pp.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x5C06; p &#x548C;&#x5F53;&#x524D; m &#x5173;&#x8054;&#x8D77;&#x6765;&#x3002;&#x5373;&#x4F7F;&#x8C03;&#x7528;&#x8005;&#x6CA1;&#x6709;&#xFF0C;&#x8BE5;&#x51FD;&#x6570;&#x4E5F;&#x53EF;&#x4EE5;&#x6709;&#x5199;&#x5C4F;&#x969C;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x7ACB;&#x5373;&#x83B7;&#x53D6; pp&#x3002;</span>
<span class="hljs-comment">//go:yeswritebarrierrec</span>
<span class="hljs-keyword">func</span> acquirep(pp *p) {
    <span class="hljs-comment">// Do the part that isn&apos;t allowed to have write barriers.</span>
    wirep(pp)

    <span class="hljs-comment">// Have p; write barriers now allowed.</span>

    <span class="hljs-comment">// Perform deferred mcache flush before this P can allocate</span>
    <span class="hljs-comment">// from a potentially stale mcache.</span>
    pp.mcache.prepareForSweep()

    <span class="hljs-keyword">if</span> trace.enabled {
        traceProcStart()
    }
}

<span class="hljs-comment">// wirep is the first step of acquirep, which actually associates the</span>
<span class="hljs-comment">// current M to pp. This is broken out so we can disallow write</span>
<span class="hljs-comment">// barriers for this part, since we don&apos;t yet have a P.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// wirep &#x662F; acquirep &#x7684;&#x7B2C;&#x4E00;&#x6B65;&#xFF0C;&#x5B83;&#x5B9E;&#x9645;&#x4E0A;&#x5C06;&#x5F53;&#x524D;&#x7684; M &#x5173;&#x8054;&#x5230; pp&#x3002;</span>
<span class="hljs-comment">// &#x8FD9;&#x5DF2;&#x88AB;&#x6253;&#x7834;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x7981;&#x6B62;&#x8FD9;&#x90E8;&#x5206;&#x7684;&#x5199;&#x5C4F;&#x969C;&#xFF0C;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x8FD8;&#x6CA1;&#x6709; P&#x3002;</span>
<span class="hljs-comment">//go:nowritebarrierrec</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-keyword">func</span> wirep(pp *p) {
    gp := getg()

    <span class="hljs-keyword">if</span> gp.m.p != <span class="hljs-number">0</span> {
        throw(<span class="hljs-string">&quot;wirep: already in go&quot;</span>)
    }
    <span class="hljs-comment">// &#x68C0;&#x67E5; m &#x662F;&#x5426;&#x6B63;&#x5E38;&#xFF0C;&#x5E76;&#x68C0;&#x67E5;&#x8981;&#x83B7;&#x53D6;&#x7684; p &#x7684;&#x72B6;&#x6001;</span>
    <span class="hljs-keyword">if</span> pp.m != <span class="hljs-number">0</span> || pp.status != _Pidle {
        id := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> pp.m != <span class="hljs-number">0</span> {
            id = pp.m.ptr().id
        }
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;wirep: p-&gt;m=&quot;</span>, pp.m, <span class="hljs-string">&quot;(&quot;</span>, id, <span class="hljs-string">&quot;) p-&gt;status=&quot;</span>, pp.status, <span class="hljs-string">&quot;\n&quot;</span>)
        throw(<span class="hljs-string">&quot;wirep: invalid p state&quot;</span>)
    }
    <span class="hljs-comment">// &#x5C06; p &#x7ED1;&#x5B9A;&#x5230; m&#xFF0C;p &#x548C; m &#x4E92;&#x76F8;&#x5F15;&#x7528;</span>
    gp.m.p.set(pp)
    pp.m.set(gp.m)
    pp.status = _Prunning
}
</code></pre>
<h3 id="m&#x7684;&#x6682;&#x6B62;&#x548C;&#x590D;&#x59CB;">M&#x7684;&#x6682;&#x6B62;&#x548C;&#x590D;&#x59CB;</h3>
<p>&#x5F53; M &#x9700;&#x8981;&#x88AB;&#x6682;&#x6B62;&#x65F6;&#xFF0C;&#x53EF;&#x80FD;&#xFF08;&#x56E0;&#x4E3A;&#x8FD8;&#x6709;&#x5176;&#x4ED6;&#x6682;&#x6B62; M &#x7684;&#x65B9;&#x6CD5;&#xFF09;&#x4F1A;&#x6267;&#x884C;&#x8BE5;&#x8C03;&#x7528;&#x3002; &#x6B64;&#x8C03;&#x7528;&#x4F1A;&#x5C06; M &#x8FDB;&#x884C;&#x6682;&#x6B62;&#xFF0C;&#x5E76;&#x963B;&#x585E;&#x5230;&#x5B83;&#x88AB;&#x590D;&#x59CB;&#x65F6;&#x3002;&#x8FD9;&#x4E00;&#x8FC7;&#x7A0B;&#x5C31;&#x662F;&#x5DE5;&#x4F5C;&#x7EBF;&#x7A0B;&#x7684;&#x6682;&#x6B62;&#x548C;&#x590D;&#x59CB;&#x3002;</p>
<p>&#x5C06;m&#x653E;&#x56DE;&#x5230;&#x7A7A;&#x95F2;&#x5217;&#x8868;&#x4E2D;&#xFF0C;&#x800C;&#x540E;&#x4F7F;&#x7528;note&#x6CE8;&#x518C;&#x4E00;&#x4E2A;&#x6682;&#x6B62;&#x901A;&#x77E5;&#xFF0C;&#x963B;&#x585E;&#x5230;&#x5B83;&#x91CD;&#x65B0;&#x88AB;&#x590D;&#x59CB;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Stops execution of the current m until new work is available.</span>
<span class="hljs-comment">// Returns with acquired P.</span>
<span class="hljs-comment">// &#x505C;&#x6B62;&#x5F53;&#x524D; m &#x7684;&#x6267;&#x884C;&#xFF0C;&#x76F4;&#x5230;&#x6709;&#x65B0;&#x5DE5;&#x4F5C;&#x53EF;&#x7528;&#x3002;</span>
<span class="hljs-keyword">func</span> stopm() {
    gp := getg()

    <span class="hljs-keyword">if</span> gp.m.locks != <span class="hljs-number">0</span> {
        throw(<span class="hljs-string">&quot;stopm holding locks&quot;</span>)
    }
    <span class="hljs-keyword">if</span> gp.m.p != <span class="hljs-number">0</span> {
        throw(<span class="hljs-string">&quot;stopm holding p&quot;</span>)
    }
    <span class="hljs-keyword">if</span> gp.m.spinning {
        throw(<span class="hljs-string">&quot;stopm spinning&quot;</span>)
    }

    <span class="hljs-comment">// &#x5C06; m &#x653E;&#x56DE;&#x5230; &#x7A7A;&#x95F2;&#x5217;&#x8868;&#x4E2D;&#xFF0C;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x9A6C;&#x4E0A;&#x5C31;&#x8981;&#x6682;&#x6B62;&#x4E86;</span>
    lock(&amp;sched.lock)
    mput(gp.m)
    unlock(&amp;sched.lock)
    <span class="hljs-comment">// &#x6682;&#x6B62;&#x5F53;&#x524D;&#x7684; M&#xFF0C;&#x5728;&#x6B64;&#x963B;&#x585E;&#xFF0C;&#x76F4;&#x5230;&#x88AB;&#x5524;&#x9192;</span>
    mPark()
    <span class="hljs-comment">// &#x6B64;&#x65F6;&#x5DF2;&#x7ECF;&#x88AB;&#x590D;&#x59CB;&#xFF0C;&#x8BF4;&#x660E;&#x6709;&#x4EFB;&#x52A1;&#x8981;&#x6267;&#x884C;</span>
    <span class="hljs-comment">// &#x7ACB;&#x5373; acquire P</span>
    acquirep(gp.m.nextp.ptr())
    gp.m.nextp = <span class="hljs-number">0</span>
}
</code></pre>
<h3 id="&#x6838;&#x5FC3;&#x8C03;&#x5EA6;">&#x6838;&#x5FC3;&#x8C03;&#x5EA6;</h3>
<p><img src="../image/&#x534F;&#x7A0B;&#x8C03;&#x5EA6;.png" alt="&#x534F;&#x7A0B;&#x8C03;&#x5EA6;" style="zoom:150%;"></p>
<h4 id="1&#x3001;&#x4E3B;&#x6D41;&#x7A0B;">1&#x3001;&#x4E3B;&#x6D41;&#x7A0B;</h4>
<pre><code class="lang-go"><span class="hljs-comment">// One round of scheduler: find a runnable goroutine and execute it.</span>
<span class="hljs-comment">// Never returns.</span>
<span class="hljs-keyword">func</span> schedule() {
    mp := getg().m

    <span class="hljs-comment">// &#x68C0;&#x67E5;&#x7EBF;&#x7A0B;&#x7684;&#x9501;&#x5B9A;&#x72B6;&#x6001;</span>
    <span class="hljs-comment">// &#x8C03;&#x5EA6;&#x5668;&#x4E0D;&#x80FD;&#x5728; M&#xFF08;&#x7EBF;&#x7A0B;&#xFF09;&#x6301;&#x6709;&#x9501;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x8FDB;&#x884C;&#x3002;</span>
    <span class="hljs-comment">// mp.locks &#x8868;&#x793A;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x662F;&#x5426;&#x6301;&#x6709;&#x4EFB;&#x4F55;&#x9501;&#x3002;</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x9501;&#x6CA1;&#x6709;&#x91CA;&#x653E;&#x5C31;&#x8FDB;&#x5165;&#x8C03;&#x5EA6;&#x5668;&#xFF0C;&#x4F1A;&#x5BFC;&#x81F4;&#x6B7B;&#x9501;&#xFF0C;&#x56E0;&#x6B64;&#x76F4;&#x63A5;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x3002;</span>
    <span class="hljs-keyword">if</span> mp.locks != <span class="hljs-number">0</span> {
        throw(<span class="hljs-string">&quot;schedule: holding locks&quot;</span>)
    }

    <span class="hljs-comment">// m.lockedg &#x4F1A;&#x5728; LockOSThread &#x4E0B;&#x53D8;&#x4E3A;&#x975E;&#x96F6;</span>
    <span class="hljs-comment">// LockOSThread &#x662F;&#x4E00;&#x79CD;&#x5C06; goroutine &#x7ED1;&#x5B9A;&#x5230;&#x7279;&#x5B9A;&#x7CFB;&#x7EDF;&#x7EBF;&#x7A0B;&#x7684;&#x673A;&#x5236;&#x3002;</span>
    <span class="hljs-comment">// &#x8FD9;&#x91CC;&#x68C0;&#x67E5; mp.lockedg &#x662F;&#x5426;&#x975E;&#x96F6;&#xFF0C;&#x5982;&#x679C;&#x975E;&#x96F6;&#xFF0C;&#x8BF4;&#x660E;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x6709;&#x4E00;&#x4E2A;&#x7ED1;&#x5B9A;&#x7684; goroutine&#xFF0C;&#x5E94;&#x8BE5;&#x4F18;&#x5148;&#x8C03;&#x5EA6;&#x5B83;&#x3002;</span>
    <span class="hljs-keyword">if</span> mp.lockedg != <span class="hljs-number">0</span> {
        stoplockedm()
        execute(mp.lockedg.ptr(), <span class="hljs-literal">false</span>) <span class="hljs-comment">// Never returns.</span>
    }

    <span class="hljs-comment">// We should not schedule away from a g that is executing a cgo call,</span>
    <span class="hljs-comment">// since the cgo call is using the m&apos;s g0 stack.</span>
    <span class="hljs-comment">// &#x6211;&#x4EEC;&#x4E0D;&#x5E94;&#x8BE5;&#x8C03;&#x5EA6;&#x8FDC;&#x79BB;&#x6B63;&#x5728;&#x6267;&#x884C; cgo &#x8C03;&#x7528;&#x7684; g&#xFF0C;&#x56E0;&#x4E3A; cgo &#x8C03;&#x7528;&#x6B63;&#x5728;&#x4F7F;&#x7528; m &#x7684; g0 &#x5806;&#x6808;&#x3002;</span>
    <span class="hljs-comment">// cgo &#x8C03;&#x7528;&#x4F9D;&#x8D56;&#x4E8E; M &#x7684; g0 &#x6808;&#xFF0C;&#x56E0;&#x6B64;&#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x6B63;&#x5728;&#x6267;&#x884C; cgo &#x8C03;&#x7528;&#xFF0C;&#x8C03;&#x5EA6;&#x5668;&#x4E0D;&#x80FD;&#x5207;&#x6362;&#x5230;&#x5176;&#x4ED6; goroutine&#x3002;</span>
    <span class="hljs-keyword">if</span> mp.incgo {
        throw(<span class="hljs-string">&quot;schedule: in cgo&quot;</span>)
    }

top:
    pp := mp.p.ptr()
    <span class="hljs-comment">// &#x5F53;&#x524D;&#x4E0D;&#x5141;&#x8BB8;&#x62A2;&#x5360;&#x8C03;&#x5EA6;</span>
    pp.preempt = <span class="hljs-literal">false</span>

    <span class="hljs-comment">// Safety check: if we are spinning, the run queue should be empty.</span>
    <span class="hljs-comment">// Check this before calling checkTimers, as that might call</span>
    <span class="hljs-comment">// goready to put a ready goroutine on the local run queue.</span>
    <span class="hljs-comment">// &#x5B89;&#x5168;&#x68C0;&#x67E5;&#xFF1A;&#x5982;&#x679C;&#x6211;&#x4EEC;&#x6B63;&#x5728;&#x65CB;&#x8F6C;&#xFF0C;&#x5219;&#x8FD0;&#x884C;&#x961F;&#x5217;&#x5E94;&#x8BE5;&#x4E3A;&#x7A7A;&#x3002;</span>
    <span class="hljs-comment">// &#x5728;&#x8C03;&#x7528; checkTimers &#x4E4B;&#x524D;&#x68C0;&#x67E5;&#x6B64;&#x9879;&#xFF0C;&#x56E0;&#x4E3A;&#x8FD9;&#x53EF;&#x80FD;&#x4F1A;&#x8C03;&#x7528; goready &#x5C06;&#x5C31;&#x7EEA;&#x7684; Goroutine &#x653E;&#x5165;&#x672C;&#x5730;&#x8FD0;&#x884C;&#x961F;&#x5217;&#x3002;</span>
    <span class="hljs-keyword">if</span> mp.spinning &amp;&amp; (pp.runnext != <span class="hljs-number">0</span> || pp.runqhead != pp.runqtail) {
        throw(<span class="hljs-string">&quot;schedule: spinning with local work&quot;</span>)
    }

    <span class="hljs-comment">// &#x8BE5;&#x51FD;&#x6570;&#x8FD4;&#x56DE;&#x53EF;&#x8FD0;&#x884C;&#x7684; goroutine gp&#x3001;&#x662F;&#x5426;&#x7EE7;&#x627F;&#x8C03;&#x5EA6;&#x65F6;&#x95F4; inheritTime &#x4EE5;&#x53CA;&#x662F;&#x5426;&#x9700;&#x8981;&#x5524;&#x9192;&#x5176;&#x4ED6; P (tryWakeP)&#x3002;</span>
    gp, inheritTime, tryWakeP := findRunnable() <span class="hljs-comment">// blocks until work is available</span>

    <span class="hljs-comment">// This thread is going to run a goroutine and is not spinning anymore,</span>
    <span class="hljs-comment">// so if it was marked as spinning we need to reset it now and potentially</span>
    <span class="hljs-comment">// start a new spinning M.</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5728;&#x6267;&#x884C;&#x524D;&#x662F;&#x5904;&#x4E8E;&#x65CB;&#x8F6C;&#x72B6;&#x6001;&#xFF0C;&#x5219;&#x9700;&#x8981;&#x5C06;&#x5176;&#x6807;&#x8BB0;&#x4E3A;&#x4E0D;&#x518D;&#x65CB;&#x8F6C;&#xFF0C;&#x5E76;&#x91CD;&#x7F6E;&#x65CB;&#x8F6C;&#x72B6;&#x6001;&#x3002;</span>
    <span class="hljs-keyword">if</span> mp.spinning {
        resetspinning()
    }

    <span class="hljs-comment">// &#x5904;&#x7406;&#x8C03;&#x5EA6;&#x7981;&#x7528;</span>
    <span class="hljs-keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) {
        <span class="hljs-comment">// Scheduling of this goroutine is disabled. Put it on</span>
        <span class="hljs-comment">// the list of pending runnable goroutines for when we</span>
        <span class="hljs-comment">// re-enable user scheduling and look again.</span>
        <span class="hljs-comment">// &#x8C03;&#x5EA6;&#x5668;&#x652F;&#x6301;&#x7981;&#x7528;&#x67D0;&#x4E9B; goroutine &#x7684;&#x8C03;&#x5EA6;&#x3002;</span>
        <span class="hljs-comment">// &#x5982;&#x679C;&#x8C03;&#x5EA6;&#x88AB;&#x7981;&#x7528;&#x4E14;&#x5F53;&#x524D; goroutine &#x4E0D;&#x5141;&#x8BB8;&#x8C03;&#x5EA6;&#xFF0C;&#x5219;&#x5C06;&#x5B83;&#x653E;&#x5230;&#x7B49;&#x5F85;&#x8FD0;&#x884C;&#x7684;&#x5217;&#x8868;&#x4E2D;&#x3002;</span>
        lock(&amp;sched.lock)
        <span class="hljs-keyword">if</span> schedEnabled(gp) {
            <span class="hljs-comment">// Something re-enabled scheduling while we</span>
            <span class="hljs-comment">// were acquiring the lock.</span>
            unlock(&amp;sched.lock)
        } <span class="hljs-keyword">else</span> {
            sched.disable.runnable.pushBack(gp)
            sched.disable.n++
            unlock(&amp;sched.lock)
            <span class="hljs-keyword">goto</span> top
        }
    }

    <span class="hljs-comment">// If about to schedule a not-normal goroutine (a GCworker or tracereader),</span>
    <span class="hljs-comment">// wake a P if there is one.</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x8FD4;&#x56DE;&#x7684; goroutine &#x4E0D;&#x662F;&#x4E00;&#x4E2A; &#x201C;&#x6B63;&#x5E38;&#x201D; &#x7684; goroutine&#xFF08;&#x4F8B;&#x5982; GC worker &#x6216; trace reader&#xFF09;&#xFF0C;&#x8C03;&#x5EA6;&#x5668;&#x9700;&#x8981;&#x5524;&#x9192;&#x4E00;&#x4E2A; P &#x6765;&#x5904;&#x7406;&#x8FD9;&#x4E9B;&#x7279;&#x6B8A;&#x4EFB;&#x52A1;&#x3002;</span>
    <span class="hljs-keyword">if</span> tryWakeP {
        wakep()
    }
    <span class="hljs-comment">// &#x68C0;&#x67E5; goroutine &#x662F;&#x5426;&#x9501;&#x5B9A;&#x5728;&#x67D0;&#x4E2A;&#x7EBF;&#x7A0B;</span>
    <span class="hljs-keyword">if</span> gp.lockedm != <span class="hljs-number">0</span> {
        <span class="hljs-comment">// Hands off own p to the locked m,</span>
        <span class="hljs-comment">// then blocks waiting for a new p.</span>
        <span class="hljs-comment">// &#x5982;&#x679C; goroutine &#x9501;&#x5B9A;&#x4E86;&#x67D0;&#x4E2A;&#x7279;&#x5B9A;&#x7684; M&#xFF0C;&#x8C03;&#x5EA6;&#x5668;&#x9700;&#x8981;&#x5C06;&#x5F53;&#x524D;&#x7684; P &#x4EA4;&#x7ED9;&#x8BE5; M &#x5E76;&#x7B49;&#x5F85;&#x65B0;&#x7684; P&#x3002;</span>
        startlockedm(gp)
        <span class="hljs-keyword">goto</span> top
    }

    <span class="hljs-comment">// &#x6267;&#x884C; Goroutine</span>
    execute(gp, inheritTime)
}
</code></pre>
<p>&#x5F53;&#x5F00;&#x59CB;&#x6267;&#x884C; <code>execute</code> &#x540E;&#xFF0C;g &#x4F1A;&#x88AB;&#x5207;&#x6362;&#x5230; <code>_Grunning</code> &#x72B6;&#x6001;&#x3002; &#x8BBE;&#x7F6E;&#x81EA;&#x8EAB;&#x7684;&#x62A2;&#x5360;&#x4FE1;&#x53F7;&#xFF0C;&#x5C06; m &#x548C; g &#x8FDB;&#x884C;&#x7ED1;&#x5B9A;&#x3002; &#x6700;&#x7EC8;&#x8C03;&#x7528; <code>gogo</code> &#x5F00;&#x59CB;&#x6267;&#x884C;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Schedules gp to run on the current M.</span>
<span class="hljs-comment">// If inheritTime is true, gp inherits the remaining time in the</span>
<span class="hljs-comment">// current time slice. Otherwise, it starts a new time slice.</span>
<span class="hljs-comment">// Never returns.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Write barriers are allowed because this is called immediately after</span>
<span class="hljs-comment">// acquiring a P in several places.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:yeswritebarrierrec</span>
<span class="hljs-comment">// &#x5728;&#x5F53;&#x524D; M &#x4E0A;&#x8C03;&#x5EA6; gp&#x3002;</span>
<span class="hljs-comment">// &#x5982;&#x679C; inheritTime &#x4E3A; true&#xFF0C;&#x5219; gp &#x7EE7;&#x627F;&#x5269;&#x4F59;&#x7684;&#x65F6;&#x95F4;&#x7247;&#x3002;&#x5426;&#x5219;&#x4ECE;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x65F6;&#x95F4;&#x7247;&#x5F00;&#x59CB;</span>
<span class="hljs-comment">// &#x6C38;&#x4E0D;&#x8FD4;&#x56DE;&#x3002;</span>
<span class="hljs-keyword">func</span> execute(gp *g, inheritTime <span class="hljs-keyword">bool</span>) {
    mp := getg().m

    <span class="hljs-keyword">if</span> goroutineProfile.active {
        <span class="hljs-comment">// Make sure that gp has had its stack written out to the goroutine</span>
        <span class="hljs-comment">// profile, exactly as it was when the goroutine profiler first stopped</span>
        <span class="hljs-comment">// the world.</span>
        tryRecordGoroutineProfile(gp, osyield)
    }

    <span class="hljs-comment">// Assign gp.m before entering _Grunning so running Gs have an</span>
    <span class="hljs-comment">// M.</span>
    <span class="hljs-comment">// // &#x5C06; g &#x6B63;&#x5F0F;&#x5207;&#x6362;&#x4E3A; _Grunning &#x72B6;&#x6001;</span>
    mp.curg = gp
    gp.m = mp
    casgstatus(gp, _Grunnable, _Grunning)
    gp.waitsince = <span class="hljs-number">0</span>
    <span class="hljs-comment">// &#x62A2;&#x5360;&#x4FE1;&#x53F7;</span>
    gp.preempt = <span class="hljs-literal">false</span>
    gp.stackguard0 = gp.stack.lo + _StackGuard
    <span class="hljs-keyword">if</span> !inheritTime {
        mp.p.ptr().schedtick++
    }

    <span class="hljs-comment">// Check whether the profiler needs to be turned on or off.</span>
    hz := sched.profilehz
    <span class="hljs-keyword">if</span> mp.profilehz != hz {
        setThreadCPUProfiler(hz)
    }

    <span class="hljs-keyword">if</span> trace.enabled {
        <span class="hljs-comment">// GoSysExit has to happen when we have a P, but before GoStart.</span>
        <span class="hljs-comment">// So we emit it here.</span>
        <span class="hljs-keyword">if</span> gp.syscallsp != <span class="hljs-number">0</span> &amp;&amp; gp.sysblocktraced {
            traceGoSysExit(gp.sysexitticks)
        }
        traceGoStart()
    }

    <span class="hljs-comment">// &#x5F00;&#x59CB;&#x6267;&#x884C;</span>
    gogo(&amp;gp.sched)
}
</code></pre>
<p><code>gogo</code>&#x51FD;&#x6570;&#x7531;&#x6C47;&#x7F16;&#x4EE3;&#x7801;&#x5B9E;&#x73B0;</p>
<pre><code>// func gogo(buf *gobuf)
// restore state from Gobuf; longjmp
// gobuf&#x4FDD;&#x5B58;&#x4E86;&#x534F;&#x7A0B;&#x7684;&#x4E0A;&#x4E0B;&#x6587;&#x4FE1;&#x606F;
TEXT runtime&#xB7;gogo(SB), NOSPLIT, $0-8
    MOVQ    buf+0(FP), BX        // gobuf
    MOVQ    gobuf_g(BX), DX
    MOVQ    0(DX), CX        // make sure g != nil
    JMP    gogo&lt;&gt;(SB)

TEXT gogo&lt;&gt;(SB), NOSPLIT, $0
    // &#x4ECE;&#x7EBF;&#x7A0B;&#x672C;&#x5730;&#x5B58;&#x50A8; (TLS) &#x83B7;&#x53D6;&#x6307;&#x5411;&#x5F53;&#x524D; goroutine g &#x7ED3;&#x6784;&#x7684;&#x6307;&#x9488;&#x3002;
    get_tls(CX)
    // &#x8BBE;&#x7F6E;g&#x7684;&#x5BC4;&#x5B58;&#x5668;
    MOVQ    DX, g(CX)
    MOVQ    DX, R14        // set the g register
    // &#x6062;&#x590D;&#x534F;&#x7A0B;&#x7684;&#x4E0A;&#x4E0B;&#x6587;
    MOVQ    gobuf_sp(BX), SP    // restore SP
    MOVQ    gobuf_ret(BX), AX
    MOVQ    gobuf_ctxt(BX), DX
    MOVQ    gobuf_bp(BX), BP
    // &#x6E05;&#x7406;gobuf&#x4E2D;&#x7684;&#x503C;
    MOVQ    $0, gobuf_sp(BX)    // clear to help garbage collector
    MOVQ    $0, gobuf_ret(BX)
    MOVQ    $0, gobuf_ctxt(BX)
    MOVQ    $0, gobuf_bp(BX)
    // &#x83B7;&#x53D6; g &#x8981;&#x6267;&#x884C;&#x7684;&#x51FD;&#x6570;&#x7684;&#x5165;&#x53E3;&#x5730;&#x5740;
    MOVQ    gobuf_pc(BX), BX
    // &#x6267;&#x884C;&#x51FD;&#x6570;
    JMP    BX
</code></pre><p>&#x914D;&#x5408;<code>newproc</code>&#x5B9E;&#x73B0;&#x771F;&#x6B63;&#x7684;&#x8C03;&#x5EA6;&#x5FAA;&#x73AF;</p>
<pre><code class="lang-go"><span class="hljs-keyword">func</span> newproc1(fn *funcval, callergp *g, callerpc <span class="hljs-keyword">uintptr</span>) *g {
  ...
    <span class="hljs-comment">// &#x6E05;&#x7406;&#x521B;&#x5EFA;&#x5E76;&#x521D;&#x59CB;&#x5316;g&#x7684;&#x8FD0;&#x884C;&#x73B0;&#x573A;</span>
    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))
    newg.sched.sp = sp
    newg.stktopsp = sp
    newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum <span class="hljs-comment">// +PCQuantum so that previous instruction is in same function</span>
    newg.sched.g = guintptr(unsafe.Pointer(newg))
    <span class="hljs-comment">// &#x4E3A;&#x4E4B;&#x540E;&#x7684;&#x534F;&#x7A0B;&#x8C03;&#x5EA6;&#x57CB;&#x4E0B;&#x4F0F;&#x7B14;&#xFF0C;&#x6267;&#x884C;&#x5B8C;&#x8BE5;&#x51FD;&#x6570;&#xFF0C;&#x4F1A;&#x5728;&#x6808;&#x4E2D;&#x4FDD;&#x5B58;goexit&#x51FD;&#x6570;&#x7684;&#x5730;&#x5740;&#x3002;</span>
    <span class="hljs-comment">// &#x534F;&#x7A0B;&#x6267;&#x884C;&#x5B8C;&#x6210;&#x8FD4;&#x56DE;&#x540E;&#xFF0C;&#x4F1A;&#x5728;&#x6808;&#x9876;&#x5F39;&#x51FA;&#x8FD4;&#x56DE;&#x5730;&#x5740;&#x5E76;&#x52A0;&#x8F7D;&#x5230;&#x7A0B;&#x5E8F;&#x8BA1;&#x6570;&#x5668;PC&#x4E2D;&#xFF0C;&#x5E76;&#x6267;&#x884C;goexit</span>
    gostartcallfn(&amp;newg.sched, fn)
  ...
}

<span class="hljs-comment">// adjust Gobuf as if it executed a call to fn</span>
<span class="hljs-comment">// and then stopped before the first instruction in fn.</span>
<span class="hljs-keyword">func</span> gostartcallfn(gobuf *gobuf, fv *funcval) {
    <span class="hljs-keyword">var</span> fn unsafe.Pointer
    <span class="hljs-keyword">if</span> fv != <span class="hljs-literal">nil</span> {
        fn = unsafe.Pointer(fv.fn)
    } <span class="hljs-keyword">else</span> {
        fn = unsafe.Pointer(abi.FuncPCABIInternal(nilfunc))
    }
    gostartcall(gobuf, fn, unsafe.Pointer(fv))
}

<span class="hljs-comment">// adjust Gobuf as if it executed a call to fn with context ctxt</span>
<span class="hljs-comment">// and then stopped before the first instruction in fn.</span>
<span class="hljs-keyword">func</span> gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) {
    <span class="hljs-comment">// &#x6808;&#x6307;&#x9488;&#x8C03;&#x6574;</span>
    sp := buf.sp
    <span class="hljs-comment">// &#x51C6;&#x5907;&#x51FD;&#x6570;&#x7684;&#x8FD4;&#x56DE;&#x5730;&#x5740;&#x5E76;&#x628A;&#x5B83;&#x653E;&#x5728;&#x6808;&#x4E0A;</span>
    sp -= goarch.PtrSize
    <span class="hljs-comment">// &#x5C06;&#x8C03;&#x7528;&#x8005;&#x7684; pc &#x4FDD;&#x5B58;&#x5230;&#x6808;&#x4E2D;&#xFF0C;&#x8FD9;&#x6837;&#x5F53;&#x65B0;&#x51FD;&#x6570;&#x6267;&#x884C;&#x5B8C;&#x6BD5;&#x65F6;&#xFF0C;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x8FD9;&#x4E2A;&#x8FD4;&#x56DE;&#x5730;&#x5740;&#x6062;&#x590D;&#x6267;&#x884C;&#x539F;&#x6765;&#x7684;&#x51FD;&#x6570;&#x3002;</span>
    *(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(sp)) = buf.pc
    <span class="hljs-comment">// &#x8C03;&#x6574; Gobuf &#x7684;&#x6808;&#x6307;&#x9488;&#x548C;&#x7A0B;&#x5E8F;&#x8BA1;&#x6570;&#x5668;&#x4EE5;&#x6307;&#x5411;&#x51FD;&#x6570;fn</span>
    <span class="hljs-comment">// &#x51C6;&#x5907;&#x597D;&#x51FD;&#x6570;&#x6267;&#x884C;&#x65F6;&#x7684;&#x6808;&#x5E27;</span>
    buf.sp = sp
    <span class="hljs-comment">// &#x5C06; Goroutine &#x7684; pc &#x8BBE;&#x7F6E;&#x4E3A;&#x5C06;&#x8981;&#x6267;&#x884C;&#x7684;&#x51FD;&#x6570;&#x7684;&#x5165;&#x53E3;&#x5730;&#x5740;&#x3002;&#x8FD9;&#x6837;&#xFF0C;&#x5F53; Goroutine &#x88AB;&#x8C03;&#x5EA6;&#x8FD0;&#x884C;&#x65F6;&#xFF0C;&#x5B83;&#x4F1A;&#x4ECE;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x7684;&#x5165;&#x53E3;&#x5730;&#x5740;&#x5F00;&#x59CB;&#x6267;&#x884C;&#x3002;</span>
    buf.pc = <span class="hljs-keyword">uintptr</span>(fn)
    <span class="hljs-comment">// &#x4FDD;&#x5B58;&#x4E86;funcval&#xFF0C;&#x5373;&#x51FD;&#x6570;&#x53CA;&#x5176;&#x53C2;&#x6570;&#x7684;&#x5F15;&#x7528;</span>
    buf.ctxt = ctxt
}
</code></pre>
<p>&#x5728;&#x6267;&#x884C;&#x73B0;&#x573A; <code>sched.sp</code> &#x4FDD;&#x5B58;&#x7684;&#x5176;&#x5B9E;&#x662F; <code>goexit</code> &#x7684;&#x5730;&#x5740;&#x3002; &#x90A3;&#x4E48;&#x4E5F;&#x5C31;&#x662F; <code>JMP</code> &#x8DF3;&#x8F6C;&#x5230; PC &#x5BC4;&#x5B58;&#x5668;&#x5904;&#xFF0C;&#x5F00;&#x59CB;&#x6267;&#x884C; <code>fn</code>&#x3002;&#x5F53; <code>fn</code> &#x6267;&#x884C;&#x5B8C;&#x6BD5;&#x540E;&#xFF0C;&#x4F1A;&#x5C06;&#xFF08;&#x5047;&#x60F3;&#x7684;&#xFF09; &#x8C03;&#x7528;&#x65B9; <code>goexit</code> &#x7684;&#x5730;&#x5740;&#x6062;&#x590D;&#x5230; PC&#xFF0C;&#x4ECE;&#x800C;&#x8FBE;&#x5230;&#x6267;&#x884C; <code>goexit</code> &#x7684;&#x76EE;&#x7684;&#x3002;</p>
<p><code>goexit</code>&#x5E76;&#x975E;&#x88AB;&#x663E;&#x5F0F;&#x8C03;&#x7528;&#xFF0C;&#x800C;&#x662F;&#x88AB;&#x4F2A;&#x88C5;&#x6210;&#x51FD;&#x6570;&#x7684;&#x8C03;&#x7528;&#x65B9;&#xFF0C;&#x5728;&#x51FD;&#x6570;&#x6267;&#x884C;&#x5B8C;&#x6210;&#x8FD4;&#x56DE;&#x65F6;&#xFF0C;&#x4ECE;&#x51FD;&#x6570;&#x7684;&#x6808;&#x9876;&#x53D6;&#x51FA;&#x8FDB;&#x884C;&#x8C03;&#x7528;&#xFF0C;&#x5FAA;&#x73AF;&#x5F80;&#x590D;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// The top-most function running on a goroutine</span>
<span class="hljs-comment">// returns to goexit+PCQuantum.</span>
TEXT runtime&#xB7;goexit(SB),NOSPLIT|TOPFRAME,$<span class="hljs-number">0</span><span class="hljs-number">-0</span>
    BYTE    $<span class="hljs-number">0x90</span>    <span class="hljs-comment">// NOP</span>
    CALL    runtime&#xB7;goexit1(SB)    <span class="hljs-comment">// does not return</span>
    <span class="hljs-comment">// traceback from goexit1 must hit code range of goexit</span>
    BYTE    $<span class="hljs-number">0x90</span>    <span class="hljs-comment">// NOP</span>
</code></pre>
<p>&#x6267;&#x884C;<code>goexit1</code></p>
<pre><code class="lang-go"><span class="hljs-comment">// Finishes execution of the current goroutine.</span>
<span class="hljs-keyword">func</span> goexit1() {
    <span class="hljs-keyword">if</span> raceenabled {
        racegoend()
    }
    <span class="hljs-keyword">if</span> trace.enabled {
        traceGoEnd()
    }
    mcall(goexit0)
}
</code></pre>
<p>&#x901A;&#x8FC7;<code>mcall</code>&#x8C03;&#x7528;<code>goexit0</code>&#x7684;&#x8C03;&#x7528;</p>
<pre><code>// func mcall(fn func(*g))
// Switch to m-&gt;g0&apos;s stack, call fn(g).
// Fn must never return. It should gogo(&amp;g-&gt;sched)
// to keep running g.
// &#x7528;&#x4E8E;&#x5C06;&#x5F53;&#x524D;&#x7684; Goroutine&#xFF08;g&#xFF09;&#x5207;&#x6362;&#x5230;&#x4E0E;&#x5176;&#x5173;&#x8054;&#x7684;&#x7CFB;&#x7EDF;&#x6808;&#xFF08;&#x5373; g0 &#x7684;&#x6808;&#xFF09;&#xFF0C;&#x5E76;&#x8C03;&#x7528;&#x4E00;&#x4E2A;&#x4E0D;&#x4F1A;&#x8FD4;&#x56DE;&#x7684;&#x51FD;&#x6570; fn
TEXT runtime&#xB7;mcall&lt;ABIInternal&gt;(SB), NOSPLIT, $0-8
    MOVQ   AX, DX // DX = fn

    // save state in g-&gt;sched
    // &#x4FDD;&#x5B58;&#x5F53;&#x524D; Goroutine &#x7684;&#x6267;&#x884C;&#x72B6;&#x6001;&#x5230; g-&gt;sched
    MOVQ   0(SP), BX  // caller&apos;s PC
    MOVQ   BX, (g_sched+gobuf_pc)(R14)
    LEAQ   fn+0(FP), BX   // caller&apos;s SP
    MOVQ   BX, (g_sched+gobuf_sp)(R14)
    MOVQ   BP, (g_sched+gobuf_bp)(R14)

    // switch to m-&gt;g0 &amp; its stack, call fn
    // &#x5207;&#x6362;&#x5230; g0
    MOVQ   g_m(R14), BX
    MOVQ   m_g0(BX), SI   // SI = g.m.g0
    CMPQ   SI, R14    // if g == m-&gt;g0 call badmcall
    JNE    goodm
    JMP    runtime&#xB7;badmcall(SB)
goodm:
    // &#x5207;&#x6362; Goroutine &#x5230; g0&#xFF0C;&#x5E76;&#x51C6;&#x5907;&#x8C03;&#x7528; fn
    MOVQ   R14, AX       // AX (and arg 0) = g
    MOVQ   SI, R14       // g = g.m.g0
    get_tls(CX)       // Set G in TLS
    MOVQ   R14, g(CX)
    MOVQ   (g_sched+gobuf_sp)(R14), SP    // sp = g0.sched.sp
    PUSHQ  AX // open up space for fn&apos;s arg spill slot
    MOVQ   0(DX), R12
    CALL   R12       // fn(g)
    // &#x6E05;&#x7406;&#x5E76;&#x5904;&#x7406;&#x9519;&#x8BEF;
    POPQ   AX
    JMP    runtime&#xB7;badmcall2(SB)
    RET
</code></pre><p>&#x9000;&#x51FA;&#x7684;&#x5584;&#x540E;&#x5DE5;&#x4F5C;&#x4E3B;&#x8981;&#x662F;&#x590D;&#x4F4D;g&#x7684;&#x72B6;&#x6001;&#x3001;&#x89E3;&#x7ED1;m&#x548C;g&#xFF0C;&#x5C06;&#x5176;&#x653E;&#x5165;&#x7A7A;&#x95F2;&#x94FE;&#x8868;&#x4E2D;&#x7B49;&#x5F85;&#x5176;&#x4ED6;&#x7684;go&#x8BED;&#x53E5;&#x521B;&#x5EFA;&#x65B0;&#x7684;g&#x3002;</p>
<p>&#x5982;&#x679C; Goroutine &#x5C06;&#x81EA;&#x8EAB;&#x9501;&#x5728;&#x540C;&#x4E00;&#x4E2A; OS &#x7EBF;&#x7A0B;&#x4E2D;&#x4E14;&#x6CA1;&#x6709;&#x81EA;&#x884C;&#x89E3;&#x7ED1;&#x5219; m &#x4F1A;&#x9000;&#x51FA;&#xFF0C;&#x800C;&#x4E0D;&#x4F1A;&#x88AB;&#x653E;&#x56DE;&#x5230;&#x7EBF;&#x7A0B;&#x6C60;&#x4E2D;&#x3002; &#x76F8;&#x53CD;&#xFF0C;&#x4F1A;&#x518D;&#x6B21;&#x8C03;&#x7528; gogo &#x5207;&#x6362;&#x5230; g0 &#x6267;&#x884C;&#x73B0;&#x573A;&#x4E2D;&#xFF0C;&#x8FD9;&#x4E5F;&#x662F;&#x76EE;&#x524D;&#x552F;&#x4E00;&#x7684;&#x9000;&#x51FA; m &#x7684;&#x673A;&#x4F1A;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// goexit continuation on g0.</span>
<span class="hljs-comment">// g0&#x4E0A;&#x6267;&#x884C;goexit</span>
<span class="hljs-keyword">func</span> goexit0(gp *g) {
    mp := getg().m
    pp := mp.p.ptr()

    <span class="hljs-comment">// &#x5207;&#x6362;&#x5F53;&#x524D;&#x7684; g &#x4E3A; _Gdead</span>
    casgstatus(gp, _Grunning, _Gdead)
    gcController.addScannableStack(pp, -<span class="hljs-keyword">int64</span>(gp.stack.hi-gp.stack.lo))
    <span class="hljs-keyword">if</span> isSystemGoroutine(gp, <span class="hljs-literal">false</span>) {
        sched.ngsys.Add(<span class="hljs-number">-1</span>)
    }
    <span class="hljs-comment">// &#x6E05;&#x7406;</span>
    gp.m = <span class="hljs-literal">nil</span>
    locked := gp.lockedm != <span class="hljs-number">0</span>
    gp.lockedm = <span class="hljs-number">0</span>
    mp.lockedg = <span class="hljs-number">0</span>
    gp.preemptStop = <span class="hljs-literal">false</span>
    gp.paniconfault = <span class="hljs-literal">false</span>
    gp._defer = <span class="hljs-literal">nil</span> <span class="hljs-comment">// should be true already but just in case.</span>
    gp._panic = <span class="hljs-literal">nil</span> <span class="hljs-comment">// non-nil for Goexit during panic. points at stack-allocated data.</span>
    gp.writebuf = <span class="hljs-literal">nil</span>
    gp.waitreason = waitReasonZero
    gp.param = <span class="hljs-literal">nil</span>
    gp.labels = <span class="hljs-literal">nil</span>
    gp.timer = <span class="hljs-literal">nil</span>

    <span class="hljs-keyword">if</span> gcBlackenEnabled != <span class="hljs-number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="hljs-number">0</span> {
        <span class="hljs-comment">// Flush assist credit to the global pool. This gives</span>
        <span class="hljs-comment">// better information to pacing if the application is</span>
        <span class="hljs-comment">// rapidly creating an exiting goroutines.</span>
        assistWorkPerByte := gcController.assistWorkPerByte.Load()
        scanCredit := <span class="hljs-keyword">int64</span>(assistWorkPerByte * <span class="hljs-keyword">float64</span>(gp.gcAssistBytes))
        gcController.bgScanCredit.Add(scanCredit)
        gp.gcAssistBytes = <span class="hljs-number">0</span>
    }

    <span class="hljs-comment">// &#x89E3;&#x7ED1;g&#x548C;m</span>
    dropg()

    <span class="hljs-comment">// wasm &#x76EE;&#x524D;&#x8FD8;&#x6CA1;&#x6709;&#x7EBF;&#x7A0B;&#x652F;&#x6301;</span>
    <span class="hljs-keyword">if</span> GOARCH == <span class="hljs-string">&quot;wasm&quot;</span> { <span class="hljs-comment">// no threads yet on wasm</span>
        <span class="hljs-comment">// &#x5C06; g &#x6254;&#x8FDB; gfree &#x94FE;&#x8868;&#x4E2D;&#x7B49;&#x5F85;&#x590D;&#x7528;</span>
        gfput(pp, gp)
        <span class="hljs-comment">// &#x518D;&#x6B21;&#x8FDB;&#x884C;&#x8C03;&#x5EA6;</span>
        schedule() <span class="hljs-comment">// never returns</span>
    }

    <span class="hljs-keyword">if</span> mp.lockedInt != <span class="hljs-number">0</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;invalid m-&gt;lockedInt = &quot;</span>, mp.lockedInt, <span class="hljs-string">&quot;\n&quot;</span>)
        throw(<span class="hljs-string">&quot;internal lockOSThread error&quot;</span>)
    }

    <span class="hljs-comment">// &#x5C06; g &#x6254;&#x8FDB; gfree &#x94FE;&#x8868;&#x4E2D;&#x7B49;&#x5F85;&#x590D;&#x7528;</span>
    gfput(pp, gp)
    <span class="hljs-keyword">if</span> locked {
        <span class="hljs-comment">// The goroutine may have locked this thread because</span>
        <span class="hljs-comment">// it put it in an unusual kernel state. Kill it</span>
        <span class="hljs-comment">// rather than returning it to the thread pool.</span>
        <span class="hljs-comment">// &#x8BE5; Goroutine &#x53EF;&#x80FD;&#x5728;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E0A;&#x9501;&#x4F4F;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x53EF;&#x80FD;&#x5BFC;&#x81F4;&#x4E86;&#x4E0D;&#x6B63;&#x5E38;&#x7684;&#x5185;&#x6838;&#x72B6;&#x6001;</span>
        <span class="hljs-comment">// &#x8FD9;&#x65F6;&#x5019; kill &#x8BE5;&#x7EBF;&#x7A0B;&#xFF0C;&#x800C;&#x975E;&#x5C06; m &#x653E;&#x56DE;&#x5230;&#x7EBF;&#x7A0B;&#x6C60;&#x3002;</span>

        <span class="hljs-comment">// Return to mstart, which will release the P and exit</span>
        <span class="hljs-comment">// the thread.</span>
        <span class="hljs-comment">// &#x6B64;&#x4E3E;&#x4F1A;&#x8FD4;&#x56DE;&#x5230; mstart&#xFF0C;&#x4ECE;&#x800C;&#x91CA;&#x653E;&#x5F53;&#x524D;&#x7684; P &#x5E76;&#x9000;&#x51FA;&#x8BE5;&#x7EBF;&#x7A0B;</span>
        <span class="hljs-keyword">if</span> GOOS != <span class="hljs-string">&quot;plan9&quot;</span> { <span class="hljs-comment">// See golang.org/issue/22227.</span>
            gogo(&amp;mp.g0.sched)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Clear lockedExt on plan9 since we may end up re-using</span>
            <span class="hljs-comment">// this thread.</span>
            <span class="hljs-comment">// // &#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x5DF2;&#x91CD;&#x7528;&#x6B64;&#x7EBF;&#x7A0B;&#x7ED3;&#x675F;&#xFF0C;&#x5728; plan9 &#x4E0A;&#x6E05;&#x9664; lockedExt</span>
            mp.lockedExt = <span class="hljs-number">0</span>
        }
    }
    <span class="hljs-comment">// &#x518D;&#x6B21;&#x8FDB;&#x884C;&#x8C03;&#x5EA6;</span>
    schedule()
}
</code></pre>
<h4 id="2&#x3001;&#x5077;&#x53D6;&#x5DE5;&#x4F5C;">2&#x3001;&#x5077;&#x53D6;&#x5DE5;&#x4F5C;</h4>
<p>&#x4ECE;&#x5168;&#x5C40;&#x7684;&#x53EF;&#x8FD0;&#x884C;&#x7684;&#x534F;&#x7A0B;&#x961F;&#x5217;&#x4E2D;&#x83B7;&#x53D6;&#x4E00;&#x6279;&#x534F;&#x7A0B;&#xFF0C;&#x5C06;&#x4E00;&#x90E8;&#x5206;&#x534F;&#x7A0B;&#x653E;&#x5165;&#x5F53;&#x524D;P&#x7684;&#x672C;&#x5730;&#x961F;&#x5217;&#xFF0C;&#x4F9B;&#x672C;&#x5730;&#x8C03;&#x5EA6;&#x4F7F;&#x7528;&#x3002;</p>
<p>&#x901A;&#x8FC7;&#x6309;&#x6BD4;&#x4F8B;&#x83B7;&#x53D6;&#x534F;&#x7A0B;&#xFF0C;&#x907F;&#x514D;&#x67D0;&#x4E2A;P&#x957F;&#x65F6;&#x95F4;&#x5904;&#x4E8E;&#x7A7A;&#x95F2;&#x72B6;&#x6001;&#xFF0C;&#x540C;&#x65F6;&#x907F;&#x514D;&#x672C;&#x5730;&#x961F;&#x5217;&#x79EF;&#x538B;&#x8FC7;&#x591A;&#x7684;&#x534F;&#x7A0B;&#xFF0C;&#x5F71;&#x54CD;&#x5168;&#x5C40;&#x8C03;&#x5EA6;&#x7684;&#x516C;&#x5E73;&#x6027;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Try get a batch of G&apos;s from the global runnable queue.</span>
<span class="hljs-comment">// sched.lock must be held.</span>
<span class="hljs-comment">// &#x5728; P&#xFF08;&#x5904;&#x7406;&#x5668;&#xFF09;&#x7684;&#x672C;&#x5730;&#x961F;&#x5217;&#x4E2D;&#x653E;&#x5165;&#x4E00;&#x4E9B; Goroutine &#x5E76;&#x8FD4;&#x56DE;&#x5176;&#x4E2D;&#x4E00;&#x4E2A;&#x53EF;&#x8FD0;&#x884C;&#x7684; Goroutine</span>
<span class="hljs-keyword">func</span> globrunqget(pp *p, max <span class="hljs-keyword">int32</span>) *g {
    <span class="hljs-comment">// &#x5168;&#x5C40;&#x53EF;&#x8FD0;&#x884C;&#x961F;&#x5217;&#x7684;&#x64CD;&#x4F5C;&#x9700;&#x8981;&#x52A0;&#x9501;&#x4EE5;&#x786E;&#x4FDD;&#x7EBF;&#x7A0B;&#x5B89;&#x5168;&#x3002;</span>
    assertLockHeld(&amp;sched.lock)

    <span class="hljs-comment">// &#x5168;&#x5C40;&#x961F;&#x5217;&#x4E2D;&#x6CA1;&#x6709;g&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;</span>
    <span class="hljs-keyword">if</span> sched.runqsize == <span class="hljs-number">0</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }

    <span class="hljs-comment">// &#x8BA1;&#x7B97;&#x8981;&#x83B7;&#x53D6;&#x7684;&#x534F;&#x7A0B;&#x6570;&#x91CF;</span>
    <span class="hljs-comment">// &#x6839;&#x636E;&#x5168;&#x5C40;&#x961F;&#x5217;&#x5927;&#x5C0F;&#x548C; GOMAXPROCS &#x7684;&#x503C;&#x4F30;&#x7B97;&#x8981;&#x83B7;&#x53D6;&#x7684; Goroutine &#x6570;&#x91CF;&#xFF0C;</span>
    <span class="hljs-comment">// &#x4FDD;&#x8BC1;&#x6BCF;&#x4E2A;&#x5904;&#x7406;&#x5668; (P) &#x80FD;&#x591F;&#x83B7;&#x53D6;&#x5230;&#x5408;&#x7406;&#x6570;&#x91CF;&#x7684; Goroutine&#x3002;</span>
    n := sched.runqsize/gomaxprocs + <span class="hljs-number">1</span>
    <span class="hljs-comment">// &#x6BD4;&#x8F83; n &#x548C;&#x5168;&#x5C40;&#x961F;&#x5217;&#x7684;&#x5927;&#x5C0F;&#xFF0C;&#x786E;&#x4FDD;&#x4E0D;&#x4F1A;&#x8D85;&#x8FC7;&#x5B9E;&#x9645;&#x7684; Goroutine &#x6570;&#x91CF;&#x3002;</span>
    <span class="hljs-keyword">if</span> n &gt; sched.runqsize {
        n = sched.runqsize
    }
    <span class="hljs-comment">// &#x5982;&#x679C;&#x4F20;&#x5165;&#x7684; max &#x53C2;&#x6570;&#x9650;&#x5236;&#x4E86;&#x83B7;&#x53D6;&#x7684;&#x6570;&#x91CF;&#xFF0C;&#x5219;&#x6309; max &#x8FDB;&#x884C;&#x9650;&#x5236;&#x3002;</span>
    <span class="hljs-keyword">if</span> max &gt; <span class="hljs-number">0</span> &amp;&amp; n &gt; max {
        n = max
    }
    <span class="hljs-comment">// &#x5982;&#x679C;&#x8981;&#x83B7;&#x53D6;&#x7684;&#x6570;&#x91CF;&#x8D85;&#x8FC7;&#x4E86;&#x5F53;&#x524D; P &#x672C;&#x5730;&#x8FD0;&#x884C;&#x961F;&#x5217;&#x7684;&#x4E00;&#x534A;&#x957F;&#x5EA6;&#xFF0C;&#x5219;&#x4E5F;&#x8981;&#x8FDB;&#x884C;&#x9650;&#x5236;&#xFF0C;</span>
    <span class="hljs-comment">// &#x907F;&#x514D;&#x8FC7;&#x591A;&#x7684; Goroutine &#x5806;&#x79EF;&#x5728;&#x4E00;&#x4E2A; P &#x7684;&#x672C;&#x5730;&#x961F;&#x5217;&#x4E2D;&#x3002;</span>
    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-keyword">int32</span>(<span class="hljs-built_in">len</span>(pp.runq))/<span class="hljs-number">2</span> {
        n = <span class="hljs-keyword">int32</span>(<span class="hljs-built_in">len</span>(pp.runq)) / <span class="hljs-number">2</span>
    }

    <span class="hljs-comment">// &#x66F4;&#x65B0;&#x5168;&#x5C40;&#x961F;&#x5217;&#x7684;&#x5927;&#x5C0F;</span>
    sched.runqsize -= n

    <span class="hljs-comment">// &#x4ECE;&#x5168;&#x5C40;&#x961F;&#x5217;&#x4E2D;&#x53D6;&#x51FA; Goroutine</span>
    <span class="hljs-comment">// &#x5148;&#x4ECE;&#x5168;&#x5C40;&#x961F;&#x5217;&#x4E2D;&#x5F39;&#x51FA;&#x4E00;&#x4E2A; Goroutine&#xFF0C;&#x8D4B;&#x503C;&#x7ED9; gp&#xFF0C;&#x8FD9;&#x4E2A; Goroutine &#x5C06;&#x4F1A;&#x8FD4;&#x56DE;&#x4F5C;&#x4E3A;&#x7ED3;&#x679C;&#x3002;</span>
    gp := sched.runq.pop()
    n--
    <span class="hljs-comment">// &#x7136;&#x540E;&#x7EE7;&#x7EED;&#x4ECE;&#x5168;&#x5C40;&#x961F;&#x5217;&#x4E2D;&#x5F39;&#x51FA;&#x5269;&#x4F59;&#x7684; Goroutine&#xFF08;n-1 &#x4E2A;&#xFF09;&#xFF0C;&#x5C06;&#x5B83;&#x4EEC;&#x653E;&#x5165;&#x5F53;&#x524D; P &#x7684;&#x672C;&#x5730;&#x961F;&#x5217;&#x4E2D;&#x3002;</span>
    <span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- {
        gp1 := sched.runq.pop()
        runqput(pp, gp1, <span class="hljs-literal">false</span>)
    }
    <span class="hljs-keyword">return</span> gp
}
</code></pre>
<p>&#x4ECE;&#x672C;&#x5730;&#x961F;&#x5217;&#x4E2D;&#x53D6;&#xFF0C;&#x9996;&#x5148;&#x770B; next &#x662F;&#x5426;&#x6709;&#x5DF2;&#x7ECF;&#x5B89;&#x6392;&#x8981;&#x8FD0;&#x884C;&#x7684; g &#xFF0C;&#x5982;&#x679C;&#x6709;&#xFF0C;&#x5219;&#x8FD4;&#x56DE;&#x4E0B;&#x4E00;&#x4E2A;&#x8981;&#x8FD0;&#x884C;&#x7684; g &#x5426;&#x5219;&#xFF0C;&#x4EE5; cas &#x7684;&#x65B9;&#x5F0F;&#x4ECE;&#x672C;&#x5730;&#x961F;&#x5217;&#x4E2D;&#x53D6;&#x4E00;&#x4E2A; g&#x3002;</p>
<p>&#x5982;&#x679C;&#x662F;&#x5DF2;&#x7ECF;&#x5B89;&#x6392;&#x8981;&#x8FD0;&#x884C;&#x7684; g&#xFF0C;&#x5219;&#x7EE7;&#x627F;&#x5269;&#x4F59;&#x7684;&#x53EF;&#x8FD0;&#x884C;&#x65F6;&#x95F4;&#x7247;&#x8FDB;&#x884C;&#x8FD0;&#x884C;&#xFF1B; &#x5426;&#x5219;&#x4EE5;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x65F6;&#x95F4;&#x7247;&#x6765;&#x8FD0;&#x884C;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Get g from local runnable queue.</span>
<span class="hljs-comment">// If inheritTime is true, gp should inherit the remaining time in the</span>
<span class="hljs-comment">// current time slice. Otherwise, it should start a new time slice.</span>
<span class="hljs-comment">// Executed only by the owner P.</span>
<span class="hljs-comment">// &#x4ECE;&#x672C;&#x5730;&#x53EF;&#x8FD0;&#x884C;&#x961F;&#x5217;&#x4E2D;&#x83B7;&#x53D6; g</span>
<span class="hljs-comment">// &#x5982;&#x679C; inheritTime &#x4E3A; true&#xFF0C;&#x5219; g &#x7EE7;&#x627F;&#x5269;&#x4F59;&#x7684;&#x65F6;&#x95F4;&#x7247;</span>
<span class="hljs-comment">// &#x5426;&#x5219;&#x5F00;&#x59CB;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x65F6;&#x95F4;&#x7247;&#x3002;&#x5728;&#x6240;&#x6709;&#x8005; P &#x4E0A;&#x6267;&#x884C;</span>
<span class="hljs-keyword">func</span> runqget(pp *p) (gp *g, inheritTime <span class="hljs-keyword">bool</span>) {
    <span class="hljs-comment">// If there&apos;s a runnext, it&apos;s the next G to run.</span>
    <span class="hljs-comment">// runnext&#x662F;&#x88AB;&#x4F18;&#x5148;&#x8C03;&#x5EA6;&#x7684;&#x534F;&#x7A0B;</span>
    <span class="hljs-comment">// &#x68C0;&#x67E5;runnext&#x662F;&#x5426;&#x53EF;&#x7528;</span>
    next := pp.runnext
    <span class="hljs-comment">// If the runnext is non-0 and the CAS fails, it could only have been stolen by another P,</span>
    <span class="hljs-comment">// because other Ps can race to set runnext to 0, but only the current P can set it to non-0.</span>
    <span class="hljs-comment">// Hence, there&apos;s no need to retry this CAS if it fails.</span>
    <span class="hljs-keyword">if</span> next != <span class="hljs-number">0</span> &amp;&amp; pp.runnext.cas(next, <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// &#x53EF;&#x7528;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#xFF0C;&#x5E76;&#x7EE7;&#x627F;&#x5269;&#x4F59;&#x65F6;&#x95F4;&#x7247;</span>
        <span class="hljs-keyword">return</span> next.ptr(), <span class="hljs-literal">true</span>
    }

    <span class="hljs-comment">// &#x4ECE;&#x672C;&#x5730;&#x961F;&#x5217;&#x4E2D;&#x83B7;&#x53D6;</span>
    <span class="hljs-keyword">for</span> {
        h := atomic.LoadAcq(&amp;pp.runqhead) <span class="hljs-comment">// load-acquire, synchronize with other consumers</span>
        t := pp.runqtail
        <span class="hljs-comment">// &#x94FE;&#x8868;&#x4E3A;&#x7A7A;</span>
        <span class="hljs-keyword">if</span> t == h {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
        }
        <span class="hljs-comment">// &#x5982;&#x679C;&#x961F;&#x5217;&#x4E2D;&#x6709;&#x53EF;&#x7528; Goroutine&#xFF0C;&#x5219;&#x4ECE;&#x672C;&#x5730;&#x961F;&#x5217;&#x4E2D;&#x7684;&#x4F4D;&#x7F6E; h % uint32(len(pp.runq)) &#x83B7;&#x53D6; Goroutine&#x3002;</span>
        gp := pp.runq[h%<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()
        <span class="hljs-comment">// &#x539F;&#x5B50;&#x5730;&#x5C06; runqhead &#x52A0; 1&#xFF08;&#x6D88;&#x8D39;&#x4E00;&#x4E2A; Goroutine&#xFF09;&#x3002;&#x8BE5;&#x64CD;&#x4F5C;&#x6210;&#x529F;&#x540E;&#xFF0C;&#x8FD4;&#x56DE;&#x8BE5; Goroutine&#xFF0C;</span>
        <span class="hljs-comment">// &#x5E76;&#x4E14; inheritTime &#x4E3A; false&#xFF0C;&#x8868;&#x793A;&#x8FD9;&#x4E2A; Goroutine &#x4E0D;&#x7EE7;&#x627F;&#x65F6;&#x95F4;&#x7247;&#x3002;</span>
        <span class="hljs-keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+<span class="hljs-number">1</span>) { <span class="hljs-comment">// cas-release, commits consume</span>
            <span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>
        }
    }
}
</code></pre>
<p>Findrunnable&#xFF1A;&#x627E;&#x5230;&#x4E00;&#x4E2A;&#x53EF;&#x8FD0;&#x884C;&#x7684;&#x534F;&#x7A0B;&#xFF0C;&#x6574;&#x4F53;&#x7684;&#x6D41;&#x7A0B;&#x5982;&#x4E0B;&#xFF1A;</p>
<ul>
<li>&#x9996;&#x5148;&#x68C0;&#x67E5;&#x662F;&#x662F;&#x5426;&#x6B63;&#x5728;&#x8FDB;&#x884C; GC&#xFF0C;&#x5982;&#x679C;&#x662F;&#x5219;&#x6682;&#x6B62;&#x5F53;&#x524D;&#x7684; m &#x5E76;&#x963B;&#x585E;&#x4F11;&#x7720;&#xFF1B;</li>
<li>&#x5C1D;&#x8BD5;&#x4ECE;&#x672C;&#x5730;&#x961F;&#x5217;&#x4E2D;&#x53D6; g&#xFF0C;&#x5982;&#x679C;&#x53D6;&#x5230;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#xFF0C;&#x5426;&#x5219;&#x7EE7;&#x7EED;&#x4ECE;&#x5168;&#x5C40;&#x961F;&#x5217;&#x4E2D;&#x627E; g&#xFF0C;&#x5982;&#x679C;&#x627E;&#x5230;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#xFF1B;</li>
<li>&#x68C0;&#x67E5;&#x662F;&#x5426;&#x5B58;&#x5728; poll &#x7F51;&#x7EDC;&#x7684; g&#xFF0C;&#x5982;&#x679C;&#x6709;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#xFF1B;</li>
<li>&#x5982;&#x679C;&#x6B64;&#x65F6;&#x4ECD;&#x7136;&#x65E0;&#x6CD5;&#x627E;&#x5230; g&#xFF0C;&#x5219;&#x4ECE;&#x5176;&#x4ED6; P &#x7684;&#x672C;&#x5730;&#x961F;&#x5217;&#x4E2D;&#x5077;&#x53D6;&#xFF1B;</li>
<li>&#x4ECE;&#x5176;&#x4ED6; P &#x672C;&#x5730;&#x961F;&#x5217;&#x5077;&#x53D6;&#x7684;&#x5DE5;&#x4F5C;&#x4F1A;&#x6267;&#x884C;&#x56DB;&#x8F6E;&#xFF0C;&#x5728;&#x524D;&#x4E24;&#x8F6E;&#x4E2D;&#x53EA;&#x4F1A;&#x67E5;&#x627E; runnable &#x961F;&#x5217;&#xFF0C;&#x540E;&#x4E24;&#x8F6E;&#x5219;&#x4F1A;&#x4F18;&#x5148;&#x67E5;&#x627E; ready &#x961F;&#x5217;&#xFF0C;&#x5982;&#x679C;&#x627E;&#x5230;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#xFF1B;</li>
<li>&#x6240;&#x6709;&#x7684;&#x53EF;&#x80FD;&#x6027;&#x90FD;&#x5C1D;&#x8BD5;&#x8FC7;&#x4E86;&#xFF0C;&#x5728;&#x51C6;&#x5907;&#x6682;&#x6B62; m &#x4E4B;&#x524D;&#xFF0C;&#x8FD8;&#x8981;&#x8FDB;&#x884C;&#x989D;&#x5916;&#x7684;&#x68C0;&#x67E5;&#xFF1B;</li>
<li>&#x9996;&#x5148;&#x68C0;&#x67E5;&#x6B64;&#x65F6;&#x662F;&#x5426;&#x662F; GC mark &#x9636;&#x6BB5;&#xFF0C;&#x5982;&#x679C;&#x662F;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE; mark &#x9636;&#x6BB5;&#x7684; g&#xFF1B;</li>
<li>&#x5982;&#x679C;&#x4ECD;&#x7136;&#x6CA1;&#x6709;&#xFF0C;&#x5219;&#x5BF9;&#x5F53;&#x524D;&#x7684; p &#x8FDB;&#x884C;&#x5FEB;&#x7167;&#xFF0C;&#x51C6;&#x5907;&#x5BF9;&#x8C03;&#x5EA6;&#x5668;&#x8FDB;&#x884C;&#x52A0;&#x9501;&#xFF1B;</li>
<li>&#x5F53;&#x8C03;&#x5EA6;&#x5668;&#x88AB;&#x9501;&#x4F4F;&#x540E;&#xFF0C;&#x6211;&#x4EEC;&#x4ECD;&#x7136;&#x8FD8;&#x9700;&#x518D;&#x6B21;&#x68C0;&#x67E5;&#x8FD9;&#x6BB5;&#x65F6;&#x95F4;&#x91CC;&#x662F;&#x5426;&#x6709;&#x8FDB;&#x5165; GC&#xFF0C;&#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x8FDB;&#x5165;&#x4E86; GC&#xFF0C;&#x5219;&#x56DE;&#x5230;&#x7B2C;&#x4E00;&#x6B65;&#xFF0C;&#x963B;&#x585E; m &#x5E76;&#x4F11;&#x7720;&#xFF1B;</li>
<li>&#x5F53;&#x8C03;&#x5EA6;&#x5668;&#x88AB;&#x9501;&#x4F4F;&#x540E;&#xFF0C;&#x5982;&#x679C;&#x6211;&#x4EEC;&#x53C8;&#x5728;&#x5168;&#x5C40;&#x961F;&#x5217;&#x4E2D;&#x53D1;&#x73B0;&#x4E86; g&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#xFF1B;</li>
<li>&#x5F53;&#x8C03;&#x5EA6;&#x5668;&#x88AB;&#x9501;&#x4F4F;&#x540E;&#xFF0C;&#x6211;&#x4EEC;&#x5F7B;&#x5E95;&#x627E;&#x4E0D;&#x5230;&#x4EFB;&#x52A1;&#x4E86;&#xFF0C;&#x5219;&#x5F52;&#x8FD8;&#x91CA;&#x653E;&#x5F53;&#x524D;&#x7684; P&#xFF0C;&#x5C06;&#x5176;&#x653E;&#x5165; idle &#x94FE;&#x8868;&#x4E2D;&#xFF0C;&#x5E76;&#x89E3;&#x9501;&#x8C03;&#x5EA6;&#x5668;&#xFF1B;</li>
<li>&#x5F53; M/P &#x5DF2;&#x7ECF;&#x89E3;&#x7ED1;&#x540E;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x5C06; m &#x7684;&#x72B6;&#x6001;&#x5207;&#x6362;&#x51FA;&#x81EA;&#x65CB;&#x72B6;&#x6001;&#xFF0C;&#x5E76;&#x51CF;&#x5C11; nmspinning&#xFF1B;</li>
<li>&#x6B64;&#x65F6;&#x6211;&#x4EEC;&#x4ECD;&#x7136;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x68C0;&#x67E5;&#x6240;&#x6709;&#x7684;&#x961F;&#x5217;&#xFF1B;</li>
<li>&#x5982;&#x679C;&#x6B64;&#x65F6;&#x6211;&#x4EEC;&#x53D1;&#x73B0;&#x6709;&#x4E00;&#x4E2A; P &#x961F;&#x5217;&#x4E0D;&#x7A7A;&#xFF0C;&#x5219;&#x7ACB;&#x523B;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x4E00;&#x4E2A; P&#xFF0C;&#x5982;&#x679C;&#x83B7;&#x53D6;&#x5230;&#xFF0C;&#x5219;&#x56DE;&#x5230;&#x7B2C;&#x4E00;&#x6B65;&#xFF0C;&#x91CD;&#x65B0;&#x6267;&#x884C;&#x5077;&#x53D6;&#x5DE5;&#x4F5C;&#xFF0C;&#x5982;&#x679C;&#x53D6;&#x4E0D;&#x5230;&#xFF0C;&#x5219;&#x8BF4;&#x660E;&#x7CFB;&#x7EDF;&#x5DF2;&#x7ECF;&#x6EE1;&#x8F7D;&#xFF0C;&#x65E0;&#x9700;&#x7EE7;&#x7EED;&#x8FDB;&#x884C;&#x8C03;&#x5EA6;&#xFF1B;</li>
<li>&#x540C;&#x6837;&#xFF0C;&#x6211;&#x4EEC;&#x8FD8;&#x9700;&#x8981;&#x518D;&#x68C0;&#x67E5;&#x662F;&#x5426;&#x6709; GC mark &#x7684; g &#x51FA;&#x73B0;&#xFF0C;&#x5982;&#x679C;&#x6709;&#xFF0C;&#x83B7;&#x53D6; P &#x5E76;&#x56DE;&#x5230;&#x7B2C;&#x4E00;&#x6B65;&#xFF0C;&#x91CD;&#x65B0;&#x6267;&#x884C;&#x5077;&#x53D6;&#x5DE5;&#x4F5C;&#xFF1B;</li>
<li>&#x540C;&#x6837;&#xFF0C;&#x6211;&#x4EEC;&#x8FD8;&#x9700;&#x8981;&#x518D;&#x68C0;&#x67E5;&#x662F;&#x5426;&#x5B58;&#x5728; poll &#x7F51;&#x7EDC;&#x7684; g&#xFF0C;&#x5982;&#x679C;&#x6709;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#xFF1B;</li>
<li>&#x7EC8;&#x4E8E;&#xFF0C;&#x6211;&#x4EEC;&#x4EC0;&#x4E48;&#x4E5F;&#x6CA1;&#x627E;&#x5230;&#xFF0C;&#x6682;&#x6B62;&#x5F53;&#x524D;&#x7684; m &#x5E76;&#x963B;&#x585E;&#x4F11;&#x7720;&#x3002;</li>
</ul>
<pre><code class="lang-go"><span class="hljs-comment">// Finds a runnable goroutine to execute.</span>
<span class="hljs-comment">// Tries to steal from other P&apos;s, get g from local or global queue, poll network.</span>
<span class="hljs-comment">// tryWakeP indicates that the returned goroutine is not normal (GC worker, trace</span>
<span class="hljs-comment">// reader) so the caller should try to wake a P.</span>
<span class="hljs-comment">// &#x627E;&#x5230;&#x4E00;&#x4E2A;&#x53EF;&#x8FD0;&#x884C;&#x7684; goroutine &#x6765;&#x6267;&#x884C;&#x3002;</span>
<span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x4ECE;&#x5176;&#x4ED6; P &#x7A83;&#x53D6;&#xFF0C;&#x4ECE;&#x672C;&#x5730;&#x6216;&#x5168;&#x5C40;&#x961F;&#x5217;&#x83B7;&#x53D6; g&#xFF0C;&#x8F6E;&#x8BE2;&#x7F51;&#x7EDC;&#x3002;</span>
<span class="hljs-comment">// inheritTime &#x662F;&#x5426;&#x7EE7;&#x627F;&#x8C03;&#x5EA6;&#x65F6;&#x95F4;</span>
<span class="hljs-comment">// tryWakeP &#x8868;&#x793A;&#x8FD4;&#x56DE;&#x7684; goroutine &#x4E0D;&#x6B63;&#x5E38;&#xFF08;GC &#x5DE5;&#x4F5C;&#x7EBF;&#x7A0B;&#x3001;&#x8DDF;&#x8E2A;&#x8BFB;&#x53D6;&#x5668;&#xFF09;&#xFF0C;&#x56E0;&#x6B64;&#x8C03;&#x7528;&#x8005;&#x5E94;&#x5C1D;&#x8BD5;&#x5524;&#x9192; P&#x3002;</span>
<span class="hljs-keyword">func</span> findRunnable() (gp *g, inheritTime, tryWakeP <span class="hljs-keyword">bool</span>) {
    mp := getg().m

    <span class="hljs-comment">// The conditions here and in handoffp must agree: if</span>
    <span class="hljs-comment">// findrunnable would return a G to run, handoffp must start</span>
    <span class="hljs-comment">// an M.</span>

top:
    pp := mp.p.ptr()
    <span class="hljs-keyword">if</span> sched.gcwaiting.Load() {
        <span class="hljs-comment">// &#x5982;&#x679C;&#x5728; gc&#xFF0C;&#x5219;&#x6682;&#x6B62;&#x5F53;&#x524D; m&#xFF0C;&#x76F4;&#x5230;&#x590D;&#x59CB;&#x540E;&#x56DE;&#x5230; top</span>
        gcstopm()
        <span class="hljs-keyword">goto</span> top
    }
    <span class="hljs-comment">// &#x5982;&#x679C; P &#x9700;&#x8981;&#x8FDB;&#x5165; Safe Point&#xFF08;&#x5B89;&#x5168;&#x70B9;&#xFF0C;&#x901A;&#x5E38;&#x5728; GC &#x8FC7;&#x7A0B;&#x4E2D;&#xFF09;&#xFF0C;&#x5219;&#x8FD0;&#x884C;&#x76F8;&#x5173;&#x7684; Safe Point &#x51FD;&#x6570;&#x3002;</span>
    <span class="hljs-keyword">if</span> pp.runSafePointFn != <span class="hljs-number">0</span> {
        runSafePointFn()
    }

    <span class="hljs-comment">// now and pollUntil are saved for work stealing later,</span>
    <span class="hljs-comment">// which may steal timers. It&apos;s important that between now</span>
    <span class="hljs-comment">// and then, nothing blocks, so these numbers remain mostly</span>
    <span class="hljs-comment">// relevant.</span>
    <span class="hljs-comment">// &#x68C0;&#x67E5;&#x662F;&#x5426;&#x6709;&#x9700;&#x8981;&#x5904;&#x7406;&#x7684;&#x5B9A;&#x65F6;&#x5668;</span>
    <span class="hljs-comment">// &#x5B9A;&#x65F6;&#x5668;&#x673A;&#x5236;&#x53EF;&#x4EE5;&#x8BA9; goroutine &#x5728;&#x6307;&#x5B9A;&#x65F6;&#x95F4;&#x540E;&#x88AB;&#x5524;&#x9192;&#xFF0C;&#x5982;&#x679C;&#x6709;&#x5230;&#x671F;&#x7684;&#x5B9A;&#x65F6;&#x5668;&#x4EFB;&#x52A1;&#xFF0C;&#x8C03;&#x5EA6;&#x5668;&#x4F1A;&#x5904;&#x7406;&#x5B83;&#x4EEC;&#x3002;</span>
    now, pollUntil, _ := checkTimers(pp, <span class="hljs-number">0</span>)

    <span class="hljs-comment">// Try to schedule the trace reader.</span>
    <span class="hljs-keyword">if</span> trace.enabled || trace.shutdown {
        gp := traceReader()
        <span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> {
            casgstatus(gp, _Gwaiting, _Grunnable)
            traceGoUnpark(gp, <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>
        }
    }

    <span class="hljs-comment">// Try to schedule a GC worker.</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x5F53;&#x524D;&#x6B63;&#x5728;&#x6267;&#x884C; GC &#x5E76;&#x4E14;&#x6709; GC &#x5DE5;&#x4F5C; goroutine &#x9700;&#x8981;&#x6267;&#x884C;&#xFF0C;&#x5219;&#x8C03;&#x5EA6; GC worker&#x3002;</span>
    <span class="hljs-keyword">if</span> gcBlackenEnabled != <span class="hljs-number">0</span> {
        gp, tnow := gcController.findRunnableGCWorker(pp, now)
        <span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>
        }
        now = tnow
    }

    <span class="hljs-comment">// Check the global runnable queue once in a while to ensure fairness.</span>
    <span class="hljs-comment">// Otherwise two goroutines can completely occupy the local runqueue</span>
    <span class="hljs-comment">// by constantly respawning each other.</span>
    <span class="hljs-comment">// &#x6BCF;&#x8C03;&#x5EA6; 61 &#x6B21;&#xFF0C;&#x5C31;&#x68C0;&#x67E5;&#x4E00;&#x6B21;&#x5168;&#x5C40;&#x961F;&#x5217;&#xFF0C;&#x4FDD;&#x8BC1;&#x516C;&#x5E73;&#x6027;</span>
    <span class="hljs-comment">// &#x5426;&#x5219;&#x4E24;&#x4E2A; Goroutine &#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x4E92;&#x76F8; respawn &#x4E00;&#x76F4;&#x5360;&#x9886;&#x672C;&#x5730;&#x7684; runqueue</span>
    <span class="hljs-comment">// &#x68C0;&#x67E5;&#x5168;&#x5C40;&#x8FD0;&#x884C;&#x961F;&#x5217;&#x4E2D;&#x7684; goroutine</span>
    <span class="hljs-comment">// &#x5168;&#x5C40;&#x8FD0;&#x884C;&#x961F;&#x5217;&#x4FDD;&#x5B58;&#x4E86;&#x6240;&#x6709; M &#x548C; P &#x4E4B;&#x95F4;&#x53EF;&#x5171;&#x4EAB;&#x7684; goroutine&#xFF0C;&#x6BCF; 61 &#x6B21;&#x8C03;&#x5EA6;&#x65F6;&#x4F1A;&#x68C0;&#x67E5;&#x5168;&#x5C40;&#x8FD0;&#x884C;&#x961F;&#x5217;&#x3002;</span>
    <span class="hljs-keyword">if</span> pp.schedtick%<span class="hljs-number">61</span> == <span class="hljs-number">0</span> &amp;&amp; sched.runqsize &gt; <span class="hljs-number">0</span> {
        lock(&amp;sched.lock)
        gp := globrunqget(pp, <span class="hljs-number">1</span>)
        unlock(&amp;sched.lock)
        <span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>
        }
    }

    <span class="hljs-comment">// Wake up the finalizer G.</span>
    <span class="hljs-keyword">if</span> fingStatus.Load()&amp;(fingWait|fingWake) == fingWait|fingWake {
        <span class="hljs-keyword">if</span> gp := wakefing(); gp != <span class="hljs-literal">nil</span> {
            ready(gp, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>)
        }
    }
    <span class="hljs-comment">// cgo &#x8C03;&#x7528;&#x88AB;&#x7EC8;&#x6B62;&#xFF0C;&#x7EE7;&#x7EED;&#x8FDB;&#x5165;</span>
    <span class="hljs-keyword">if</span> *cgo_yield != <span class="hljs-literal">nil</span> {
        asmcgocall(*cgo_yield, <span class="hljs-literal">nil</span>)
    }

    <span class="hljs-comment">// local runq</span>
    <span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x4ECE;&#x672C;&#x5730;&#x961F;&#x5217;&#x83B7;&#x53D6;&#x534F;&#x7A0B;</span>
    <span class="hljs-keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> gp, inheritTime, <span class="hljs-literal">false</span>
    }

    <span class="hljs-comment">// global runq</span>
    <span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x4ECE;&#x5168;&#x5C40;&#x961F;&#x5217;&#x83B7;&#x53D6;&#x534F;&#x7A0B;</span>
    <span class="hljs-keyword">if</span> sched.runqsize != <span class="hljs-number">0</span> {
        lock(&amp;sched.lock)
        gp := globrunqget(pp, <span class="hljs-number">0</span>)
        unlock(&amp;sched.lock)
        <span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>
        }
    }

    <span class="hljs-comment">// Poll network.</span>
    <span class="hljs-comment">// This netpoll is only an optimization before we resort to stealing.</span>
    <span class="hljs-comment">// We can safely skip it if there are no waiters or a thread is blocked</span>
    <span class="hljs-comment">// in netpoll already. If there is any kind of logical race with that</span>
    <span class="hljs-comment">// blocked thread (e.g. it has already returned from netpoll, but does</span>
    <span class="hljs-comment">// not set lastpoll yet), this thread will do blocking netpoll below</span>
    <span class="hljs-comment">// anyway.</span>
    <span class="hljs-comment">// Poll &#x7F51;&#x7EDC;&#xFF0C;&#x4F18;&#x5148;&#x7EA7;&#x6BD4;&#x4ECE;&#x5176;&#x4ED6; P &#x4E2D;&#x5077;&#x8981;&#x9AD8;&#x3002;</span>
    <span class="hljs-comment">// &#x5728;&#x6211;&#x4EEC;&#x5C1D;&#x8BD5;&#x53BB;&#x5176;&#x4ED6; P &#x5077;&#x4E4B;&#x524D;&#xFF0C;&#x8FD9;&#x4E2A; netpoll &#x53EA;&#x662F;&#x4E00;&#x4E2A;&#x4F18;&#x5316;&#x3002;</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x6CA1;&#x6709; waiter &#x6216; netpoll &#x4E2D;&#x7684;&#x7EBF;&#x7A0B;&#x5DF2;&#x88AB;&#x963B;&#x585E;&#xFF0C;&#x5219;&#x53EF;&#x4EE5;&#x5B89;&#x5168;&#x5730;&#x8DF3;&#x8FC7;&#x5B83;&#x3002;</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x6709;&#x4EFB;&#x4F55;&#x7C7B;&#x578B;&#x7684;&#x903B;&#x8F91;&#x7ADE;&#x4E89;&#x4E0E;&#x88AB;&#x963B;&#x585E;&#x7684;&#x7EBF;&#x7A0B;&#xFF08;&#x4F8B;&#x5982;&#x5B83;&#x5DF2;&#x7ECF;&#x4ECE; netpoll &#x8FD4;&#x56DE;&#xFF0C;&#x4F46;&#x5C1A;&#x672A;&#x8BBE;&#x7F6E; lastpoll&#xFF09;</span>
    <span class="hljs-comment">// &#x8BE5;&#x7EBF;&#x7A0B;&#x65E0;&#x8BBA;&#x5982;&#x4F55;&#x90FD;&#x5C06;&#x963B;&#x585E; netpoll&#x3002;</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x521D;&#x59CB;&#x5316;&#x4E86;&#xFF0C;&#x5E76;&#x4E14;&#x6709; goroutine &#x7B49;&#x5F85;&#x7F51;&#x7EDC;&#x4E8B;&#x4EF6;&#xFF0C;&#x8C03;&#x5EA6;&#x5668;&#x4F1A;&#x8C03;&#x7528; netpoll &#x4EE5;&#x975E;&#x963B;&#x585E;&#x7684;&#x65B9;&#x5F0F;&#x68C0;&#x67E5;&#x662F;&#x5426;&#x6709;&#x53EF;&#x6267;&#x884C;&#x7684;&#x7F51;&#x7EDC;&#x4E8B;&#x4EF6;&#x3002;</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x5F53;&#x524D;&#x6CA1;&#x6709;&#x627E;&#x5230;&#x5DE5;&#x4F5C;&#x4E14;&#x5DF2;&#x7ECF;&#x521D;&#x59CB;&#x5316;&#x4E86;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x673A;&#x5236;&#xFF0C;&#x8C03;&#x5EA6;&#x5668;&#x4F1A;&#x5C1D;&#x8BD5;&#x901A;&#x8FC7;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x83B7;&#x53D6;&#x65B0;&#x4EFB;&#x52A1;</span>
    <span class="hljs-keyword">if</span> netpollinited() &amp;&amp; netpollWaiters.Load() &gt; <span class="hljs-number">0</span> &amp;&amp; sched.lastpoll.Load() != <span class="hljs-number">0</span> {
        <span class="hljs-comment">// netpoll(0) &#x662F;&#x975E;&#x963B;&#x585E;&#x8F6E;&#x8BE2;&#x64CD;&#x4F5C;&#xFF0C;&#x5B83;&#x4F1A;&#x68C0;&#x67E5;&#x7F51;&#x7EDC;&#x4E8B;&#x4EF6;&#x5E76;&#x8FD4;&#x56DE;&#x7B49;&#x5F85;&#x6267;&#x884C;&#x7684; goroutine &#x5217;&#x8868;&#x3002;</span>
        <span class="hljs-keyword">if</span> list := netpoll(<span class="hljs-number">0</span>); !list.empty() { <span class="hljs-comment">// non-blocking</span>
            <span class="hljs-comment">// &#x5982;&#x679C;&#x6709;&#x7B49;&#x5F85;&#x5904;&#x7406;&#x7684;&#x7F51;&#x7EDC;&#x4E8B;&#x4EF6;&#xFF0C;&#x8C03;&#x5EA6;&#x5668;&#x4F1A;&#x5C06;&#x5176;&#x72B6;&#x6001;&#x8BBE;&#x7F6E;&#x4E3A;&#x53EF;&#x8FD0;&#x884C;&#x5E76;&#x8FD4;&#x56DE;&#x8BE5; goroutine &#x8FDB;&#x884C;&#x8C03;&#x5EA6;&#x3002;</span>
            gp := list.pop()
            injectglist(&amp;list)
            casgstatus(gp, _Gwaiting, _Grunnable)
            <span class="hljs-keyword">if</span> trace.enabled {
                traceGoUnpark(gp, <span class="hljs-number">0</span>)
            }
            <span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>
        }
    }

    <span class="hljs-comment">// Spinning Ms: steal work from other Ps.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Limit the number of spinning Ms to half the number of busy Ps.</span>
    <span class="hljs-comment">// This is necessary to prevent excessive CPU consumption when</span>
    <span class="hljs-comment">// GOMAXPROCS&gt;&gt;1 but the program parallelism is low.</span>
    <span class="hljs-comment">// &#x81EA;&#x65CB;&#x7684;M&#x7684;&#x5DE5;&#x4F5C;&#x7A83;&#x53D6;</span>
    <span class="hljs-comment">// nmspinning&#xFF1A;&#x8BB0;&#x5F55;&#x5F53;&#x524D;&#x6709;&#x591A;&#x5C11; M &#x5904;&#x4E8E;&#x65CB;&#x8F6C;&#x72B6;&#x6001;&#x3002;&#x4E3A;&#x4E86;&#x907F;&#x514D;&#x8FC7;&#x591A; CPU &#x8D44;&#x6E90;&#x6D6A;&#x8D39;&#xFF0C;&#x65CB;&#x8F6C;&#x7684; M &#x7684;&#x6570;&#x91CF;&#x88AB;&#x9650;&#x5236;&#x5728;&#x5FD9;&#x788C;&#x7684; P &#x7684;&#x4E00;&#x534A;&#xFF08;GOMAXPROCS/2&#xFF09;&#x3002;</span>
    <span class="hljs-keyword">if</span> mp.spinning || <span class="hljs-number">2</span>*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load() {
        <span class="hljs-keyword">if</span> !mp.spinning {
            mp.becomeSpinning()
        }

        <span class="hljs-comment">// &#x4ECE;&#x5176;&#x4ED6;P&#x7A83;&#x53D6;&#x5DE5;&#x4F5C;</span>
        gp, inheritTime, tnow, w, newWork := stealWork(now)
        <span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> {
            <span class="hljs-comment">// Successfully stole.</span>
            <span class="hljs-keyword">return</span> gp, inheritTime, <span class="hljs-literal">false</span>
        }
        <span class="hljs-keyword">if</span> newWork {
            <span class="hljs-comment">// There may be new timer or GC work; restart to</span>
            <span class="hljs-comment">// discover.</span>
            <span class="hljs-comment">// &#x5982;&#x679C;&#x6709;&#x65B0;&#x7684;&#x5B9A;&#x65F6;&#x5668;&#x6216; GC &#x5DE5;&#x4F5C;&#xFF0C;&#x5219;&#x91CD;&#x65B0;&#x5F00;&#x59CB;&#x5BFB;&#x627E;&#x5DE5;&#x4F5C;</span>
            <span class="hljs-keyword">goto</span> top
        }

        now = tnow
        <span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; (pollUntil == <span class="hljs-number">0</span> || w &lt; pollUntil) {
            <span class="hljs-comment">// Earlier timer to wait for.</span>
            <span class="hljs-comment">// &#x53D1;&#x73B0;&#x4E86;&#x4E00;&#x4E2A;&#x66F4;&#x65E9;&#x7684;&#x5B9A;&#x65F6;&#x5668;</span>
            pollUntil = w
        }
    }

    <span class="hljs-comment">// &#x7A7A;&#x95F2; GC Worker &#x7684;&#x8C03;&#x5EA6;</span>
    <span class="hljs-comment">// We have nothing to do.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// If we&apos;re in the GC mark phase, can safely scan and blacken objects,</span>
    <span class="hljs-comment">// and have work to do, run idle-time marking rather than give up the P.</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x5783;&#x573E;&#x56DE;&#x6536;&#xFF08;GC&#xFF09;&#x7684;&#x9ED1;&#x5316;&#x9636;&#x6BB5;&#x5DF2;&#x7ECF;&#x542F;&#x7528;&#x5E76;&#x4E14;&#x6709;&#x5DE5;&#x4F5C;&#x53EF;&#x505A;&#xFF0C;</span>
    <span class="hljs-comment">// &#x8C03;&#x5EA6;&#x5668;&#x4F1A;&#x542F;&#x52A8;&#x4E00;&#x4E2A;&#x7A7A;&#x95F2; GC &#x5DE5;&#x4F5C;&#x7EBF;&#x7A0B;&#x6765;&#x6267;&#x884C; GC &#x76F8;&#x5173;&#x7684;&#x4EFB;&#x52A1;&#x3002;</span>
    <span class="hljs-keyword">if</span> gcBlackenEnabled != <span class="hljs-number">0</span> &amp;&amp; gcMarkWorkAvailable(pp) &amp;&amp; gcController.addIdleMarkWorker() {
        <span class="hljs-comment">// &#x5982;&#x679C; gcController.addIdleMarkWorker() &#x6210;&#x529F;&#xFF0C;</span>
        <span class="hljs-comment">// &#x5219;&#x8C03;&#x5EA6;&#x4E00;&#x4E2A; GC worker &#x5E76;&#x5C06;&#x5176;&#x72B6;&#x6001;&#x4ECE; _Gwaiting &#x8BBE;&#x7F6E;&#x4E3A; _Grunnable&#xFF0C;&#x4F7F;&#x5176;&#x5904;&#x4E8E;&#x53EF;&#x8FD0;&#x884C;&#x72B6;&#x6001;&#x3002;</span>
        node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())
        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> {
            pp.gcMarkWorkerMode = gcMarkWorkerIdleMode
            gp := node.gp.ptr()
            casgstatus(gp, _Gwaiting, _Grunnable)
            <span class="hljs-keyword">if</span> trace.enabled {
                traceGoUnpark(gp, <span class="hljs-number">0</span>)
            }
            <span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>
        }
        gcController.removeIdleMarkWorker()
    }

    <span class="hljs-comment">// wasm only:</span>
    <span class="hljs-comment">// If a callback returned and no other goroutine is awake,</span>
    <span class="hljs-comment">// then wake event handler goroutine which pauses execution</span>
    <span class="hljs-comment">// until a callback was triggered.</span>
    gp, otherReady := beforeIdle(now, pollUntil)
    <span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> {
        casgstatus(gp, _Gwaiting, _Grunnable)
        <span class="hljs-keyword">if</span> trace.enabled {
            traceGoUnpark(gp, <span class="hljs-number">0</span>)
        }
        <span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">if</span> otherReady {
        <span class="hljs-keyword">goto</span> top
    }

    <span class="hljs-comment">// Before we drop our P, make a snapshot of the allp slice,</span>
    <span class="hljs-comment">// which can change underfoot once we no longer block</span>
    <span class="hljs-comment">// safe-points. We don&apos;t need to snapshot the contents because</span>
    <span class="hljs-comment">// everything up to cap(allp) is immutable.</span>
    allpSnapshot := allp
    <span class="hljs-comment">// Also snapshot masks. Value changes are OK, but we can&apos;t allow</span>
    <span class="hljs-comment">// len to change out from under us.</span>
    idlepMaskSnapshot := idlepMask
    timerpMaskSnapshot := timerpMask

    <span class="hljs-comment">// return P and block</span>
    lock(&amp;sched.lock)
    <span class="hljs-keyword">if</span> sched.gcwaiting.Load() || pp.runSafePointFn != <span class="hljs-number">0</span> {
        unlock(&amp;sched.lock)
        <span class="hljs-keyword">goto</span> top
    }
    <span class="hljs-keyword">if</span> sched.runqsize != <span class="hljs-number">0</span> {
        gp := globrunqget(pp, <span class="hljs-number">0</span>)
        unlock(&amp;sched.lock)
        <span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">if</span> !mp.spinning &amp;&amp; sched.needspinning.Load() == <span class="hljs-number">1</span> {
        <span class="hljs-comment">// See &quot;Delicate dance&quot; comment below.</span>
        mp.becomeSpinning()
        unlock(&amp;sched.lock)
        <span class="hljs-keyword">goto</span> top
    }
    <span class="hljs-comment">// &#x5982;&#x679C;&#x6CA1;&#x6709;&#x53EF;&#x4EE5;&#x8FD0;&#x884C;&#x7684; goroutine&#xFF0C;&#x4E14; GC &#x5DE5;&#x4F5C;&#x4E5F;&#x5B8C;&#x6210;&#xFF0C;M &#x4F1A;&#x8FDB;&#x5165;&#x7A7A;&#x95F2;&#x72B6;&#x6001;</span>
    <span class="hljs-keyword">if</span> releasep() != pp {
        throw(<span class="hljs-string">&quot;findrunnable: wrong p&quot;</span>)
    }
    now = pidleput(pp, now)
    unlock(&amp;sched.lock)

    <span class="hljs-comment">// Delicate dance: thread transitions from spinning to non-spinning</span>
    <span class="hljs-comment">// state, potentially concurrently with submission of new work. We must</span>
    <span class="hljs-comment">// drop nmspinning first and then check all sources again (with</span>
    <span class="hljs-comment">// #StoreLoad memory barrier in between). If we do it the other way</span>
    <span class="hljs-comment">// around, another thread can submit work after we&apos;ve checked all</span>
    <span class="hljs-comment">// sources but before we drop nmspinning; as a result nobody will</span>
    <span class="hljs-comment">// unpark a thread to run the work.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// This applies to the following sources of work:</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// * Goroutines added to a per-P run queue.</span>
    <span class="hljs-comment">// * New/modified-earlier timers on a per-P timer heap.</span>
    <span class="hljs-comment">// * Idle-priority GC work (barring golang.org/issue/19112).</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// If we discover new work below, we need to restore m.spinning as a</span>
    <span class="hljs-comment">// signal for resetspinning to unpark a new worker thread (because</span>
    <span class="hljs-comment">// there can be more than one starving goroutine).</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// However, if after discovering new work we also observe no idle Ps</span>
    <span class="hljs-comment">// (either here or in resetspinning), we have a problem. We may be</span>
    <span class="hljs-comment">// racing with a non-spinning M in the block above, having found no</span>
    <span class="hljs-comment">// work and preparing to release its P and park. Allowing that P to go</span>
    <span class="hljs-comment">// idle will result in loss of work conservation (idle P while there is</span>
    <span class="hljs-comment">// runnable work). This could result in complete deadlock in the</span>
    <span class="hljs-comment">// unlikely event that we discover new work (from netpoll) right as we</span>
    <span class="hljs-comment">// are racing with _all_ other Ps going idle.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// We use sched.needspinning to synchronize with non-spinning Ms going</span>
    <span class="hljs-comment">// idle. If needspinning is set when they are about to drop their P,</span>
    <span class="hljs-comment">// they abort the drop and instead become a new spinning M on our</span>
    <span class="hljs-comment">// behalf. If we are not racing and the system is truly fully loaded</span>
    <span class="hljs-comment">// then no spinning threads are required, and the next thread to</span>
    <span class="hljs-comment">// naturally become spinning will clear the flag.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Also see &quot;Worker thread parking/unparking&quot; comment at the top of the</span>
    <span class="hljs-comment">// file.</span>
    <span class="hljs-comment">// &#x5904;&#x7406; Spinning &#x8F6C;&#x6362;&#x4E3A;&#x975E; Spinning &#x7684;&#x7CBE;&#x7EC6;&#x64CD;&#x4F5C;</span>
    wasSpinning := mp.spinning
    <span class="hljs-keyword">if</span> mp.spinning {
        mp.spinning = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> sched.nmspinning.Add(<span class="hljs-number">-1</span>) &lt; <span class="hljs-number">0</span> {
            throw(<span class="hljs-string">&quot;findrunnable: negative nmspinning&quot;</span>)
        }

        <span class="hljs-comment">// Note the for correctness, only the last M transitioning from</span>
        <span class="hljs-comment">// spinning to non-spinning must perform these rechecks to</span>
        <span class="hljs-comment">// ensure no missed work. However, the runtime has some cases</span>
        <span class="hljs-comment">// of transient increments of nmspinning that are decremented</span>
        <span class="hljs-comment">// without going through this path, so we must be conservative</span>
        <span class="hljs-comment">// and perform the check on all spinning Ms.</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// See https://go.dev/issue/43997.</span>

        <span class="hljs-comment">// Check all runqueues once again.</span>
        <span class="hljs-comment">// &#x518D;&#x6B21;&#x68C0;&#x67E5;&#x6240;&#x6709;&#x8FD0;&#x884C;&#x961F;&#x5217;&#xFF0C;&#x786E;&#x4FDD;&#x6CA1;&#x6709;&#x9519;&#x8FC7;&#x5DE5;&#x4F5C;</span>
        pp := checkRunqsNoP(allpSnapshot, idlepMaskSnapshot)
        <span class="hljs-keyword">if</span> pp != <span class="hljs-literal">nil</span> {
            acquirep(pp)
            mp.becomeSpinning()
            <span class="hljs-keyword">goto</span> top
        }

        <span class="hljs-comment">// Check for idle-priority GC work again.</span>
        <span class="hljs-comment">// &#x518D;&#x6B21;&#x68C0;&#x67E5;&#x7A7A;&#x95F2;&#x4F18;&#x5148;&#x7EA7; GC &#x5DE5;&#x4F5C;</span>
        pp, gp := checkIdleGCNoP()
        <span class="hljs-keyword">if</span> pp != <span class="hljs-literal">nil</span> {
            acquirep(pp)
            mp.becomeSpinning()

            <span class="hljs-comment">// Run the idle worker.</span>
            pp.gcMarkWorkerMode = gcMarkWorkerIdleMode
            casgstatus(gp, _Gwaiting, _Grunnable)
            <span class="hljs-keyword">if</span> trace.enabled {
                traceGoUnpark(gp, <span class="hljs-number">0</span>)
            }
            <span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>
        }

        <span class="hljs-comment">// Finally, check for timer creation or expiry concurrently with</span>
        <span class="hljs-comment">// transitioning from spinning to non-spinning.</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// Note that we cannot use checkTimers here because it calls</span>
        <span class="hljs-comment">// adjusttimers which may need to allocate memory, and that isn&apos;t</span>
        <span class="hljs-comment">// allowed when we don&apos;t have an active P.</span>
        <span class="hljs-comment">// &#x68C0;&#x67E5;&#x5B9A;&#x65F6;&#x5668;&#x521B;&#x5EFA;&#x6216;&#x5230;&#x671F;</span>
        pollUntil = checkTimersNoP(allpSnapshot, timerpMaskSnapshot, pollUntil)
    }

    <span class="hljs-comment">// Poll network until next timer.</span>
    <span class="hljs-comment">// &#x6761;&#x4EF6;&#x5224;&#x65AD;&#x662F;&#x5426;&#x8FDB;&#x884C;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;</span>
    <span class="hljs-keyword">if</span> netpollinited() &amp;&amp; (netpollWaiters.Load() &gt; <span class="hljs-number">0</span> || pollUntil != <span class="hljs-number">0</span>) &amp;&amp; sched.lastpoll.Swap(<span class="hljs-number">0</span>) != <span class="hljs-number">0</span> {
        sched.pollUntil.Store(pollUntil)
        <span class="hljs-comment">// &#x53EF;&#x80FD;&#x6709;&#x7F51;&#x7EDC;&#x4E8B;&#x4EF6;&#x53EF;&#x5904;&#x7406;&#xFF0C;&#x56E0;&#x6B64;&#x8FDB;&#x5165;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x9636;&#x6BB5;</span>
        <span class="hljs-comment">// &#x8F6E;&#x8BE2;&#x7F51;&#x7EDC;&#x4E8B;&#x4EF6;</span>
        <span class="hljs-comment">// &#x786E;&#x4FDD; M &#x6CA1;&#x6709;&#x7ED1;&#x5B9A; P&#x3002;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x65F6;&#xFF0C;M &#x4E0D;&#x80FD;&#x5360;&#x7528; P&#xFF0C;&#x56E0;&#x4E3A;&#x8F6E;&#x8BE2;&#x8FC7;&#x7A0B;&#x4E2D; M &#x4F1A;&#x963B;&#x585E;&#x7B49;&#x5F85;&#x7F51;&#x7EDC;&#x4E8B;&#x4EF6;&#xFF0C;&#x800C; P &#x9700;&#x8981;&#x7EE7;&#x7EED;&#x5904;&#x7406;&#x5176;&#x4ED6; goroutine&#x3002;</span>
        <span class="hljs-keyword">if</span> mp.p != <span class="hljs-number">0</span> {
            throw(<span class="hljs-string">&quot;findrunnable: netpoll with p&quot;</span>)
        }
        <span class="hljs-comment">// M &#x5904;&#x4E8E;&#x65CB;&#x8F6C;&#x72B6;&#x6001;&#x65F6;&#x4E0D;&#x5141;&#x8BB8;&#x8FDB;&#x5165;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x3002;&#x5982;&#x679C; M &#x6B63;&#x5728;&#x65CB;&#x8F6C;&#x67E5;&#x627E;&#x5DE5;&#x4F5C;&#xFF0C;&#x5219;&#x4E0D;&#x5E94;&#x8FDB;&#x5165;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x4EE5;&#x907F;&#x514D;&#x963B;&#x585E;&#x3002;</span>
        <span class="hljs-keyword">if</span> mp.spinning {
            throw(<span class="hljs-string">&quot;findrunnable: netpoll with spinning&quot;</span>)
        }
        <span class="hljs-comment">// Refresh now.</span>
        <span class="hljs-comment">// &#x8BA1;&#x7B97;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x7684;&#x8D85;&#x65F6;&#x65F6;&#x95F4; delay&#x3002;&#x5982;&#x679C;&#x6709;&#x5B9A;&#x65F6;&#x5668;&#x4E8B;&#x4EF6;&#x53D1;&#x751F;&#xFF0C;&#x5219;&#x8BBE;&#x7F6E; delay &#x4F7F;&#x8F6E;&#x8BE2;&#x7B49;&#x5F85;&#x7684;&#x65F6;&#x95F4;&#x4E0D;&#x8D85;&#x8FC7;&#x5B9A;&#x65F6;&#x5668;&#x4E8B;&#x4EF6;&#x7684;&#x65F6;&#x95F4;&#x3002;</span>
        now = nanotime()
        delay := <span class="hljs-keyword">int64</span>(<span class="hljs-number">-1</span>)
        <span class="hljs-keyword">if</span> pollUntil != <span class="hljs-number">0</span> {
            delay = pollUntil - now
            <span class="hljs-keyword">if</span> delay &lt; <span class="hljs-number">0</span> {
                delay = <span class="hljs-number">0</span>
            }
        }
        <span class="hljs-keyword">if</span> faketime != <span class="hljs-number">0</span> {
            <span class="hljs-comment">// When using fake time, just poll.</span>
            delay = <span class="hljs-number">0</span>
        }
        <span class="hljs-comment">// &#x6267;&#x884C;&#x975E;&#x963B;&#x585E;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;</span>
        <span class="hljs-comment">// &#x6267;&#x884C;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#xFF0C;&#x963B;&#x585E;&#x76F4;&#x5230;&#x6709;&#x65B0;&#x7684;&#x7F51;&#x7EDC;&#x4E8B;&#x4EF6;&#x6216;&#x8D85;&#x65F6;&#x3002;</span>
        list := netpoll(delay) <span class="hljs-comment">// block until new work is available</span>
        <span class="hljs-comment">// &#x8F6E;&#x8BE2;&#x5B8C;&#x6210;&#x540E;&#xFF0C;&#x5C06; sched.pollUntil &#x548C; sched.lastpoll &#x91CD;&#x7F6E;&#xFF0C;&#x786E;&#x4FDD;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x7684;&#x72B6;&#x6001;&#x5DF2;&#x66F4;&#x65B0;&#x3002;</span>
        sched.pollUntil.Store(<span class="hljs-number">0</span>)
        sched.lastpoll.Store(now)
        <span class="hljs-keyword">if</span> faketime != <span class="hljs-number">0</span> &amp;&amp; list.empty() {
            <span class="hljs-comment">// Using fake time and nothing is ready; stop M.</span>
            <span class="hljs-comment">// When all M&apos;s stop, checkdead will call timejump.</span>
            <span class="hljs-comment">//     &#x5982;&#x679C;&#x4F7F;&#x7528;&#x7684;&#x662F;&#x865A;&#x62DF;&#x65F6;&#x95F4; (faketime != 0) &#x5E76;&#x4E14;&#x6CA1;&#x6709;&#x7F51;&#x7EDC;&#x4E8B;&#x4EF6;&#xFF0C;</span>
            <span class="hljs-comment">//     &#x5F53;&#x524D; M &#x4F1A;&#x505C;&#x6B62; (stopm())&#xFF0C;&#x91CA;&#x653E;&#x7CFB;&#x7EDF;&#x8D44;&#x6E90;&#xFF0C;&#x8FDB;&#x5165;&#x7A7A;&#x95F2;&#x72B6;&#x6001;&#x3002;</span>
            stopm()
            <span class="hljs-keyword">goto</span> top
        }
        <span class="hljs-comment">// &#x5206;&#x914D;&#x53EF;&#x8FD0;&#x884C;&#x7684; goroutine</span>
        lock(&amp;sched.lock)
        <span class="hljs-comment">// &#x68C0;&#x67E5;&#x662F;&#x5426;&#x6709;&#x7A7A;&#x95F2;&#x7684;P&#x53EF;&#x7528;</span>
        pp, _ := pidleget(now)
        unlock(&amp;sched.lock)
        <span class="hljs-comment">// &#x5982;&#x679C;&#x6CA1;&#x6709;&#x7A7A;&#x95F2;&#x7684; P&#xFF0C;&#x5219;&#x5C06;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x7ED3;&#x679C;&#x7684; goroutine &#x5217;&#x8868; (list) &#x6CE8;&#x5165;&#x5168;&#x5C40;&#x961F;&#x5217;&#x3002;</span>
        <span class="hljs-keyword">if</span> pp == <span class="hljs-literal">nil</span> {
            injectglist(&amp;list)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// &#x5982;&#x679C;&#x6709;&#x7A7A;&#x95F2;&#x7684; P&#xFF0C;&#x5219;&#x83B7;&#x53D6;&#x8BE5; P &#x5E76;&#x4ECE;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x7684;&#x7ED3;&#x679C;&#x4E2D;&#x9009;&#x62E9;&#x4E00;&#x4E2A; goroutine &#x8FD0;&#x884C;&#xFF0C;</span>
            <span class="hljs-comment">// &#x66F4;&#x65B0;&#x5176;&#x72B6;&#x6001;&#x4E3A;&#x53EF;&#x8FD0;&#x884C; (_Grunnable) &#x5E76;&#x5C06;&#x5176;&#x8FD4;&#x56DE;</span>
            acquirep(pp)
            <span class="hljs-keyword">if</span> !list.empty() {
                gp := list.pop()
                injectglist(&amp;list)
                casgstatus(gp, _Gwaiting, _Grunnable)
                <span class="hljs-keyword">if</span> trace.enabled {
                    traceGoUnpark(gp, <span class="hljs-number">0</span>)
                }
                <span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>
            }
            <span class="hljs-keyword">if</span> wasSpinning {
                mp.becomeSpinning()
            }
            <span class="hljs-keyword">goto</span> top
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> pollUntil != <span class="hljs-number">0</span> &amp;&amp; netpollinited() {
        <span class="hljs-comment">// &#x7EE7;&#x7EED;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;</span>
        <span class="hljs-comment">// &#x5982;&#x679C; pollUntil &#x4E0D;&#x4E3A;&#x96F6;&#x4E14;&#x7F51;&#x7EDC;&#x8F6E;&#x8BE2;&#x5DF2;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x8C03;&#x5EA6;&#x5668;&#x5C06;&#x7EE7;&#x7EED;&#x8F6E;&#x8BE2;&#x4EE5;&#x83B7;&#x53D6;&#x66F4;&#x591A;&#x7684;&#x7F51;&#x7EDC;&#x4E8B;&#x4EF6;&#xFF0C;&#x76F4;&#x5230;&#x4E0B;&#x4E00;&#x6B21;&#x5B9A;&#x65F6;&#x5668;&#x4E8B;&#x4EF6;&#x53D1;&#x751F;&#x3002;</span>
        pollerPollUntil := sched.pollUntil.Load()
        <span class="hljs-keyword">if</span> pollerPollUntil == <span class="hljs-number">0</span> || pollerPollUntil &gt; pollUntil {
            netpollBreak()
        }
    }
    <span class="hljs-comment">// &#x5982;&#x679C;&#x627E;&#x4E0D;&#x5230;&#x53EF;&#x8FD0;&#x884C;&#x7684; goroutine &#x6216;&#x7F51;&#x7EDC;&#x4E8B;&#x4EF6;&#xFF0C;M &#x5C06;&#x8C03;&#x7528; stopm() &#x8FDB;&#x5165;&#x7A7A;&#x95F2;&#x72B6;&#x6001;&#xFF0C;&#x7B49;&#x5F85;&#x8C03;&#x5EA6;&#x5668;&#x91CD;&#x65B0;&#x5524;&#x9192;&#x3002;</span>
    stopm()
    <span class="hljs-keyword">goto</span> top
}
</code></pre>
<pre><code class="lang-go"><span class="hljs-comment">// stealWork attempts to steal a runnable goroutine or timer from any P.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// If newWork is true, new work may have been readied.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// If now is not 0 it is the current time. stealWork returns the passed time or</span>
<span class="hljs-comment">// the current time if now was passed as 0.</span>
<span class="hljs-keyword">func</span> stealWork(now <span class="hljs-keyword">int64</span>) (gp *g, inheritTime <span class="hljs-keyword">bool</span>, rnow, pollUntil <span class="hljs-keyword">int64</span>, newWork <span class="hljs-keyword">bool</span>) {
    pp := getg().m.p.ptr()

    <span class="hljs-comment">// &#x6807;&#x8BB0;&#x662F;&#x5426;&#x8FD0;&#x884C;&#x4E86;&#x5B9A;&#x65F6;&#x5668;</span>
    ranTimer := <span class="hljs-literal">false</span>

    <span class="hljs-comment">// &#x6700;&#x591A;&#x5077;&#x53D6;&#x56DB;&#x6B21;</span>
    <span class="hljs-keyword">const</span> stealTries = <span class="hljs-number">4</span>
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; stealTries; i++ {
        <span class="hljs-comment">// &#x6700;&#x540E;&#x4E00;&#x6B21;&#x5C1D;&#x8BD5;&#x7A83;&#x53D6;&#x65F6;&#xFF0C;&#x4F18;&#x5148;&#x5C1D;&#x8BD5;&#x7A83;&#x53D6;&#x5B9A;&#x65F6;&#x5668;</span>
        <span class="hljs-comment">// &#x53EA;&#x6709;&#x5728;&#x6700;&#x540E;&#x4E00;&#x6B21;&#x5C1D;&#x8BD5;&#x65F6;&#xFF0C;&#x624D;&#x4F1A;&#x4F18;&#x5148;&#x5C1D;&#x8BD5;&#x7A83;&#x53D6;&#x5B9A;&#x65F6;&#x5668;&#x6216;&#x8005; runnext&#xFF0C;&#x5373;&#x6700;&#x9AD8;&#x4F18;&#x5148;&#x7EA7;&#x7684; goroutine&#x3002;</span>
        stealTimersOrRunNextG := i == stealTries<span class="hljs-number">-1</span>

        <span class="hljs-comment">// &#x904D;&#x5386;P</span>
        <span class="hljs-comment">// &#x968F;&#x673A;&#x987A;&#x5E8F;&#x904D;&#x5386;&#x6240;&#x6709;&#x7684;P</span>
        <span class="hljs-keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
            <span class="hljs-comment">// &#x5982;&#x679C;&#x8C03;&#x5EA6;&#x5668;&#x6B63;&#x5728;&#x7B49;&#x5F85;&#x5783;&#x573E;&#x56DE;&#x6536; (GC) &#x8FDB;&#x884C;&#xFF0C;&#x5219;&#x8FD4;&#x56DE;&#xFF0C;&#x8868;&#x793A;&#x53EF;&#x80FD;&#x6709; GC &#x4EFB;&#x52A1;&#x3002;</span>
            <span class="hljs-keyword">if</span> sched.gcwaiting.Load() {
                <span class="hljs-comment">// GC work may be available.</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>, now, pollUntil, <span class="hljs-literal">true</span>
            }
            <span class="hljs-comment">// &#x5F53;&#x524D;&#x904D;&#x5386;&#x7684;P</span>
            p2 := allp[enum.position()]
            <span class="hljs-comment">// &#x662F;&#x81EA;&#x5DF1;&#x5219;&#x8DF3;&#x8FC7;</span>
            <span class="hljs-keyword">if</span> pp == p2 {
                <span class="hljs-keyword">continue</span>
            }

            <span class="hljs-comment">// Steal timers from p2. This call to checkTimers is the only place</span>
            <span class="hljs-comment">// where we might hold a lock on a different P&apos;s timers. We do this</span>
            <span class="hljs-comment">// once on the last pass before checking runnext because stealing</span>
            <span class="hljs-comment">// from the other P&apos;s runnext should be the last resort, so if there</span>
            <span class="hljs-comment">// are timers to steal do that first.</span>
            <span class="hljs-comment">//</span>
            <span class="hljs-comment">// We only check timers on one of the stealing iterations because</span>
            <span class="hljs-comment">// the time stored in now doesn&apos;t change in this loop and checking</span>
            <span class="hljs-comment">// the timers for each P more than once with the same value of now</span>
            <span class="hljs-comment">// is probably a waste of time.</span>
            <span class="hljs-comment">//</span>
            <span class="hljs-comment">// timerpMask tells us whether the P may have timers at all. If it</span>
            <span class="hljs-comment">// can&apos;t, no need to check at all.</span>
            <span class="hljs-comment">// &#x5077;&#x53D6;&#x5B9A;&#x65F6;&#x5668;&#x4EFB;&#x52A1;</span>
            <span class="hljs-keyword">if</span> stealTimersOrRunNextG &amp;&amp; timerpMask.read(enum.position()) {
                <span class="hljs-comment">// &#x68C0;&#x67E5; p2 &#x662F;&#x5426;&#x6709;&#x5B9A;&#x65F6;&#x5668;&#x5230;&#x671F;&#x4EFB;&#x52A1;&#xFF0C;&#x5982;&#x679C;&#x6709;&#x5C31;&#x8FD0;&#x884C;&#x3002;</span>
                tnow, w, ran := checkTimers(p2, now)
                now = tnow
                <span class="hljs-comment">// &#x66F4;&#x65B0;&#x5B9A;&#x65F6;&#x5668;&#x7684;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x3002;</span>
                <span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; (pollUntil == <span class="hljs-number">0</span> || w &lt; pollUntil) {
                    pollUntil = w
                }
                <span class="hljs-keyword">if</span> ran {
                    <span class="hljs-comment">// &#x5982;&#x679C;&#x6210;&#x529F;&#x8FD0;&#x884C;&#x4E86;&#x5B9A;&#x65F6;&#x5668;&#x4EFB;&#x52A1; (ran &#x4E3A; true)&#xFF0C;</span>
                    <span class="hljs-comment">// &#x68C0;&#x67E5;&#x5F53;&#x524D; P (pp) &#x7684;&#x8FD0;&#x884C;&#x961F;&#x5217; (runqget) &#x662F;&#x5426;&#x6709;&#x4EFB;&#x52A1;&#x53EF;&#x6267;&#x884C;&#x3002;&#x5982;&#x679C;&#x6709;&#xFF0C;&#x8FD4;&#x56DE;&#x8BE5; goroutine&#x3002;</span>
                    <span class="hljs-comment">// Running the timers may have</span>
                    <span class="hljs-comment">// made an arbitrary number of G&apos;s</span>
                    <span class="hljs-comment">// ready and added them to this P&apos;s</span>
                    <span class="hljs-comment">// local run queue. That invalidates</span>
                    <span class="hljs-comment">// the assumption of runqsteal</span>
                    <span class="hljs-comment">// that it always has room to add</span>
                    <span class="hljs-comment">// stolen G&apos;s. So check now if there</span>
                    <span class="hljs-comment">// is a local G to run.</span>
                    <span class="hljs-keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="hljs-literal">nil</span> {
                        <span class="hljs-keyword">return</span> gp, inheritTime, now, pollUntil, ranTimer
                    }
                    ranTimer = <span class="hljs-literal">true</span>
                }
            }

            <span class="hljs-comment">// Don&apos;t bother to attempt to steal if p2 is idle.</span>
            <span class="hljs-comment">// &#x68C0;&#x67E5; p2 &#x662F;&#x5426;&#x5904;&#x4E8E;&#x7A7A;&#x95F2;&#x72B6;&#x6001; (idlepMask.read)&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x7A7A;&#x95F2;&#xFF0C;&#x5C1D;&#x8BD5;&#x4ECE; p2 &#x4E2D;&#x5077;&#x53D6;&#x4EFB;&#x52A1; (runqsteal)&#x3002;</span>
            <span class="hljs-keyword">if</span> !idlepMask.read(enum.position()) {
                <span class="hljs-keyword">if</span> gp := runqsteal(pp, p2, stealTimersOrRunNextG); gp != <span class="hljs-literal">nil</span> {
                    <span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, now, pollUntil, ranTimer
                }
            }
        }
    }

    <span class="hljs-comment">// No goroutines found to steal. Regardless, running a timer may have</span>
    <span class="hljs-comment">// made some goroutine ready that we missed. Indicate the next timer to</span>
    <span class="hljs-comment">// wait for.</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x6240;&#x6709;&#x5C1D;&#x8BD5;&#x90FD;&#x5931;&#x8D25;&#xFF0C;&#x6CA1;&#x6709;&#x627E;&#x5230;&#x53EF;&#x8FD0;&#x884C;&#x7684; goroutine &#x6216;&#x5B9A;&#x65F6;&#x5668;&#x4EFB;&#x52A1;&#xFF0C;&#x5219;&#x8FD4;&#x56DE; nil&#xFF0C;</span>
    <span class="hljs-comment">// &#x8868;&#x793A;&#x5F53;&#x524D;&#x6CA1;&#x6709;&#x4EFB;&#x52A1;&#x53EF;&#x6267;&#x884C;&#xFF0C;&#x53EF;&#x80FD;&#x9700;&#x8981;&#x7EE7;&#x7EED;&#x7B49;&#x5F85;&#x5176;&#x4ED6;&#x4EFB;&#x52A1;&#x7684;&#x5230;&#x6765;&#x3002;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>, now, pollUntil, ranTimer
}
</code></pre>
<h4 id="3&#x3001;m&#x7684;&#x5524;&#x9192;">3&#x3001;M&#x7684;&#x5524;&#x9192;</h4>
<pre><code class="lang-go"><span class="hljs-keyword">func</span> resetspinning() {
    gp := getg()
    <span class="hljs-keyword">if</span> !gp.m.spinning {
        throw(<span class="hljs-string">&quot;resetspinning: not a spinning m&quot;</span>)
    }
    <span class="hljs-comment">// &#x505C;&#x6B62;&#x5F53;&#x524D;M&#x7684;&#x81EA;&#x65CB;&#x72B6;&#x6001;</span>
    gp.m.spinning = <span class="hljs-literal">false</span>
    <span class="hljs-comment">// &#x66F4;&#x65B0;M&#x7684;&#x5168;&#x5C40;&#x8BA1;&#x6570;&#xFF0C;&#x786E;&#x4FDD;&#x65CB;&#x8F6C;&#x72B6;&#x6001;&#x8BA1;&#x6570;&#x6B63;&#x786E;</span>
    nmspinning := sched.nmspinning.Add(<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">if</span> nmspinning &lt; <span class="hljs-number">0</span> {
        throw(<span class="hljs-string">&quot;findrunnable: negative nmspinning&quot;</span>)
    }
    <span class="hljs-comment">// M wakeup policy is deliberately somewhat conservative, so check if we</span>
    <span class="hljs-comment">// need to wakeup another P here. See &quot;Worker thread parking/unparking&quot;</span>
    <span class="hljs-comment">// comment at the top of the file for details.</span>
    <span class="hljs-comment">// &#x68C0;&#x67E5;&#x662F;&#x5426;&#x9700;&#x8981;&#x5524;&#x9192;&#x5176;&#x4ED6; M &#x6765;&#x5904;&#x7406;&#x65B0;&#x7684;&#x4EFB;&#x52A1;&#xFF0C;&#x4FDD;&#x6301;&#x7CFB;&#x7EDF;&#x7684;&#x8FD0;&#x884C;&#x6548;&#x7387;&#x3002;</span>
    wakep()
}

<span class="hljs-comment">// Tries to add one more P to execute G&apos;s.</span>
<span class="hljs-comment">// Called when a G is made runnable (newproc, ready).</span>
<span class="hljs-comment">// Must be called with a P.</span>
<span class="hljs-keyword">func</span> wakep() {
    <span class="hljs-comment">// Be conservative about spinning threads, only start one if none exist</span>
    <span class="hljs-comment">// already.</span>
    <span class="hljs-keyword">if</span> sched.nmspinning.Load() != <span class="hljs-number">0</span> || !sched.nmspinning.CompareAndSwap(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-comment">// Disable preemption until ownership of pp transfers to the next M in</span>
    <span class="hljs-comment">// startm. Otherwise preemption here would leave pp stuck waiting to</span>
    <span class="hljs-comment">// enter _Pgcstop.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// See preemption comment on acquirem in startm for more details.</span>
    <span class="hljs-comment">// &#x83B7;&#x53D6;&#x5F53;&#x524D;&#x7684; M&#xFF0C;&#x5E76;&#x7981;&#x6B62;&#x62A2;&#x5360;&#x3002;&#x8FD9;&#x6837;&#x786E;&#x4FDD;&#x5728; P &#x88AB;&#x5206;&#x914D;&#x7ED9;&#x4E0B;&#x4E00;&#x4E2A; M &#x4E4B;&#x524D;&#xFF0C;&#x4E0D;&#x4F1A;&#x88AB;&#x62A2;&#x5360;&#x3002;</span>
    mp := acquirem()

    <span class="hljs-keyword">var</span> pp *p
    lock(&amp;sched.lock)
    <span class="hljs-comment">// &#x67E5;&#x627E;&#x7A7A;&#x95F2;&#x7684;P</span>
    <span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x4ECE;&#x7A7A;&#x95F2; P &#x5217;&#x8868;&#x4E2D;&#x83B7;&#x53D6;&#x4E00;&#x4E2A; P&#x3002;&#x5982;&#x679C;&#x627E;&#x4E0D;&#x5230;&#x7A7A;&#x95F2;&#x7684; P&#xFF0C;pp &#x4E3A; nil&#x3002;</span>
    pp, _ = pidlegetSpinning(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">if</span> pp == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// &#x5982;&#x679C; pp == nil&#xFF0C;&#x5219;&#x6CA1;&#x6709;&#x7A7A;&#x95F2;&#x7684; P&#xFF0C;&#x6B64;&#x65F6;&#x5C06; nmspinning &#x51CF; 1&#xFF0C;&#x8868;&#x793A;&#x6CA1;&#x6709; M &#x5904;&#x4E8E;&#x65CB;&#x8F6C;&#x72B6;&#x6001;&#xFF0C;&#x7136;&#x540E;&#x89E3;&#x9501;&#x5E76;&#x91CA;&#x653E;&#x5F53;&#x524D; M&#x3002;</span>
        <span class="hljs-keyword">if</span> sched.nmspinning.Add(<span class="hljs-number">-1</span>) &lt; <span class="hljs-number">0</span> {
            throw(<span class="hljs-string">&quot;wakep: negative nmspinning&quot;</span>)
        }
        unlock(&amp;sched.lock)
        releasem(mp)
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-comment">// Since we always have a P, the race in the &quot;No M is available&quot;</span>
    <span class="hljs-comment">// comment in startm doesn&apos;t apply during the small window between the</span>
    <span class="hljs-comment">// unlock here and lock in startm. A checkdead in between will always</span>
    <span class="hljs-comment">// see at least one running M (ours).</span>
    unlock(&amp;sched.lock)

    <span class="hljs-comment">// &#x5982;&#x679C;&#x627E;&#x5230;&#x7A7A;&#x95F2;&#x7684; P&#xFF0C;&#x5219;&#x8C03;&#x7528; startm(pp, true, false) &#x542F;&#x52A8;&#x4E00;&#x4E2A;&#x65B0;&#x7684; M &#x6765;&#x6267;&#x884C; P</span>
    startm(pp, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)

    <span class="hljs-comment">// &#x89E3;&#x9664;&#x5BF9; M &#x7684;&#x6301;&#x6709;&#xFF0C;&#x6062;&#x590D;&#x62A2;&#x5360;&#x3002;</span>
    releasem(mp)
}

<span class="hljs-comment">// Schedules some M to run the p (creates an M if necessary).</span>
<span class="hljs-comment">// If p==nil, tries to get an idle P, if no idle P&apos;s does nothing.</span>
<span class="hljs-comment">// May run with m.p==nil, so write barriers are not allowed.</span>
<span class="hljs-comment">// If spinning is set, the caller has incremented nmspinning and must provide a</span>
<span class="hljs-comment">// P. startm will set m.spinning in the newly started M.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Callers passing a non-nil P must call from a non-preemptible context. See</span>
<span class="hljs-comment">// comment on acquirem below.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Argument lockheld indicates whether the caller already acquired the</span>
<span class="hljs-comment">// scheduler lock. Callers holding the lock when making the call must pass</span>
<span class="hljs-comment">// true. The lock might be temporarily dropped, but will be reacquired before</span>
<span class="hljs-comment">// returning.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Must not have write barriers because this may be called without a P.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// startm &#x51FD;&#x6570;&#x7684;&#x76EE;&#x7684;&#x662F;&#x542F;&#x52A8;&#x4E00;&#x4E2A;&#x65B0;&#x7684; M &#x6765;&#x6267;&#x884C;&#x4EFB;&#x52A1;&#xFF0C;&#x6216;&#x8005;&#x4E3A;&#x73B0;&#x6709;&#x7684; P &#x5206;&#x914D;&#x4E00;&#x4E2A; M&#x3002;</span>
<span class="hljs-comment">// &#x5B83;&#x53EF;&#x4EE5;&#x5728;&#x7CFB;&#x7EDF;&#x4E2D;&#x6CA1;&#x6709;&#x7A7A;&#x95F2;&#x7684; M &#x65F6;&#x521B;&#x5EFA;&#x65B0;&#x7684; M&#xFF0C;&#x5E76;&#x5C06;&#x5176;&#x4E0E; P &#x5173;&#x8054;&#xFF0C;&#x4EE5;&#x7EE7;&#x7EED;&#x8C03;&#x5EA6;&#x5E76;&#x6267;&#x884C;&#x53EF;&#x8FD0;&#x884C;&#x7684; G&#x3002;</span>
<span class="hljs-comment">//     1.    &#x5F53;&#x6709;&#x7A7A;&#x95F2;&#x7684; P &#x4F46;&#x6CA1;&#x6709; M &#x65F6;&#xFF0C;&#x5B83;&#x4F1A;&#x521B;&#x5EFA;&#x65B0;&#x7684; M&#x3002;</span>
<span class="hljs-comment">//    2.    &#x5F53;&#x7CFB;&#x7EDF;&#x4E2D;&#x6709;&#x4EFB;&#x52A1;&#x9700;&#x8981;&#x5904;&#x7406;&#x65F6;&#xFF0C;&#x5B83;&#x4F1A;&#x5524;&#x9192; M &#x6765;&#x6267;&#x884C;&#x8FD9;&#x4E9B;&#x4EFB;&#x52A1;&#x3002;</span>
<span class="hljs-comment">//    3.    &#x5BF9;&#x4E8E;&#x65CB;&#x8F6C; M&#xFF0C;&#x5B83;&#x4F1A;&#x786E;&#x4FDD; M &#x5904;&#x4E8E;&#x6B63;&#x786E;&#x7684;&#x72B6;&#x6001;&#xFF0C;&#x5E76;&#x4E14;&#x6CA1;&#x6709;&#x51B2;&#x7A81;&#x7684; G &#x6216; P&#x3002;</span>
<span class="hljs-comment">//go:nowritebarrierrec</span>
<span class="hljs-keyword">func</span> startm(pp *p, spinning, lockheld <span class="hljs-keyword">bool</span>) {
    <span class="hljs-comment">// Disable preemption.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Every owned P must have an owner that will eventually stop it in the</span>
    <span class="hljs-comment">// event of a GC stop request. startm takes transient ownership of a P</span>
    <span class="hljs-comment">// (either from argument or pidleget below) and transfers ownership to</span>
    <span class="hljs-comment">// a started M, which will be responsible for performing the stop.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Preemption must be disabled during this transient ownership,</span>
    <span class="hljs-comment">// otherwise the P this is running on may enter GC stop while still</span>
    <span class="hljs-comment">// holding the transient P, leaving that P in limbo and deadlocking the</span>
    <span class="hljs-comment">// STW.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Callers passing a non-nil P must already be in non-preemptible</span>
    <span class="hljs-comment">// context, otherwise such preemption could occur on function entry to</span>
    <span class="hljs-comment">// startm. Callers passing a nil P may be preemptible, so we must</span>
    <span class="hljs-comment">// disable preemption before acquiring a P from pidleget below.</span>
    mp := acquirem()
    <span class="hljs-keyword">if</span> !lockheld {
        lock(&amp;sched.lock)
    }
    <span class="hljs-keyword">if</span> pp == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// &#x83B7;&#x53D6;P</span>
        <span class="hljs-keyword">if</span> spinning {
            <span class="hljs-comment">// TODO(prattmic): All remaining calls to this function</span>
            <span class="hljs-comment">// with _p_ == nil could be cleaned up to find a P</span>
            <span class="hljs-comment">// before calling startm.</span>
            throw(<span class="hljs-string">&quot;startm: P required for spinning=true&quot;</span>)
        }
        <span class="hljs-comment">// &#x4ECE;&#x7A7A;&#x95F2;&#x5217;&#x8868;&#x83B7;&#x53D6;&#xFF0C;&#x6CA1;&#x6709;&#x5C31;&#x8FD4;&#x56DE;</span>
        pp, _ = pidleget(<span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> pp == <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">if</span> !lockheld {
                unlock(&amp;sched.lock)
            }
            releasem(mp)
            <span class="hljs-keyword">return</span>
        }
    }
    <span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x7A7A;&#x95F2;&#x7684;M</span>
    nmp := mget()
    <span class="hljs-keyword">if</span> nmp == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// No M is available, we must drop sched.lock and call newm.</span>
        <span class="hljs-comment">// However, we already own a P to assign to the M.</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// Once sched.lock is released, another G (e.g., in a syscall),</span>
        <span class="hljs-comment">// could find no idle P while checkdead finds a runnable G but</span>
        <span class="hljs-comment">// no running M&apos;s because this new M hasn&apos;t started yet, thus</span>
        <span class="hljs-comment">// throwing in an apparent deadlock.</span>
        <span class="hljs-comment">// This apparent deadlock is possible when startm is called</span>
        <span class="hljs-comment">// from sysmon, which doesn&apos;t count as a running M.</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// Avoid this situation by pre-allocating the ID for the new M,</span>
        <span class="hljs-comment">// thus marking it as &apos;running&apos; before we drop sched.lock. This</span>
        <span class="hljs-comment">// new M will eventually run the scheduler to execute any</span>
        <span class="hljs-comment">// queued G&apos;s.</span>
        <span class="hljs-comment">// &#x6CA1;&#x6709;&#x83B7;&#x53D6;&#x5230;&#x7A7A;&#x95F2;&#x7684;M&#xFF0C;&#x51C6;&#x5907;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;M&#x4E0E;P&#x5173;&#x8054;</span>
        id := mReserveID()
        unlock(&amp;sched.lock)

        <span class="hljs-keyword">var</span> fn <span class="hljs-keyword">func</span>()
        <span class="hljs-keyword">if</span> spinning {
            <span class="hljs-comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span>
            fn = mspinning
        }
        newm(fn, pp, id)

        <span class="hljs-keyword">if</span> lockheld {
            lock(&amp;sched.lock)
        }
        <span class="hljs-comment">// Ownership transfer of pp committed by start in newm.</span>
        <span class="hljs-comment">// Preemption is now safe.</span>
        releasem(mp)
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">if</span> !lockheld {
        unlock(&amp;sched.lock)
    }
    <span class="hljs-comment">// &#x68C0;&#x67E5;&#x72B6;&#x6001;&#x5E76;&#x8BBE;&#x7F6E; M</span>
    <span class="hljs-keyword">if</span> nmp.spinning {
        throw(<span class="hljs-string">&quot;startm: m is spinning&quot;</span>)
    }
    <span class="hljs-keyword">if</span> nmp.nextp != <span class="hljs-number">0</span> {
        throw(<span class="hljs-string">&quot;startm: m has p&quot;</span>)
    }
    <span class="hljs-keyword">if</span> spinning &amp;&amp; !runqempty(pp) {
        throw(<span class="hljs-string">&quot;startm: p has runnable gs&quot;</span>)
    }
    <span class="hljs-comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span>
    <span class="hljs-comment">// &#x8BBE;&#x7F6E;M&#x548C;P&#x5173;&#x8054;</span>
    nmp.spinning = spinning
    nmp.nextp.set(pp)
    <span class="hljs-comment">// &#x5524;&#x9192;M</span>
    notewakeup(&amp;nmp.park)
    <span class="hljs-comment">// Ownership transfer of pp committed by wakeup. Preemption is now</span>
    <span class="hljs-comment">// safe.</span>
    releasem(mp)
}
</code></pre>
<h4 id="4&#x3001;m&#x7684;&#x521B;&#x5EFA;">4&#x3001;M&#x7684;&#x521B;&#x5EFA;</h4>
<pre><code class="lang-go"><span class="hljs-comment">// Create a new m. It will start off with a call to fn, or else the scheduler.</span>
<span class="hljs-comment">// fn needs to be static and not a heap allocated closure.</span>
<span class="hljs-comment">// May run with m.p==nil, so write barriers are not allowed.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// // &#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684; m. &#x5B83;&#x4F1A;&#x542F;&#x52A8;&#x5E76;&#x8C03;&#x7528; fn &#x6216;&#x8C03;&#x5EA6;&#x5668;</span>
<span class="hljs-comment">// // fn &#x5FC5;&#x987B;&#x662F;&#x9759;&#x6001;&#x3001;&#x975E;&#x5806;&#x4E0A;&#x5206;&#x914D;&#x7684;&#x95ED;&#x5305;</span>
<span class="hljs-comment">// // &#x5B83;&#x53EF;&#x80FD;&#x5728; m.p==nil &#x65F6;&#x8FD0;&#x884C;&#xFF0C;&#x56E0;&#x6B64;&#x4E0D;&#x5141;&#x8BB8; write barrier</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// id is optional pre-allocated m ID. Omit by passing -1.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:nowritebarrierrec</span>
<span class="hljs-keyword">func</span> newm(fn <span class="hljs-keyword">func</span>(), pp *p, id <span class="hljs-keyword">int64</span>) {
    <span class="hljs-comment">// allocm adds a new M to allm, but they do not start until created by</span>
    <span class="hljs-comment">// the OS in newm1 or the template thread.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// doAllThreadsSyscall requires that every M in allm will eventually</span>
    <span class="hljs-comment">// start and be signal-able, even with a STW.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Disable preemption here until we start the thread to ensure that</span>
    <span class="hljs-comment">// newm is not preempted between allocm and starting the new thread,</span>
    <span class="hljs-comment">// ensuring that anything added to allm is guaranteed to eventually</span>
    <span class="hljs-comment">// start.</span>
    acquirem()

    <span class="hljs-comment">// &#x5206;&#x914D;&#x4E00;&#x4E2A;M</span>
    mp := allocm(pp, fn, id)
    <span class="hljs-comment">// &#x8BBE;&#x7F6E; p &#x7528;&#x4E8E;&#x540E;&#x7EED;&#x7ED1;&#x5B9A;</span>
    mp.nextp.set(pp)
    <span class="hljs-comment">// &#x8BBE;&#x7F6E; signal mask</span>
    mp.sigmask = initSigmask
    <span class="hljs-keyword">if</span> gp := getg(); gp != <span class="hljs-literal">nil</span> &amp;&amp; gp.m != <span class="hljs-literal">nil</span> &amp;&amp; (gp.m.lockedExt != <span class="hljs-number">0</span> || gp.m.incgo) &amp;&amp; GOOS != <span class="hljs-string">&quot;plan9&quot;</span> {
        <span class="hljs-comment">// We&apos;re on a locked M or a thread that may have been</span>
        <span class="hljs-comment">// started by C. The kernel state of this thread may</span>
        <span class="hljs-comment">// be strange (the user may have locked it for that</span>
        <span class="hljs-comment">// purpose). We don&apos;t want to clone that into another</span>
        <span class="hljs-comment">// thread. Instead, ask a known-good thread to create</span>
        <span class="hljs-comment">// the thread for us.</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// &#x6211;&#x4EEC;&#x5904;&#x4E8E;&#x4E00;&#x4E2A;&#x9501;&#x5B9A;&#x7684; M &#x6216;&#x53EF;&#x80FD;&#x7531; C &#x542F;&#x52A8;&#x7684;&#x7EBF;&#x7A0B;&#x3002;&#x8FD9;&#x4E2A;&#x7EBF;&#x7A0B;&#x7684;&#x5185;&#x6838;&#x72B6;&#x6001;&#x53EF;&#x80FD;</span>
        <span class="hljs-comment">// &#x5F88;&#x5947;&#x602A;&#xFF08;&#x7528;&#x6237;&#x53EF;&#x80FD;&#x5DF2;&#x5C06;&#x5176;&#x9501;&#x5B9A;&#xFF09;&#x3002;&#x6211;&#x4EEC;&#x4E0D;&#x60F3;&#x5C06;&#x5176;&#x514B;&#x9686;&#x5230;&#x53E6;&#x4E00;&#x4E2A;&#x7EBF;&#x7A0B;&#x3002;</span>
        <span class="hljs-comment">// &#x76F8;&#x53CD;&#xFF0C;&#x8BF7;&#x6C42;&#x4E00;&#x4E2A;&#x5DF2;&#x77E5;&#x72B6;&#x6001;&#x826F;&#x597D;&#x7684;&#x7EBF;&#x7A0B;&#x6765;&#x521B;&#x5EFA;&#x7ED9;&#x6211;&#x4EEC;&#x7684;&#x7EBF;&#x7A0B;&#x3002;</span>
        <span class="hljs-comment">// This is disabled on Plan 9. See golang.org/issue/22227.</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This may be unnecessary on Windows, which</span>
        <span class="hljs-comment">// doesn&apos;t model thread creation off fork.</span>
        lock(&amp;newmHandoff.lock)
        <span class="hljs-keyword">if</span> newmHandoff.haveTemplateThread == <span class="hljs-number">0</span> {
            throw(<span class="hljs-string">&quot;on a locked thread with no template thread&quot;</span>)
        }
        mp.schedlink = newmHandoff.newm
        newmHandoff.newm.set(mp)
        <span class="hljs-keyword">if</span> newmHandoff.waiting {
            newmHandoff.waiting = <span class="hljs-literal">false</span>
            <span class="hljs-comment">// &#x5524;&#x9192; m, &#x81EA;&#x65CB;&#x5230;&#x975E;&#x81EA;&#x65CB;</span>
            notewakeup(&amp;newmHandoff.wake)
        }
        unlock(&amp;newmHandoff.lock)
        <span class="hljs-comment">// The M has not started yet, but the template thread does not</span>
        <span class="hljs-comment">// participate in STW, so it will always process queued Ms and</span>
        <span class="hljs-comment">// it is safe to releasem.</span>
        releasem(getg().m)
        <span class="hljs-keyword">return</span>
    }
    newm1(mp)
    releasem(getg().m)
}
</code></pre>
<pre><code class="lang-go"><span class="hljs-comment">// Allocate a new m unassociated with any thread.</span>
<span class="hljs-comment">// Can use p for allocation context if needed.</span>
<span class="hljs-comment">// fn is recorded as the new m&apos;s m.mstartfn.</span>
<span class="hljs-comment">// id is optional pre-allocated m ID. Omit by passing -1.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// This function is allowed to have write barriers even if the caller</span>
<span class="hljs-comment">// isn&apos;t because it borrows pp.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:yeswritebarrierrec</span>
<span class="hljs-keyword">func</span> allocm(pp *p, fn <span class="hljs-keyword">func</span>(), id <span class="hljs-keyword">int64</span>) *m {
    allocmLock.rlock()

    <span class="hljs-comment">// The caller owns pp, but we may borrow (i.e., acquirep) it. We must</span>
    <span class="hljs-comment">// disable preemption to ensure it is not stolen, which would make the</span>
    <span class="hljs-comment">// caller lose ownership.</span>
    acquirem()

    gp := getg()
    <span class="hljs-comment">// P &#x4EE3;&#x8868;&#x5904;&#x7406;&#x5668;&#x8D44;&#x6E90;&#xFF0C;M &#x9700;&#x8981;&#x4E00;&#x4E2A; P &#x6765;&#x6267;&#x884C;&#x4EFB;&#x52A1;&#x3002;&#x5982;&#x679C;&#x5F53;&#x524D;&#x7684; M &#x6CA1;&#x6709;&#x7ED1;&#x5B9A; P&#xFF0C;&#x5219;&#x4E34;&#x65F6;&#x83B7;&#x53D6;&#x4E00;&#x4E2A; P&#xFF0C;&#x7528;&#x4E8E;&#x5185;&#x5B58;&#x5206;&#x914D;&#x7B49;&#x64CD;&#x4F5C;&#x3002;</span>
    <span class="hljs-keyword">if</span> gp.m.p == <span class="hljs-number">0</span> {
        acquirep(pp) <span class="hljs-comment">// temporarily borrow p for mallocs in this function</span>
    }

    <span class="hljs-comment">// Release the free M list. We need to do this somewhere and</span>
    <span class="hljs-comment">// this may free up a stack we can use.</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x8C03;&#x5EA6;&#x5668;&#x4E2D;&#x6709;&#x7A7A;&#x95F2;&#x7684; M&#xFF0C;&#x5219;&#x4F1A;&#x5C1D;&#x8BD5;&#x91CA;&#x653E;&#x8FD9;&#x4E9B;&#x7A7A;&#x95F2;&#x7684; M&#xFF0C;&#x7279;&#x522B;&#x662F;&#x90A3;&#x4E9B;&#x4E0D;&#x518D;&#x9700;&#x8981;&#x7684; M &#x7684;&#x6808;&#x7A7A;&#x95F4;&#x3002;</span>
    <span class="hljs-comment">// stackfree &#x51FD;&#x6570;&#x4F1A;&#x91CA;&#x653E; M &#x7684; g0 &#x6808;&#xFF08;g0 &#x662F; M &#x7684;&#x7CFB;&#x7EDF; Goroutine&#xFF09;&#x3002;</span>
    <span class="hljs-keyword">if</span> sched.freem != <span class="hljs-literal">nil</span> {
        lock(&amp;sched.lock)
        <span class="hljs-keyword">var</span> newList *m
        <span class="hljs-keyword">for</span> freem := sched.freem; freem != <span class="hljs-literal">nil</span>; {
            wait := freem.freeWait.Load()
            <span class="hljs-keyword">if</span> wait == freeMWait {
                next := freem.freelink
                freem.freelink = newList
                newList = freem
                freem = next
                <span class="hljs-keyword">continue</span>
            }
            <span class="hljs-comment">// Free the stack if needed. For freeMRef, there is</span>
            <span class="hljs-comment">// nothing to do except drop freem from the sched.freem</span>
            <span class="hljs-comment">// list.</span>
            <span class="hljs-keyword">if</span> wait == freeMStack {
                <span class="hljs-comment">// stackfree must be on the system stack, but allocm is</span>
                <span class="hljs-comment">// reachable off the system stack transitively from</span>
                <span class="hljs-comment">// startm.</span>
                systemstack(<span class="hljs-keyword">func</span>() {
                    stackfree(freem.g0.stack)
                })
            }
            freem = freem.freelink
        }
        sched.freem = newList
        unlock(&amp;sched.lock)
    }

    <span class="hljs-comment">// &#x521B;&#x5EFA;&#x65B0;&#x7684;M</span>
    mp := <span class="hljs-built_in">new</span>(m)
    mp.mstartfn = fn
    mcommoninit(mp, id)

    <span class="hljs-comment">// In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack.</span>
    <span class="hljs-comment">// Windows and Plan 9 will layout sched stack on OS stack.</span>
    <span class="hljs-comment">// &#x5206;&#x914D; g0 &#x6808;</span>
    <span class="hljs-comment">// g0 &#x662F;&#x6BCF;&#x4E2A; M &#x7684;&#x7279;&#x6B8A; Goroutine&#xFF0C;&#x8D1F;&#x8D23;&#x6267;&#x884C;&#x8C03;&#x5EA6;&#x76F8;&#x5173;&#x7684;&#x5DE5;&#x4F5C;&#x3002;</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x662F; cgo &#x6216;&#x7279;&#x5B9A;&#x5E73;&#x53F0;&#xFF08;Solaris&#x3001;illumos&#x3001;Darwin&#xFF09;&#xFF0C;&#x6808;&#x4F1A;&#x7531; pthread_create &#x521B;&#x5EFA;&#x3002;&#x5426;&#x5219;&#xFF0C;Go &#x4F1A;&#x624B;&#x52A8;&#x4E3A; g0 &#x5206;&#x914D;&#x6808;&#x3002;</span>
    <span class="hljs-keyword">if</span> iscgo || mStackIsSystemAllocated() {
        mp.g0 = malg(<span class="hljs-number">-1</span>)
    } <span class="hljs-keyword">else</span> {
        mp.g0 = malg(<span class="hljs-number">8192</span> * sys.StackGuardMultiplier)
    }
    mp.g0.m = mp

    <span class="hljs-comment">// &#x91CA;&#x653E;P&#x548C;M</span>
    <span class="hljs-keyword">if</span> pp == gp.m.p.ptr() {
        releasep()
    }

    releasem(gp.m)
    allocmLock.runlock()
    <span class="hljs-keyword">return</span> mp
}
</code></pre>
<pre><code class="lang-go"><span class="hljs-keyword">func</span> newm1(mp *m) {
    <span class="hljs-keyword">if</span> iscgo {
        <span class="hljs-keyword">var</span> ts cgothreadstart
        <span class="hljs-keyword">if</span> _cgo_thread_start == <span class="hljs-literal">nil</span> {
            throw(<span class="hljs-string">&quot;_cgo_thread_start missing&quot;</span>)
        }
        ts.g.set(mp.g0)
        ts.tls = (*<span class="hljs-keyword">uint64</span>)(unsafe.Pointer(&amp;mp.tls[<span class="hljs-number">0</span>]))
        ts.fn = unsafe.Pointer(abi.FuncPCABI0(mstart))
        <span class="hljs-keyword">if</span> msanenabled {
            msanwrite(unsafe.Pointer(&amp;ts), unsafe.Sizeof(ts))
        }
        <span class="hljs-keyword">if</span> asanenabled {
            asanwrite(unsafe.Pointer(&amp;ts), unsafe.Sizeof(ts))
        }
        execLock.rlock() <span class="hljs-comment">// Prevent process clone.</span>
        asmcgocall(_cgo_thread_start, unsafe.Pointer(&amp;ts))
        execLock.runlock()
        <span class="hljs-keyword">return</span>
    }
    execLock.rlock() <span class="hljs-comment">// Prevent process clone.</span>
    newosproc(mp)
    execLock.runlock()
}
</code></pre>
<p>Linux&#x4E0B;&#x7684;&#x7CFB;&#x7EDF;&#x7EBF;&#x7A0B;&#x521B;&#x5EFA;</p>
<pre><code class="lang-go">
<span class="hljs-comment">// &#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#xFF0C;&#x7528;&#x6765;&#x521B;&#x5EFA;&#x7EBF;&#x7A0B;</span>
<span class="hljs-comment">//go:noescape</span>
<span class="hljs-keyword">func</span> clone(flags <span class="hljs-keyword">int32</span>, stk, mp, gp, fn unsafe.Pointer) <span class="hljs-keyword">int32</span>

<span class="hljs-comment">// May run with m.p==nil, so write barriers are not allowed.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:nowritebarrier</span>
<span class="hljs-keyword">func</span> newosproc(mp *m) {
    stk := unsafe.Pointer(mp.g0.stack.hi)
    <span class="hljs-comment">/*
     * note: strace gets confused if we use CLONE_PTRACE here.
     */</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">false</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;newosproc stk=&quot;</span>, stk, <span class="hljs-string">&quot; m=&quot;</span>, mp, <span class="hljs-string">&quot; g=&quot;</span>, mp.g0, <span class="hljs-string">&quot; clone=&quot;</span>, abi.FuncPCABI0(clone), <span class="hljs-string">&quot; id=&quot;</span>, mp.id, <span class="hljs-string">&quot; ostk=&quot;</span>, &amp;mp, <span class="hljs-string">&quot;\n&quot;</span>)
    }

    <span class="hljs-comment">// Disable signals during clone, so that the new thread starts</span>
    <span class="hljs-comment">// with signals disabled. It will enable them in minit.</span>
    <span class="hljs-keyword">var</span> oset sigset
    <span class="hljs-comment">// &#x5728;&#x521B;&#x5EFA;&#x65B0;&#x7EBF;&#x7A0B;&#x4E4B;&#x524D;&#xFF0C;&#x9996;&#x5148;&#x4F7F;&#x7528; sigprocmask &#x5C4F;&#x853D;&#x6240;&#x6709;&#x4FE1;&#x53F7;&#x3002;</span>
    <span class="hljs-comment">// &#x8FD9;&#x662F;&#x4E3A;&#x4E86;&#x786E;&#x4FDD;&#x5728; clone &#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x65B0;&#x521B;&#x5EFA;&#x7684;&#x7EBF;&#x7A0B;&#x4E0D;&#x4F1A;&#x6536;&#x5230;&#x4EFB;&#x4F55;&#x4FE1;&#x53F7;&#xFF0C;&#x907F;&#x514D;&#x5728;&#x672A;&#x521D;&#x59CB;&#x5316;&#x5B8C;&#x6210;&#x65F6;&#x5904;&#x7406;&#x4FE1;&#x53F7;&#x3002;</span>
    <span class="hljs-comment">// &#x65B0;&#x7EBF;&#x7A0B;&#x5C06;&#x5728;&#x5176;&#x542F;&#x52A8;&#x540E;&#x81EA;&#x884C;&#x542F;&#x7528;&#x4FE1;&#x53F7;&#x5904;&#x7406;&#x3002;</span>
    sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)
    ret := retryOnEAGAIN(<span class="hljs-keyword">func</span>() <span class="hljs-keyword">int32</span> {
        <span class="hljs-comment">// &#x7EBF;&#x7A0B;&#x521B;&#x5EFA;&#x6210;&#x529F;&#x540E;&#xFF0C;&#x7ACB;&#x5373;&#x53BB;&#x8C03;&#x7528;mstart</span>
        r := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(abi.FuncPCABI0(mstart)))
        <span class="hljs-comment">// clone returns positive TID, negative errno.</span>
        <span class="hljs-comment">// We don&apos;t care about the TID.</span>
        <span class="hljs-keyword">if</span> r &gt;= <span class="hljs-number">0</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        }
        <span class="hljs-keyword">return</span> -r
    })
    <span class="hljs-comment">// clone &#x8C03;&#x7528;&#x5B8C;&#x6210;&#x540E;&#xFF0C;&#x6062;&#x590D;&#x4E4B;&#x524D;&#x4FDD;&#x5B58;&#x7684;&#x4FE1;&#x53F7;&#x5C4F;&#x853D;&#x72B6;&#x6001;&#xFF0C;&#x5141;&#x8BB8;&#x65B0;&#x7EBF;&#x7A0B;&#x63A5;&#x6536;&#x4FE1;&#x53F7;&#x3002;</span>
    sigprocmask(_SIG_SETMASK, &amp;oset, <span class="hljs-literal">nil</span>)

    <span class="hljs-comment">// &#x9519;&#x8BEF;&#x5904;&#x7406;</span>
    <span class="hljs-keyword">if</span> ret != <span class="hljs-number">0</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;runtime: failed to create new OS thread (have &quot;</span>, mcount(), <span class="hljs-string">&quot; already; errno=&quot;</span>, ret, <span class="hljs-string">&quot;)\n&quot;</span>)
        <span class="hljs-keyword">if</span> ret == _EAGAIN {
            <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;runtime: may need to increase max user processes (ulimit -u)&quot;</span>)
        }
        throw(<span class="hljs-string">&quot;newosproc&quot;</span>)
    }
}
</code></pre>
<p><span style="color: red">Go&#x521B;&#x5EFA;&#x5E95;&#x5C42;&#x7CFB;&#x7EDF;&#x7EBF;&#x7A0B;&#x65F6;&#xFF0C;&#x4F1A;&#x9884;&#x5148;&#x5206;&#x914D;&#x597D;&#x6808;&#x7A7A;&#x95F4;&#xFF0C;&#x7136;&#x540E;&#x5C06;&#x8FD9;&#x5757;&#x6808;&#x7A7A;&#x95F4;&#x7684;&#x5730;&#x5740;&#x4F20;&#x7ED9;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#xFF0C;&#x8FD9;&#x79CD;&#x81EA;&#x5B9A;&#x4E49;&#x6808;&#x7684;&#x65B9;&#x5F0F;&#x53EF;&#x4EE5;&#x66F4;&#x52A0;&#x7CBE;&#x7EC6;&#x5730;&#x63A7;&#x5236;&#x6808;&#x7684;&#x5206;&#x914D;&#xFF0C;&#x7075;&#x6D3B;&#x5730;&#x63A7;&#x5236;&#x6808;&#x7684;&#x5927;&#x5C0F;&#x548C;&#x5206;&#x914D; &#x65B9;&#x5F0F;&#x3002;</span></p>
<p><span style="color: red">&#x5F53;Go&#x8FD0;&#x884C;&#x65F6;&#x521B;&#x5EFA;&#x65B0;&#x7684;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x7EBF;&#x7A0B;&#x65F6;&#xFF0C;&#x5B83;&#x4F1A;&#x4F20;&#x9012;g0&#x6808;&#x7684;&#x6808;&#x9876;&#x5730;&#x5740;&#x7ED9;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#xFF0C;&#x8BA9;&#x65B0;&#x521B;&#x5EFA;&#x7684;&#x7EBF;&#x7A0B;&#x80FD;&#x591F;&#x6B63;&#x5E38;&#x8FD0;&#x884C;&#x3002;</span></p>
<p><span style="color: red">g0&#x6808;&#x7528;&#x4E8E;&#x7CFB;&#x7EDF;&#x7EBF;&#x7A0B;&#x7684;&#x8FD0;&#x884C;&#x65F6;&#x64CD;&#x4F5C;&#x548C;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#xFF0C;&#x800C;&#x534F;&#x7A0B;&#x8FD0;&#x884C;&#x5728;Go&#x8FD0;&#x884C;&#x65F6;&#x7BA1;&#x7406;&#x7684;&#x8F7B;&#x91CF;&#x7EA7;&#x6808;&#x4E0A;&#x3002;</span></p>
<p>M/G&#x7684;&#x89E3;&#x7ED1;</p>
<p>&#x5C06;&#x5F53;&#x524D; g &#x7684; m &#x7F6E;&#x7A7A;&#x3001;&#x5C06;&#x5F53;&#x524D; m &#x7684; g &#x7F6E;&#x7A7A;&#xFF0C;&#x4ECE;&#x800C;&#x5B8C;&#x6210;&#x89E3;&#x7ED1;&#xFF1A;</p>
<pre><code class="lang-go"><span class="hljs-comment">// dropg removes the association between m and the current goroutine m-&gt;curg (gp for short).</span>
<span class="hljs-comment">// Typically a caller sets gp&apos;s status away from Grunning and then</span>
<span class="hljs-comment">// immediately calls dropg to finish the job. The caller is also responsible</span>
<span class="hljs-comment">// for arranging that gp will be restarted using ready at an</span>
<span class="hljs-comment">// appropriate time. After calling dropg and arranging for gp to be</span>
<span class="hljs-comment">// readied later, the caller can do other work but eventually should</span>
<span class="hljs-comment">// call schedule to restart the scheduling of goroutines on this m.</span>
<span class="hljs-comment">// dropg &#x5220;&#x9664; m &#x4E0E;&#x5F53;&#x524D; Goroutine m-&gt;curg&#xFF08;&#x7B80;&#x79F0; gp&#xFF09;&#x4E4B;&#x95F4;&#x7684;&#x5173;&#x8054;&#x3002;</span>
<span class="hljs-comment">// &#x901A;&#x5E38;&#xFF0C;&#x8C03;&#x7528;&#x8005;&#x5C06; gp &#x7684;&#x72B6;&#x6001;&#x8BBE;&#x7F6E;&#x4E3A;&#x8FDC;&#x79BB; Grunning&#xFF0C;&#x7136;&#x540E;&#x7ACB;&#x5373;&#x8C03;&#x7528; dropg &#x6765;&#x5B8C;&#x6210;&#x5DE5;&#x4F5C;&#x3002;</span>
<span class="hljs-comment">// &#x8C03;&#x7528;&#x8005;&#x8FD8;&#x8D1F;&#x8D23;&#x5B89;&#x6392;gp &#x5728;&#x9002;&#x5F53;&#x7684;&#x65F6;&#x95F4;&#x4F7F;&#x7528;ready &#x91CD;&#x65B0;&#x542F;&#x52A8;&#x3002;</span>
<span class="hljs-comment">// &#x5728;&#x8C03;&#x7528; dropg &#x5E76;&#x5B89;&#x6392; gp &#x7A0D;&#x540E;&#x51C6;&#x5907;&#x597D;&#x4E4B;&#x540E;&#xFF0C;&#x8C03;&#x7528;&#x8005;&#x53EF;&#x4EE5;&#x505A;&#x5176;&#x4ED6;&#x5DE5;&#x4F5C;&#xFF0C;&#x4F46;&#x6700;&#x7EC8;&#x5E94;&#x8BE5;&#x8C03;&#x7528; Schedule &#x6765;&#x91CD;&#x65B0;&#x542F;&#x52A8;&#x6B64; m &#x4E0A;&#x7684; goroutine &#x7684;&#x8C03;&#x5EA6;&#x3002;</span>
<span class="hljs-keyword">func</span> dropg() {
    gp := getg()

    setMNoWB(&amp;gp.m.curg.m, <span class="hljs-literal">nil</span>)
    setGNoWB(&amp;gp.m.curg, <span class="hljs-literal">nil</span>)
}

<span class="hljs-comment">// setMNoWB performs *mp = new without a write barrier.</span>
<span class="hljs-comment">// For times when it&apos;s impractical to use an muintptr.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// setMNoWB &#x5F53;&#x4F7F;&#x7528; muintptr &#x4E0D;&#x53EF;&#x884C;&#x65F6;&#xFF0C;&#x5728;&#x6CA1;&#x6709; write barrier &#x4E0B;&#x6267;&#x884C; *mp = new</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-comment">//go:nowritebarrier</span>
<span class="hljs-keyword">func</span> setMNoWB(mp **m, <span class="hljs-built_in">new</span> *m) {
    (*muintptr)(unsafe.Pointer(mp)).set(<span class="hljs-built_in">new</span>)
}

<span class="hljs-comment">// setGNoWB performs *gp = new without a write barrier.</span>
<span class="hljs-comment">// For times when it&apos;s impractical to use a guintptr.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// setGNoWB &#x5F53;&#x4F7F;&#x7528; guintptr &#x4E0D;&#x53EF;&#x884C;&#x65F6;&#xFF0C;&#x5728;&#x6CA1;&#x6709; write barrier &#x4E0B;&#x6267;&#x884C; *gp = new</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-comment">//go:nowritebarrier</span>
<span class="hljs-keyword">func</span> setGNoWB(gp **g, <span class="hljs-built_in">new</span> *g) {
    (*guintptr)(unsafe.Pointer(gp)).set(<span class="hljs-built_in">new</span>)
}
</code></pre>
<p>M&#x7684;&#x6B7B;&#x4EA1;</p>
<p> m &#x5F53;&#x4E14;&#x4EC5;&#x5F53;&#x5B83;&#x6240;&#x8FD0;&#x884C;&#x7684; Goroutine &#x88AB;&#x9501;&#x5B9A;&#x5728;&#x8BE5; m &#x4E14; Goroutine &#x9000;&#x51FA;&#x540E;&#xFF0C; m &#x624D;&#x4F1A;&#x9000;&#x51FA;&#x3002;</p>
<p>&#x53EA;&#x6709; linux &#x4E2D;&#x624D;&#x53EF;&#x80FD;&#x6B63;&#x5E38;&#x7684;&#x9000;&#x51FA;&#x4E00;&#x4E2A;&#x6808;&#xFF0C;&#x800C; darwin &#x53EA;&#x80FD;&#x4FDD;&#x6301;&#x6682;&#x6B62;&#x4E86;&#x3002; &#x800C;&#x5982;&#x679C;&#x662F;&#x4E3B;&#x7EBF;&#x7A0B;&#xFF0C;&#x5219;&#x4F1A;&#x59CB;&#x7EC8;&#x4FDD;&#x6301; park&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// mexit tears down and exits the current thread.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Don&apos;t call this directly to exit the thread, since it must run at</span>
<span class="hljs-comment">// the top of the thread stack. Instead, use gogo(&amp;gp.m.g0.sched) to</span>
<span class="hljs-comment">// unwind the stack to the point that exits the thread.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// It is entered with m.p != nil, so write barriers are allowed. It</span>
<span class="hljs-comment">// will release the P before exiting.</span>
<span class="hljs-comment">// mexit &#x9500;&#x6BC1;&#x5E76;&#x9000;&#x51FA;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x8BF7;&#x4E0D;&#x8981;&#x76F4;&#x63A5;&#x8C03;&#x7528;&#x6765;&#x9000;&#x51FA;&#x7EBF;&#x7A0B;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x5FC5;&#x987B;&#x5728;&#x7EBF;&#x7A0B;&#x6808;&#x9876;&#x4E0A;&#x8FD0;&#x884C;&#x3002;</span>
<span class="hljs-comment">// &#x76F8;&#x53CD;&#xFF0C;&#x8BF7;&#x4F7F;&#x7528; gogo(&amp;_g_.m.g0.sched) &#x6765;&#x89E3;&#x9664;&#x6808;&#x5E76;&#x9000;&#x51FA;&#x7EBF;&#x7A0B;&#x3002;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x5F53;&#x8C03;&#x7528;&#x65F6;&#xFF0C;m.p != nil&#x3002;&#x56E0;&#x6B64;&#x53EF;&#x4EE5;&#x4F7F;&#x7528; write barrier&#x3002;</span>
<span class="hljs-comment">// &#x5728;&#x9000;&#x51FA;&#x524D;&#x5B83;&#x4F1A;&#x91CA;&#x653E;&#x5F53;&#x524D;&#x7ED1;&#x5B9A;&#x7684; P&#x3002;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x53EA;&#x6709; linux &#x4E2D;&#x624D;&#x53EF;&#x80FD;&#x6B63;&#x5E38;&#x7684;&#x9000;&#x51FA;&#x4E00;&#x4E2A;&#x6808;&#xFF0C;&#x800C; darwin &#x53EA;&#x80FD;&#x4FDD;&#x6301;&#x6682;&#x6B62;&#x4E86;&#x3002; &#x800C;&#x5982;&#x679C;&#x662F;&#x4E3B;&#x7EBF;&#x7A0B;&#xFF0C;&#x5219;&#x4F1A;&#x59CB;&#x7EC8;&#x4FDD;&#x6301; park&#x3002;</span>
<span class="hljs-comment">//go:yeswritebarrierrec</span>
<span class="hljs-keyword">func</span> mexit(osStack <span class="hljs-keyword">bool</span>) {
    mp := getg().m

    <span class="hljs-keyword">if</span> mp == &amp;m0 {
        <span class="hljs-comment">// This is the main thread. Just wedge it.</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// On Linux, exiting the main thread puts the process</span>
        <span class="hljs-comment">// into a non-waitable zombie state. On Plan 9,</span>
        <span class="hljs-comment">// exiting the main thread unblocks wait even though</span>
        <span class="hljs-comment">// other threads are still running. On Solaris we can</span>
        <span class="hljs-comment">// neither exitThread nor return from mstart. Other</span>
        <span class="hljs-comment">// bad things probably happen on other platforms.</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// We could try to clean up this M more before wedging</span>
        <span class="hljs-comment">// it, but that complicates signal handling.</span>
        <span class="hljs-comment">// &#x4E3B;&#x7EBF;&#x7A0B;</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// &#x5728; linux &#x4E2D;&#xFF0C;&#x9000;&#x51FA;&#x4E3B;&#x7EBF;&#x7A0B;&#x4F1A;&#x5BFC;&#x81F4;&#x8FDB;&#x7A0B;&#x53D8;&#x4E3A;&#x50F5;&#x5C38;&#x8FDB;&#x7A0B;&#x3002;</span>
        <span class="hljs-comment">// &#x5728; plan 9 &#x4E2D;&#xFF0C;&#x9000;&#x51FA;&#x4E3B;&#x7EBF;&#x7A0B;&#x5C06;&#x53D6;&#x6D88;&#x963B;&#x585E;&#x7B49;&#x5F85;&#xFF0C;&#x5373;&#x4F7F;&#x5176;&#x4ED6;&#x7EBF;&#x7A0B;&#x4ECD;&#x5728;&#x8FD0;&#x884C;&#x3002;</span>
        <span class="hljs-comment">// &#x5728; Solaris &#x4E2D;&#x6211;&#x4EEC;&#x65E2;&#x4E0D;&#x80FD; exitThread &#x4E5F;&#x4E0D;&#x80FD;&#x8FD4;&#x56DE;&#x5230; mstart &#x4E2D;&#x3002;</span>
        <span class="hljs-comment">// &#x5176;&#x4ED6;&#x7CFB;&#x7EDF;&#x4E0A;&#x53EF;&#x80FD;&#x53D1;&#x751F;&#x522B;&#x7684;&#x7CDF;&#x7CD5;&#x7684;&#x4E8B;&#x60C5;&#x3002;</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// &#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x5C1D;&#x8BD5;&#x9000;&#x51FA;&#x4E4B;&#x524D;&#x6E05;&#x7406;&#x5F53;&#x524D; M &#xFF0C;&#x4F46;&#x4FE1;&#x53F7;&#x5904;&#x7406;&#x975E;&#x5E38;&#x590D;&#x6742;</span>
        handoffp(releasep()) <span class="hljs-comment">// &#x8BA9;&#x51FA; P</span>
        lock(&amp;sched.lock)    <span class="hljs-comment">// &#x9501;&#x4F4F;&#x8C03;&#x5EA6;&#x5668;</span>
        sched.nmfreed++
        checkdead()
        unlock(&amp;sched.lock)
        mPark() <span class="hljs-comment">// &#x6682;&#x6B62;&#x4E3B;&#x7EBF;&#x7A0B;&#xFF0C;&#x5728;&#x6B64;&#x963B;&#x585E;</span>
        throw(<span class="hljs-string">&quot;locked m0 woke up&quot;</span>)
    }

    sigblock(<span class="hljs-literal">true</span>)
    unminit()

    <span class="hljs-comment">// Free the gsignal stack.</span>
    <span class="hljs-comment">// &#x91CA;&#x653E; gsignal &#x6808;</span>
    <span class="hljs-keyword">if</span> mp.gsignal != <span class="hljs-literal">nil</span> {
        stackfree(mp.gsignal.stack)
        <span class="hljs-comment">// On some platforms, when calling into VDSO (e.g. nanotime)</span>
        <span class="hljs-comment">// we store our g on the gsignal stack, if there is one.</span>
        <span class="hljs-comment">// Now the stack is freed, unlink it from the m, so we</span>
        <span class="hljs-comment">// won&apos;t write to it when calling VDSO code.</span>
        mp.gsignal = <span class="hljs-literal">nil</span>
    }

    <span class="hljs-comment">// Remove m from allm.</span>
    <span class="hljs-comment">// &#x5C06; m &#x4ECE; allm &#x4E2D;&#x79FB;&#x9664;</span>
    lock(&amp;sched.lock)
    <span class="hljs-keyword">for</span> pprev := &amp;allm; *pprev != <span class="hljs-literal">nil</span>; pprev = &amp;(*pprev).alllink {
        <span class="hljs-keyword">if</span> *pprev == mp {
            *pprev = mp.alllink
            <span class="hljs-keyword">goto</span> found
        }
    }
    <span class="hljs-comment">// &#x5982;&#x679C;&#x6CA1;&#x627E;&#x5230;&#x5219;&#x662F;&#x5F02;&#x5E38;&#x72B6;&#x6001;&#xFF0C;&#x8BF4;&#x660E; allm &#x7BA1;&#x7406;&#x51FA;&#x9519;</span>
    throw(<span class="hljs-string">&quot;m not found in allm&quot;</span>)
found:
    <span class="hljs-comment">// Delay reaping m until it&apos;s done with the stack.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Put mp on the free list, though it will not be reaped while freeWait</span>
    <span class="hljs-comment">// is freeMWait. mp is no longer reachable via allm, so even if it is</span>
    <span class="hljs-comment">// on an OS stack, we must keep a reference to mp alive so that the GC</span>
    <span class="hljs-comment">// doesn&apos;t free mp while we are still using it.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Note that the free list must not be linked through alllink because</span>
    <span class="hljs-comment">// some functions walk allm without locking, so may be using alllink.</span>
    mp.freeWait.Store(freeMWait)
    mp.freelink = sched.freem
    sched.freem = mp
    unlock(&amp;sched.lock)

    atomic.Xadd64(&amp;ncgocall, <span class="hljs-keyword">int64</span>(mp.ncgocall))

    <span class="hljs-comment">// Release the P.</span>
    handoffp(releasep())
    <span class="hljs-comment">// After this point we must not have write barriers.</span>

    <span class="hljs-comment">// Invoke the deadlock detector. This must happen after</span>
    <span class="hljs-comment">// handoffp because it may have started a new M to take our</span>
    <span class="hljs-comment">// P&apos;s work.</span>
    lock(&amp;sched.lock)
    sched.nmfreed++
    checkdead()
    unlock(&amp;sched.lock)

    <span class="hljs-keyword">if</span> GOOS == <span class="hljs-string">&quot;darwin&quot;</span> || GOOS == <span class="hljs-string">&quot;ios&quot;</span> {
        <span class="hljs-comment">// Make sure pendingPreemptSignals is correct when an M exits.</span>
        <span class="hljs-comment">// For #41702.</span>
        <span class="hljs-keyword">if</span> mp.signalPending.Load() != <span class="hljs-number">0</span> {
            pendingPreemptSignals.Add(<span class="hljs-number">-1</span>)
        }
    }

    <span class="hljs-comment">// Destroy all allocated resources. After this is called, we may no</span>
    <span class="hljs-comment">// longer take any locks.</span>
    <span class="hljs-comment">// &#x9500;&#x6BC1;&#x6240;&#x6709;&#x5206;&#x914D;&#x7684;&#x8D44;&#x6E90;&#x3002;&#x8C03;&#x7528;&#x6B64;&#x65B9;&#x6CD5;&#x540E;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x4E0D;&#x518D;&#x4F7F;&#x7528;&#x4EFB;&#x4F55;&#x9501;&#x3002;</span>
    mdestroy(mp)

    <span class="hljs-keyword">if</span> osStack {
        <span class="hljs-comment">// No more uses of mp, so it is safe to drop the reference.</span>
        mp.freeWait.Store(freeMRef)

        <span class="hljs-comment">// Return from mstart and let the system thread</span>
        <span class="hljs-comment">// library free the g0 stack and terminate the thread.</span>
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-comment">// mstart is the thread&apos;s entry point, so there&apos;s nothing to</span>
    <span class="hljs-comment">// return to. Exit the thread directly. exitThread will clear</span>
    <span class="hljs-comment">// m.freeWait when it&apos;s done with the stack and the m can be</span>
    <span class="hljs-comment">// reaped.</span>
    exitThread(&amp;mp.freeWait)
}
</code></pre>
<h2 id="5&#x3001;&#x7EBF;&#x7A0B;&#x7BA1;&#x7406;">5&#x3001;&#x7EBF;&#x7A0B;&#x7BA1;&#x7406;</h2>
<p>Go&#x8BED;&#x8A00;&#x4E13;&#x95E8;&#x5C06;&#x7EBF;&#x7A0B;&#x8FDB;&#x4E00;&#x6B65;&#x62BD;&#x8C61;&#x4E3A;&#x534F;&#x7A0B;&#xFF0C;&#x6240;&#x4EE5;&#x4E0D;&#x5E0C;&#x671B;&#x7528;&#x6237;&#x5BF9;&#x7EBF;&#x7A0B;&#x505A;&#x8FC7;&#x591A;&#x7684;&#x64CD;&#x4F5C;&#x3002;&#x5927;&#x90E8;&#x5206;&#x7684;&#x7528;&#x6237;&#x4EE3;&#x7801;&#x5E76;&#x4E0D;&#x9700;&#x8981;&#x7EBF;&#x7A0B;&#x7EA7;&#x7684;&#x64CD;&#x4F5C;&#x3002;</p>
<p>&#x5728;&#x67D0;&#x4E9B;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x5F53;&#x9700;&#x8981;&#x4F7F;&#x7528;cgo&#x8C03;&#x7528;C&#x7AEF;&#x56FE;&#x5F62;&#x5E93;&#xFF08;&#x5982;GLib&#xFF09;&#x65F6;&#xFF0C;&#x751A;&#x81F3;&#x9700;&#x8981;&#x5C06;&#x67D0;&#x4E2A;&#x534F;&#x7A0B;&#x7528;&#x6237;&#x6001;&#x4EE3;&#x7801;&#x4E00;&#x76F4;&#x5728;&#x4E3B;&#x7EBF;&#x7A0B;&#x4E0A;&#x6267;&#x884C;&#x3002;</p>
<p>&#x5728;<code>runtime.LockOSThread</code>&#x4F1A;&#x5C06;&#x5F53;&#x524D;&#x7684;&#x534F;&#x7A0B;&#x9501;&#x5728;&#x4E00;&#x4E2A;&#x56FA;&#x5B9A;&#x7684;&#x7CFB;&#x7EDF;&#x7EBF;&#x7A0B;&#x4E0A;&#x6267;&#x884C;&#xFF0C;&#x4F46;&#x662F;&#x4E00;&#x65E6;&#x5F00;&#x653E;&#x9501;&#x4F4F;&#x67D0;&#x4E2A;&#x7CFB;&#x7EDF;&#x7EBF;&#x7A0B;&#x540E;&#xFF0C;&#x4F1A;&#x4EA7;&#x751F;&#x4E00;&#x4E9B;&#x526F;&#x4F5C;&#x7528;&#xFF0C;&#x6BD4;&#x5982;&#x7CFB;&#x7EDF;&#x7EA7;&#x7684;&#x7F16;&#x7A0B;&#x5B9E;&#x73B0;&#x603B;&#x662F;&#x9700;&#x8981;&#x5BF9;&#x7EBF;&#x7A0B;&#x8FDB;&#x884C;&#x64CD;&#x4F5C;&#xFF0C;&#x5C24;&#x5176;&#x5F53;&#x7528;&#x6237;&#x6001;&#x4EE3;&#x7801;&#x901A;&#x8FC7;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x4F7F;&#x5F97;&#x7EBF;&#x7A0B;&#x79C1;&#x6709;&#x5316;&#x65F6;&#xFF0C;&#x5176;&#x4ED6;&#x7684;&#x534F;&#x7A0B;&#x5DF2;&#x7ECF;&#x4E0D;&#x9002;&#x5408;&#x5728;&#x6B64;&#x7CFB;&#x7EDF;&#x7EBF;&#x7A0B;&#x4E0A;&#x6267;&#x884C;&#x4E86;&#xFF0C;&#x8FD9;&#x65F6;&#x5019;&#x4E0D;&#x5F97;&#x4E0D;&#x5C06;M&#x6C38;&#x4E45;&#x5730;&#x4ECE;&#x8FD0;&#x884C;&#x65F6;&#x79FB;&#x9664;&#x3002;</p>
<p>&#x79C1;&#x6709;&#x7684;lockOSThread&#x5728;&#x6574;&#x4E2A;&#x8FD0;&#x884C;&#x65F6;&#x53EA;&#x6709;&#x5728;<code>runtime.main</code> &#x8C03;&#x7528; <code>main.init</code> &#x3001;&#x548C; cgo &#x7684; C &#x8C03;&#x7528; Go &#x65F6;&#x5019;&#x624D;&#x4F1A;&#x4F7F;&#x7528;&#xFF0C; &#x5176;&#x4E2D; <code>main.init</code> &#x5176;&#x5B9E;&#x4E5F;&#x662F;&#x4E3A;&#x4E86; cgo &#x91CC; Go &#x8C03;&#x7528;&#x67D0;&#x4E9B; C &#x56FE;&#x5F62;&#x5E93;&#x65F6;&#x9700;&#x8981;&#x4E3B;&#x7EBF;&#x7A0B;&#x652F;&#x6301;&#x624D;&#x4F7F;&#x7528;&#x7684;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// src/runtime/proc.go</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-keyword">func</span> lockOSThread() {
    getg().m.lockedInt++
    dolockOSThread()
}

<span class="hljs-comment">// dolockOSThread is called by LockOSThread and lockOSThread below</span>
<span class="hljs-comment">// after they modify m.locked. Do not allow preemption during this call,</span>
<span class="hljs-comment">// or else the m might be different in this function than in the caller.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// dolockOSThread &#x5728;&#x4FEE;&#x6539; m.locked &#x540E;&#x7531; LockOSThread &#x548C; lockOSThread &#x8C03;&#x7528;&#x3002;</span>
<span class="hljs-comment">// &#x5728;&#x6B64;&#x8C03;&#x7528;&#x671F;&#x95F4;&#x4E0D;&#x5141;&#x8BB8;&#x62A2;&#x5360;&#xFF0C;&#x5426;&#x5219;&#x6B64;&#x51FD;&#x6570;&#x4E2D;&#x7684; m &#x53EF;&#x80FD;&#x4E0E;&#x8C03;&#x7528;&#x8005;&#x4E2D;&#x7684; m &#x4E0D;&#x540C;&#x3002;</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-keyword">func</span> dolockOSThread() {
    <span class="hljs-keyword">if</span> GOARCH == <span class="hljs-string">&quot;wasm&quot;</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-comment">// no threads on wasm yet</span>
    }
    gp := getg()
    <span class="hljs-comment">// &#x5C06;g&#x548C;m&#x4E92;&#x76F8;&#x9501;&#x5B9A;</span>
    gp.m.lockedg.set(gp)
    gp.lockedm.set(gp.m)
}
</code></pre>
<p>&#x5BF9;&#x7528;&#x6237;&#x6001;&#x516C;&#x5F00;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x52A0;&#x9501;&#x7684;&#x65F6;&#x5019;&#x589E;&#x52A0;&#x4E86;&#x6A21;&#x7248;&#x7EBF;&#x7A0B;&#x673A;&#x5236;&#xFF0C;&#x53EA;&#x6709;&#x5F53;&#x9700;&#x8981;&#x7684;&#x65F6;&#x5019;&#x624D;&#x4F1A;&#x61D2;&#x52A0;&#x8F7D;&#x3002;</p>
<p>&#x89E3;&#x9501;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x53EA;&#x662F;&#x51CF;&#x5C11;&#x8BA1;&#x6570;&#xFF0C;&#x7B80;&#x5355;&#x5730;&#x5C06;&#x9501;&#x5B57;&#x6BB5;lockedg/lockedm&#x6E05;&#x96F6;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// LockOSThread wires the calling goroutine to its current operating system thread.</span>
<span class="hljs-comment">// The calling goroutine will always execute in that thread,</span>
<span class="hljs-comment">// and no other goroutine will execute in it,</span>
<span class="hljs-comment">// until the calling goroutine has made as many calls to</span>
<span class="hljs-comment">// UnlockOSThread as to LockOSThread.</span>
<span class="hljs-comment">// If the calling goroutine exits without unlocking the thread,</span>
<span class="hljs-comment">// the thread will be terminated.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// All init functions are run on the startup thread. Calling LockOSThread</span>
<span class="hljs-comment">// from an init function will cause the main function to be invoked on</span>
<span class="hljs-comment">// that thread.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// A goroutine should call LockOSThread before calling OS services or</span>
<span class="hljs-comment">// non-Go library functions that depend on per-thread state.</span>
<span class="hljs-keyword">func</span> LockOSThread() {
    <span class="hljs-keyword">if</span> atomic.Load(&amp;newmHandoff.haveTemplateThread) == <span class="hljs-number">0</span> &amp;&amp; GOOS != <span class="hljs-string">&quot;plan9&quot;</span> {
        <span class="hljs-comment">// If we need to start a new thread from the locked</span>
        <span class="hljs-comment">// thread, we need the template thread. Start it now</span>
        <span class="hljs-comment">// while we&apos;re in a known-good state.</span>
        <span class="hljs-comment">// &#x5F00;&#x59CB;&#x4E00;&#x4E2A;&#x6A21;&#x7248;&#x7EBF;&#x7A0B;</span>
        startTemplateThread()
    }
    gp := getg()
    gp.m.lockedExt++
    <span class="hljs-keyword">if</span> gp.m.lockedExt == <span class="hljs-number">0</span> {
        gp.m.lockedExt--
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;LockOSThread nesting overflow&quot;</span>)
    }
    dolockOSThread()
}

<span class="hljs-comment">//go:nosplit</span>

<span class="hljs-comment">// UnlockOSThread undoes an earlier call to LockOSThread.</span>
<span class="hljs-comment">// If this drops the number of active LockOSThread calls on the</span>
<span class="hljs-comment">// calling goroutine to zero, it unwires the calling goroutine from</span>
<span class="hljs-comment">// its fixed operating system thread.</span>
<span class="hljs-comment">// If there are no active LockOSThread calls, this is a no-op.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Before calling UnlockOSThread, the caller must ensure that the OS</span>
<span class="hljs-comment">// thread is suitable for running other goroutines. If the caller made</span>
<span class="hljs-comment">// any permanent changes to the state of the thread that would affect</span>
<span class="hljs-comment">// other goroutines, it should not call this function and thus leave</span>
<span class="hljs-comment">// the goroutine locked to the OS thread until the goroutine (and</span>
<span class="hljs-comment">// hence the thread) exits.</span>
<span class="hljs-keyword">func</span> UnlockOSThread() {
    gp := getg()
    <span class="hljs-keyword">if</span> gp.m.lockedExt == <span class="hljs-number">0</span> {
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-comment">// &#x51CF;&#x5C11;&#x8BA1;&#x6570;</span>
    gp.m.lockedExt--
    dounlockOSThread()
}

<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-keyword">func</span> unlockOSThread() {
    gp := getg()
    <span class="hljs-keyword">if</span> gp.m.lockedInt == <span class="hljs-number">0</span> {
        systemstack(badunlockosthread)
    }
    <span class="hljs-comment">// &#x51CF;&#x5C11;&#x8BA1;&#x6570;</span>
    gp.m.lockedInt--
    dounlockOSThread()
}

<span class="hljs-comment">// dounlockOSThread is called by UnlockOSThread and unlockOSThread below</span>
<span class="hljs-comment">// after they update m-&gt;locked. Do not allow preemption during this call,</span>
<span class="hljs-comment">// or else the m might be in different in this function than in the caller.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// dounlockOSThread &#x5728;&#x66F4;&#x65B0; m-&gt;locked &#x540E;&#x7531; UnlockOSThread &#x548C; unlockOSThread &#x8C03;&#x7528;&#x3002;</span>
<span class="hljs-comment">// &#x5728;&#x6B64;&#x8C03;&#x7528;&#x671F;&#x95F4;&#x4E0D;&#x5141;&#x8BB8;&#x62A2;&#x5360;&#xFF0C;&#x5426;&#x5219;&#x6B64;&#x51FD;&#x6570;&#x4E2D;&#x7684; m &#x53EF;&#x80FD;&#x4E0E;&#x8C03;&#x7528;&#x8005;&#x4E2D;&#x7684; m &#x4E0D;&#x540C;&#x3002;</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-keyword">func</span> dounlockOSThread() {
    <span class="hljs-keyword">if</span> GOARCH == <span class="hljs-string">&quot;wasm&quot;</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-comment">// no threads on wasm yet</span>
    }
    gp := getg()
    <span class="hljs-keyword">if</span> gp.m.lockedInt != <span class="hljs-number">0</span> || gp.m.lockedExt != <span class="hljs-number">0</span> {
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-comment">// &#x9501;&#x5B57;&#x6BB5;&#x6E05;&#x96F6;</span>
    gp.m.lockedg = <span class="hljs-number">0</span>
    gp.lockedm = <span class="hljs-number">0</span>
}
</code></pre>
<p><span style="color: red">&#x8BBE;&#x7F6E; lockedg &#x548C; lockedm &#x4E4B;&#x540E;&#x5C31;&#x80FD;&#x4FDD;&#x8BC1; g &#x53EA;&#x5728;&#x4E00;&#x4E2A; m &#x4E0A;&#x6267;&#x884C;&#x3002;</span></p>
<pre><code class="lang-go"><span class="hljs-comment">// &#x8C03;&#x5EA6;&#x5668;&#x7684;&#x4E00;&#x8F6E;&#xFF1A;&#x627E;&#x5230; runnable Goroutine &#x5E76;&#x8FDB;&#x884C;&#x6267;&#x884C;&#x4E14;&#x6C38;&#x4E0D;&#x8FD4;&#x56DE;</span>
<span class="hljs-keyword">func</span> schedule() {
    _g_ := getg()

    <span class="hljs-keyword">if</span> _g_.m.locks != <span class="hljs-number">0</span> {
        throw(<span class="hljs-string">&quot;schedule: holding locks&quot;</span>)
    }

    <span class="hljs-comment">// m.lockedg &#x4F1A;&#x5728; lockosthread &#x4E0B;&#x53D8;&#x4E3A;&#x975E;&#x96F6;</span>
    <span class="hljs-keyword">if</span> _g_.m.lockedg != <span class="hljs-number">0</span> {
        stoplockedm()
        execute(_g_.m.lockedg.ptr(), <span class="hljs-literal">false</span>) <span class="hljs-comment">// &#x6C38;&#x4E0D;&#x8FD4;&#x56DE;</span>
    }
    ...
}
</code></pre>
<p>&#x8C03;&#x5EA6;&#x5FAA;&#x73AF;&#x5728;&#x53D1;&#x73B0;&#x5F53;&#x524D;&#x7684; m &#x5B58;&#x5728;&#x8BF7;&#x6C42;&#x9501;&#x4F4F;&#x6267;&#x884C;&#x7684; g &#x65F6;&#xFF0C;&#x4E0D;&#x4F1A;&#x8FDB;&#x5165;&#x540E;&#x7EED; g &#x7684;&#x5077;&#x53D6;&#x8FC7;&#x7A0B;&#xFF0C; &#x76F8;&#x53CD;&#x4F1A;&#x76F4;&#x63A5;&#x8C03;&#x7528; <code>stoplockedm</code>&#xFF0C;&#x5C06;&#x5F53;&#x524D;&#x7684; m &#x548C; p &#x89E3;&#x7ED1;&#xFF0C;&#x5E76; park &#x5F53;&#x524D;&#x7684; m&#xFF0C; &#x76F4;&#x5230;&#x53EF;&#x4EE5;&#x518D;&#x6B21;&#x8C03;&#x5EA6; lockedg &#x4E3A;&#x6B62;&#xFF0C;&#x83B7;&#x53D6; p &#x5E76;&#x901A;&#x8FC7; <code>execute</code> &#x76F4;&#x63A5;&#x8C03;&#x5EA6; lockedg &#xFF0C; &#x4ECE;&#x800C;&#x518D;&#x6B21;&#x8FDB;&#x5165;&#x8C03;&#x5EA6;&#x5FAA;&#x73AF;&#xFF1A;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Stops execution of the current m that is locked to a g until the g is runnable again.</span>
<span class="hljs-comment">// Returns with acquired P.</span>
<span class="hljs-comment">// &#x505C;&#x6B62;&#x5F53;&#x524D;&#x6B63;&#x5728;&#x6267;&#x884C;&#x9501;&#x4F4F;&#x7684; g &#x7684; m &#x7684;&#x6267;&#x884C;&#xFF0C;&#x76F4;&#x5230; g &#x91CD;&#x65B0;&#x53D8;&#x4E3A; runnable&#x3002;</span>
<span class="hljs-comment">// &#x8FD4;&#x56DE;&#x83B7;&#x5F97;&#x7684; P</span>
<span class="hljs-keyword">func</span> stoplockedm() {
    gp := getg()

    <span class="hljs-keyword">if</span> gp.m.lockedg == <span class="hljs-number">0</span> || gp.m.lockedg.ptr().lockedm.ptr() != gp.m {
        throw(<span class="hljs-string">&quot;stoplockedm: inconsistent locking&quot;</span>)
    }
    <span class="hljs-keyword">if</span> gp.m.p != <span class="hljs-number">0</span> {
        <span class="hljs-comment">// Schedule another M to run this p.</span>
        <span class="hljs-comment">// &#x8C03;&#x5EA6;&#x5176;&#x4ED6;M&#x6765;&#x8FD0;&#x884C;P</span>
        pp := releasep()
        handoffp(pp)
    }
    incidlelocked(<span class="hljs-number">1</span>)
    <span class="hljs-comment">// Wait until another thread schedules lockedg again.</span>
    <span class="hljs-comment">// &#x7B49;&#x5F85;&#x76F4;&#x5230;&#x5176;&#x4ED6;&#x7EBF;&#x7A0B;&#x53EF;&#x4EE5;&#x518D;&#x6B21;&#x8C03;&#x5EA6; lockedg</span>
    mPark()
    status := readgstatus(gp.m.lockedg.ptr())
    <span class="hljs-keyword">if</span> status&amp;^_Gscan != _Grunnable {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;runtime:stoplockedm: lockedg (atomicstatus=&quot;</span>, status, <span class="hljs-string">&quot;) is not Grunnable or Gscanrunnable\n&quot;</span>)
        dumpgstatus(gp.m.lockedg.ptr())
        throw(<span class="hljs-string">&quot;stoplockedm: not runnable&quot;</span>)
    }
    acquirep(gp.m.nextp.ptr())
    gp.m.nextp = <span class="hljs-number">0</span>
}
</code></pre>
<p><span style="color: red">&#x9501;&#x4F4F;&#x7CFB;&#x7EDF;&#x7EBF;&#x7A0B;&#x5E26;&#x6765;&#x7684;&#x9690;&#x60A3;&#x5C31;&#x662F;&#x67D0;&#x4E2A;&#x7EBF;&#x7A0B;&#x7684;&#x72B6;&#x6001;&#x53EF;&#x80FD;&#x88AB;&#x7528;&#x6237;&#x6001;&#x4EE3;&#x7801;&#x8FC7;&#x5206;&#x7684;&#x4FEE;&#x6539;&#xFF0C; &#x4ECE;&#x800C;&#x4E0D;&#x518D;&#x5177;&#x6709;&#x4EA7;&#x51FA;&#x65B0;&#x7EBF;&#x7A0B;&#x7684;&#x80FD;&#x529B;&#xFF0C;&#x6A21;&#x677F;&#x7EBF;&#x7A0B;&#x5C31;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x4E2A;&#x5907;&#x7528;&#x7EBF;&#x7A0B;&#xFF0C;&#x4E0D;&#x4F1A;&#x6267;&#x884C; g&#xFF0C;&#x53EA;&#x7528;&#x4E8E;&#x521B;&#x5EFA;&#x5B89;&#x5168;&#x7684; m&#x3002;</span></p>
<pre><code class="lang-go"><span class="hljs-comment">// startTemplateThread starts the template thread if it is not already</span>
<span class="hljs-comment">// running.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// The calling thread must itself be in a known-good state.</span>
<span class="hljs-comment">// &#x5982;&#x679C;&#x6A21;&#x677F;&#x7EBF;&#x7A0B;&#x5C1A;&#x672A;&#x8FD0;&#x884C;&#xFF0C;&#x5219;startTemplateThread&#x5C06;&#x542F;&#x52A8;&#x5B83;&#x3002;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x8C03;&#x7528;&#x7EBF;&#x7A0B;&#x672C;&#x8EAB;&#x5FC5;&#x987B;&#x5904;&#x4E8E;&#x5DF2;&#x77E5;&#x826F;&#x597D;&#x72B6;&#x6001;&#x3002;</span>
<span class="hljs-keyword">func</span> startTemplateThread() {
    <span class="hljs-keyword">if</span> GOARCH == <span class="hljs-string">&quot;wasm&quot;</span> { <span class="hljs-comment">// no threads on wasm yet</span>
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-comment">// Disable preemption to guarantee that the template thread will be</span>
    <span class="hljs-comment">// created before a park once haveTemplateThread is set.</span>
    mp := acquirem()
    <span class="hljs-keyword">if</span> !atomic.Cas(&amp;newmHandoff.haveTemplateThread, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) {
        releasem(mp)
        <span class="hljs-keyword">return</span>
    }
    newm(templateThread, <span class="hljs-literal">nil</span>, <span class="hljs-number">-1</span>)
    releasem(mp)
}
</code></pre>
<p><code>tempalteThread</code> &#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x4F1A;&#x5728; m &#x6B63;&#x5F0F;&#x542F;&#x52A8;&#x65F6;&#x88AB;&#x8C03;&#x7528;&#xFF1A;</p>
<pre><code class="lang-go"><span class="hljs-comment">// &#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684; m. &#x5B83;&#x4F1A;&#x542F;&#x52A8;&#x5E76;&#x8C03;&#x7528; fn &#x6216;&#x8C03;&#x5EA6;&#x5668;</span>
<span class="hljs-comment">// fn &#x5FC5;&#x987B;&#x662F;&#x9759;&#x6001;&#x3001;&#x975E;&#x5806;&#x4E0A;&#x5206;&#x914D;&#x7684;&#x95ED;&#x5305;</span>
<span class="hljs-comment">// &#x5B83;&#x53EF;&#x80FD;&#x5728; m.p==nil &#x65F6;&#x8FD0;&#x884C;&#xFF0C;&#x56E0;&#x6B64;&#x4E0D;&#x5141;&#x8BB8; write barrier</span>
<span class="hljs-comment">//go:nowritebarrierrec</span>
<span class="hljs-keyword">func</span> newm(fn <span class="hljs-keyword">func</span>(), _p_ *p) {
    <span class="hljs-comment">// &#x5206;&#x914D;&#x4E00;&#x4E2A; m</span>
    mp := allocm(_p_, fn)
    ...
}

<span class="hljs-comment">//go:yeswritebarrierrec</span>
<span class="hljs-keyword">func</span> allocm(_p_ *p, fn <span class="hljs-keyword">func</span>()) *m {
    ...
    mp := <span class="hljs-built_in">new</span>(m)
    mp.mstartfn = fn
    ...
}

<span class="hljs-keyword">func</span> mstart1() {
    ...

    <span class="hljs-comment">// &#x6267;&#x884C;&#x542F;&#x52A8;&#x51FD;&#x6570;</span>
    <span class="hljs-keyword">if</span> fn := _g_.m.mstartfn; fn != <span class="hljs-literal">nil</span> {
        fn()
    }

    ...
}
</code></pre>
<p>&#x8FD9;&#x4E2A; <code>newmHandoff</code> &#x8D1F;&#x8D23;&#x5E76;&#x4E32;&#x8054;&#x4E86;&#x6240;&#x6709;&#x65B0;&#x521B;&#x5EFA;&#x7684; m&#xFF1A;</p>
<pre><code class="lang-go"><span class="hljs-comment">// newmHandoff &#x5305;&#x542B;&#x9700;&#x8981;&#x65B0; OS &#x7EBF;&#x7A0B;&#x7684; m &#x7684;&#x5217;&#x8868;&#x3002;</span>
<span class="hljs-comment">// &#x5728; newm &#x672C;&#x8EAB;&#x65E0;&#x6CD5;&#x5B89;&#x5168;&#x542F;&#x52A8; OS &#x7EBF;&#x7A0B;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;newm &#x4F1A;&#x4F7F;&#x7528;&#x5B83;&#x3002;</span>
<span class="hljs-keyword">var</span> newmHandoff <span class="hljs-keyword">struct</span> {
    lock mutex

    <span class="hljs-comment">// newm &#x6307;&#x5411;&#x9700;&#x8981;&#x65B0; OS &#x7EBF;&#x7A0B;&#x7684;M&#x7ED3;&#x6784;&#x5217;&#x8868;&#x3002; &#x8BE5;&#x5217;&#x8868;&#x901A;&#x8FC7; m.schedlink &#x94FE;&#x63A5;&#x3002;</span>
    newm muintptr

    <span class="hljs-comment">// waiting &#x8868;&#x793A;&#x5F53; m &#x5217;&#x5165;&#x5217;&#x8868;&#x65F6;&#x9700;&#x8981;&#x901A;&#x77E5;&#x5524;&#x9192;&#x3002;</span>
    waiting <span class="hljs-keyword">bool</span>
    wake    note

    <span class="hljs-comment">// haveTemplateThread &#x8868;&#x793A; templateThread &#x5DF2;&#x7ECF;&#x542F;&#x52A8;&#x3002;&#x6CA1;&#x6709;&#x9501;&#x4FDD;&#x62A4;&#xFF0C;&#x4F7F;&#x7528; cas &#x8BBE;&#x7F6E;&#x4E3A; 1&#x3002;</span>
    haveTemplateThread <span class="hljs-keyword">uint32</span>
}
</code></pre>
<p>&#x800C;&#x6A21;&#x677F;&#x7EBF;&#x7A0B;&#x672C;&#x8EAB;&#x4E0D;&#x4F1A;&#x9000;&#x51FA;&#xFF0C;&#x53EA;&#x4F1A;&#x5728;&#x9700;&#x8981;&#x7684;&#x65F6;&#xFF0C;&#x521B;&#x5EFA; m&#xFF1A;</p>
<pre><code class="lang-go"><span class="hljs-comment">// templateThread is a thread in a known-good state that exists solely</span>
<span class="hljs-comment">// to start new threads in known-good states when the calling thread</span>
<span class="hljs-comment">// may not be in a good state.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Many programs never need this, so templateThread is started lazily</span>
<span class="hljs-comment">// when we first enter a state that might lead to running on a thread</span>
<span class="hljs-comment">// in an unknown state.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// templateThread runs on an M without a P, so it must not have write</span>
<span class="hljs-comment">// barriers.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// templateThread&#x662F;&#x5904;&#x4E8E;&#x5DF2;&#x77E5;&#x826F;&#x597D;&#x72B6;&#x6001;&#x7684;&#x7EBF;&#x7A0B;&#xFF0C;&#x4EC5;&#x5F53;&#x8C03;&#x7528;&#x7EBF;&#x7A0B;&#x53EF;&#x80FD;&#x4E0D;&#x662F;&#x826F;&#x597D;&#x72B6;&#x6001;&#x65F6;&#xFF0C;</span>
<span class="hljs-comment">// &#x8BE5;&#x7EBF;&#x7A0B;&#x4EC5;&#x7528;&#x4E8E;&#x5728;&#x5DF2;&#x77E5;&#x826F;&#x597D;&#x72B6;&#x6001;&#x4E0B;&#x542F;&#x52A8;&#x65B0;&#x7EBF;&#x7A0B;&#x3002;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x8BB8;&#x591A;&#x7A0B;&#x5E8F;&#x4E0D;&#x9700;&#x8981;&#x8FD9;&#x4E2A;&#xFF0C;&#x6240;&#x4EE5;&#x5F53;&#x6211;&#x4EEC;&#x7B2C;&#x4E00;&#x6B21;&#x8FDB;&#x5165;&#x53EF;&#x80FD;&#x5BFC;&#x81F4;&#x5728;&#x672A;&#x77E5;&#x72B6;&#x6001;&#x7684;&#x7EBF;&#x7A0B;&#x4E0A;&#x8FD0;&#x884C;&#x7684;&#x72B6;&#x6001;&#x65F6;&#xFF0C;</span>
<span class="hljs-comment">// templateThread&#x4F1A;&#x61D2;&#x542F;&#x52A8;&#x3002;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// templateThread &#x5728;&#x6CA1;&#x6709; P &#x7684; M &#x4E0A;&#x8FD0;&#x884C;&#xFF0C;&#x56E0;&#x6B64;&#x5B83;&#x5FC5;&#x987B;&#x6CA1;&#x6709;&#x5199;&#x969C;&#x788D;&#x3002;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x6A21;&#x7248;&#x7EBF;&#x7A0B;&#x672C;&#x8EAB;&#x4E0D;&#x4F1A;&#x9000;&#x51FA;&#xFF0C;&#x53EA;&#x4F1A;&#x5728;&#x9700;&#x8981;&#x7684;&#x65F6;&#x5019;&#x521B;&#x5EFA;M</span>
<span class="hljs-comment">//go:nowritebarrierrec</span>
<span class="hljs-keyword">func</span> templateThread() {
    lock(&amp;sched.lock)
    sched.nmsys++
    checkdead()
    unlock(&amp;sched.lock)

    <span class="hljs-keyword">for</span> {
        lock(&amp;newmHandoff.lock)
        <span class="hljs-keyword">for</span> newmHandoff.newm != <span class="hljs-number">0</span> {
            newm := newmHandoff.newm.ptr()
            newmHandoff.newm = <span class="hljs-number">0</span>
            unlock(&amp;newmHandoff.lock)
            <span class="hljs-keyword">for</span> newm != <span class="hljs-literal">nil</span> {
                next := newm.schedlink.ptr()
                newm.schedlink = <span class="hljs-number">0</span>
                newm1(newm)
                newm = next
            }
            lock(&amp;newmHandoff.lock)
        }
        <span class="hljs-comment">// &#x7B49;&#x5F85;&#x65B0;&#x7684;&#x521B;&#x5EFA;&#x8BF7;&#x6C42;</span>
        newmHandoff.waiting = <span class="hljs-literal">true</span>
        noteclear(&amp;newmHandoff.wake)
        unlock(&amp;newmHandoff.lock)
        <span class="hljs-comment">// &#x521B;&#x5EFA;&#x597D;&#x540E;&#x6A21;&#x7248;&#x7EBF;&#x7A0B;&#x4F1A;&#x4F11;&#x7720;</span>
        notesleep(&amp;newmHandoff.wake)
    }
}
</code></pre>
<p>LockOSThread &#x5E76;&#x4E0D;&#x662F;&#x4EC0;&#x4E48;&#x4F18;&#x79C0;&#x7684;&#x7279;&#x6027;&#xFF0C;&#x76F8;&#x53CD;&#x5B83;&#x5374;&#x7ED9; Go &#x8FD0;&#x884C;&#x65F6;&#x8C03;&#x5EA6;&#x5668;&#x5E26;&#x6765;&#x4E86;&#x8BF8;&#x591A;&#x7BA1;&#x7406;&#x4E0A;&#x7684;&#x96BE;&#x9898;&#x3002; &#x5B83;&#x7684;&#x5B58;&#x5728;&#x4EC5;&#x4EC5;&#x53EA;&#x662F;&#x9700;&#x8981;&#x63D0;&#x4F9B;&#x5BF9;&#x4E0A;&#x4E2A;&#x4E16;&#x7EAA; C &#x7F16;&#x5199;&#x7684;&#x8BF8;&#x591A;&#x9057;&#x4EA7;&#x63D0;&#x4F9B;&#x5FC5;&#x8981;&#x652F;&#x6301;&#xFF0C;&#x5018;&#x82E5; Go &#x7684;&#x57FA;&#x7840;&#x5E93;&#x80FD;&#x591F;&#x66F4;&#x52A0;&#x4E30;&#x5BCC;&#xFF0C; &#x8FD9;&#x9879;&#x7279;&#x6027;&#x53EF;&#x80FD;&#x4E0D;&#x590D;&#x5B58;&#x5728;&#x3002;</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="内存一致模型.html" class="navigation navigation-prev " aria-label="Previous page: 内存一致模型">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../node/" class="navigation navigation-next " aria-label="Next page: Node">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"并发调度","level":"1.2.18","depth":2,"next":{"title":"Node","level":"1.3","depth":1,"path":"node/README.md","ref":"node/README.md","articles":[{"title":"相关问题","level":"1.3.1","depth":2,"path":"node/相关问题.md","ref":"node/相关问题.md","articles":[]}]},"previous":{"title":"内存一致模型","level":"1.2.17","depth":2,"path":"go/内存一致模型.md","ref":"go/内存一致模型.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"go/并发调度.md","mtime":"2024-10-12T03:32:08.763Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2024-11-15T10:00:56.746Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

