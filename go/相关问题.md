# 相关问题

### 1、map不可以拷贝

如果想要拷贝map，只可以循环赋值。

如果含有指针，则需要进行深拷贝。

如果value是一个结构体，可以直接替换结构体，但无法更新结构体内部的值。



### 2、slice复制陷阱

slice3 := slice2[:]

上述拷贝为浅拷贝，slice3和slice2是同一个切片，无论改动哪个，另一个都会发生改变



### 3、go的map中不含某个键时，会被计算为对应类型的零值。



### 4、go语言中不存在未初始化的变量。



### 5、任何类型的指针的零值都是nil。指针之间可以进行相等测试，只有当它们指向同一个变量或全部为nil时才相等。



### 6、flag包可以使用命令行参数来设置对应变量的值。



### 7、在任何情况下，运行时不会发生转换失败的错误（错误只会发生在编译阶段）。

底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。



### 8、对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者将一个浮点数转为整数，可能会改变数值或丢失精度。

<span style='color:red'>浮点数到整数的转换将丢失任何小数部分，向数轴零方向截断。</span>



### 9、printf细节

```go
// %之后的[1]副词告诉Printf函数再次使用第一个操作数
fmt.Printf("%[1]c, %[1]q", '互')
```



### 10、浮点数

计算机浮点数表示：https://zhuanlan.zhihu.com/p/358417700

一个float32类型的浮点数可以提供大约6个十进制数的精度，float64可以提供约15个十进制数的精度，通常应该优先使用float64类型，float32类型的计算误差很容易扩散，并且float32能精确表示的正整数并不是很大。

<span style='color:red'>（float32的有效bit位只有23个，其他bit位用于指数和符号，当整数大于23位能表达的范围时，float32的表示将出现误差）</span>

```go
var f float32 = 16777216 // 1 << 24
fmt.Println(f == f+1)    // "true"!
```

math包提供大量常用的数学函数，还提供IEEE754浮点数标准中定义特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果，还有NaN非数，一般用于表示无效的除法操作结果0/0或者Sqrt(-1)。

```go
var z float64
fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
```

函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值，虽然可以用math.NaN表示一个非法的结果，<span style='color:red'>但是测试一个结果是否是非数则是充满风险的，因为NaN和任何数都是不相等的（在浮点数中，NaN，正无穷大和负无穷大都不是唯一的，每个都有非常多种bit模式表示）。</span>

```go
nan := math.NaN()
fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
```

如果函数返回的浮点数结果可能失败，最好的做法是用单独的标志报告失败。



### 11、原生的字符串面值形式是``，使用反引号代替双引号。在原生的字符串面值中，没有转义操作，全部的内容都是字面意思，包含退格和换行，因此一个程序的原生字符串面值可以跨越多行。

在原生字符串面值内部是无法直接写`字符的，可以采用+"`"来连接字符串完成。

唯一的特殊处理是会删除回车以保证在所有平台的值都是一样的，包括那些 把回车也放入文本文件中的系统（windows）。

```go
rawString := `This is a raw string with a ` + "`" + ` (backtick) inside!`
fmt.Println(rawString)
```



### 12、常量表达式的值是在编译期计算的，而不是在运行期，每种常量的潜在类型都是基础类型。

iota

```go
const (
    _ = 1 << (10 * iota)
    KiB // 1024
    MiB // 1048576
    GiB // 1073741824
    TiB // 1099511627776             (exceeds 1 << 32)
    PiB // 1125899906842624
    EiB // 1152921504606846976
    ZiB // 1180591620717411303424    (exceeds 1 << 64)
    YiB // 1208925819614629174706176
)
```



### 13、无类型常量：只有常量可以是无类型的

go中许多常量并没有明确的基础类型，包含6种 

无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串

编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算数运算，可以认为至少有256bit的运算精度。

通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且<span style='color:red'>可以直接用于更多的表达式而不需要显式的类型转换。</span>

```go
var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
```

当一个无类型常量被赋值给一个变量的时候

1）出现在有明确类型的变量的声明的右边，转换合法的话，无类型的常量将会被隐式转换为对应的类型。

```go
var f float64 = 3 + 0i // untyped complex -> float64
f = 2                  // untyped integer -> float64
f = 1e123              // untyped floating-point -> float64
f = 'a'                // untyped rune -> float64
```

2）对于一个没有显式类型的变量声明，常量形势将隐式决定变量的默认类型

```go
i := 0      // untyped integer;        implicit int(0)
r := '\000' // untyped rune;           implicit rune('\000')
f := 0.0    // untyped floating-point; implicit float64(0.0)
c := 0i     // untyped complex;        implicit complex128(0i)
```

无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。如果不知道浮点数类型的内存大小很难写出正确的数值算法，go不存在整数类似的不确定内存大小的浮点数和复数类型。



### 14、当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个赋值的副本，并不是原始调用的变量。

​	<span style='color:red'>在这种机制下，会导致传递大的数组类型将是低效的，并且数组参数的任何的修改都将发生在复制的数组上，并不能直接修改调用时原始的数组变量。</span>

​	在这个方面，go对待数组和方式和其他编程语言不同。

​	go中的数组包含僵化的长度信息，不同长度的数组代表不同的类型。

```go
// [16]byte 的类型与 [32]byte 的类型并不相同
```



### 15、如果切片操作超出了cap上限将导致一个panic异常，但是超过len(s)则是意味着扩展了slice，新的slice长度会变大

```go
months := [...]string{1: "January", 2: "February", 3: "March", 4: "April",
        5: "May", 6: "June", 7: "July", 8: "August",
        9: "September", 10: "October", 11: "November", 12: "December"}
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // ["April" "May" "June"]
fmt.Println(summer) // ["June" "July" "August"]
// fmt.Println(summer[:20]) // panic: out of range
endlessSummer := summer[:5] // extend a slice (within capacity)
fmt.Println(endlessSummer)  // "[June July August September October]"
```



### 16、slice之间不可以比较，但是数组可以。

​	<span style='color:red'>在操作slice时不能使用==符号来判断两个slice是否有全部相等元素，必须自己展开每个元素进行比较</span>

```go
func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
```

​	在运行的时间方面并不比支持==操作的数组字符串更多，主要的原因有两个

- 一个slice元素是间接引用的，一个slice元素甚至可以包括自身（[]interface{}），没有一个简单有效的办法处理这种情况。
- 由于slice是间接引用的，一个固定的slice值在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改。<span style='color:red'>在Go语言中map的key只做简单的浅拷贝，key仅支持可以比较的类型，并且要求key在整个周期内保持不变性，slice在扩容时会导致本身的值/地址发生变化，所以key不可以使用slice</span>，显然，map的key在这种场合并不合适。

​	<span style='color:red'>slice的唯一合法比较操作是和nil进行比较</span>，一个零值的slice等于nil，一个nil值的slice并没有底层数组，一个nil值的slice的长度和容量都为0.

```go
if summer == nil { /* ... */ }
```

​		如果需要判断slice是否为空，应该使用len(s) == 0来判断，不应该使用s == nil来判断。

​		一个nil值的slice的行为和其他任意0长度的slice一样



### 17、make函数创建slice

​	可以创建一个指定元素类型、长度、容量的slice，容量部分可以省略，在这种情况下，容量等于长度

```go
// 这种情况下，slice使整个数组的view
make([]T, len)
// 这种情况下，slice只引用了
make([]T, len, cap) // same as make([]T, cap)[:len]
```

​	在底层，make创建了一个匿名的数组变量，然后返回一个slice，只有通过返回的slice才能引用底层匿名的数组变量。



### 18、nil可以强转为任意类型赋值给变量

```go
var s []int    // len(s) == 0, s == nil
s = nil        // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{}    // len(s) == 0, s != nil
```



### 19、append

​	通常并不知道append调用是否导致了内存的重新分配，因此不能确认新的slice和原始的slice是否引用了相同的底层数组空间，也不能确认原先slice上的操作是否会影响到新的slice。



### 20、map中的元素并不是一个变量，不能对map的元素进行取址操作

​	禁止对map元素取址的原因是可能随着元素数量的增长而重新分配更大的内存空间，可能导致之前的地址失效

```Go
_ = &ages["bob"] // compile error: cannot take address of map element
```



### 21、map上的大部分操作，包括<span style='color:red'>查找，删除、len和range循环</span>都可以工作在nil值的map上，它们的行为和一个空map类似。<span style='color:red'>但是向一个nil值的map存入一个元素将导致panic异常</span>

在向map存数据前必须创建map。查询失败将返回对应类型的零值

```Go
ages["carol"] = 21 // panic: assignment to entry in nil map
```



### 22、和slice一样，map之间不能进行相等比较。



### 23、有时需要一个map或set的key是一个slice类型，但是map的key必须是可比较的类型，slice不可以，可以通过以下方案来绕过这个限制。

​	1）定义一个辅助函数k，将slice转为map对应的string类型的key，确保x和y相等时，k(x) == k(y)。

​	2）创建一个key为string类型的map，在每次对map操作时先用辅助函数将slice转化为string类型。



### 24、结构体类型的零值是每个成员都是零值。



### 25、如果结构体没有任何成员的话就是空结构体，写作struct{}，它的大小为0，不包含任何信息，但是有时候依然有价值。

​	比如，当用map来模拟set数据结构时，用来代替map中布尔类型的value值，只是强调key的重要性，但是节约的空间有限，语法也较为复杂，通常避免这样使用。

```Go
seen := make(map[string]struct{}) // set of strings
// ...
if _, ok := seen[s]; !ok {
    seen[s] = struct{}{}
    // ...first time seeing s...
}
```



### 26、结构体可以作为函数的参数和返回值。

​	考虑到效率，较大的结构体通常会用指针的方式传入和返回。

​	<span style='color:red'>如果需要在函数内部修改结构体成员，指针传入是必须的。在go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量</span>



### 27、如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体可以使用==或者!=运算符进行比较。

```Go
type Point struct{ X, Y int }

p := Point{1, 2}
q := Point{2, 1}
fmt.Println(p.X == q.X && p.Y == q.Y) // "false"
fmt.Println(p == q)                   // "false"
```

​	可比较的结构体类型和其他可比较的类型一样，可用于map的key类型

```Go
type address struct {
    hostname string
    port     int
}

hits := make(map[address]int)
hits[address{"golang.org", 443}]++
```



### 28、go的结构体可以进行匿名嵌入，我们可以直接访问叶子属性而不需要给出完整的路径，其中匿名成员也都有自己的名字，就是命名的类型的名字。这些名字在点操作符中是可选的。在访问子成员的时候可以忽略任何匿名成员部分。

​	匿名成员也存在一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，会导致名字冲突。

​	匿名成员如果不可导出，那么在包外部也就不可以访问嵌套的匿名成员。

​	<span style='color:red'>结构体字面值并没有简短表示匿名成员的语法</span>

```Go
type Point struct {
    X, Y int
}

type Circle struct {
    Point
    Radius int
}

type Wheel struct {
    Circle
    Spokes int
}

w = Wheel{8, 8, 5, 20}                       // compile error: unknown fields
w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields
```



### 29、text/template和html/template，提供一个将变量值填充到一个文本或html格式的模版的机制。

```Go
const templ = `{{.TotalCount}} issues:
{{range .Items}}----------------------------------------
Number: {{.Number}}
User:   {{.User.Login}}
Title:  {{.Title | printf "%.64s"}}
Age:    {{.CreatedAt | daysAgo}} days
{{end}}`
```



### 30、函数类型的零值是nil，调用值为nil的函数值会引起panic错误。

```Go
var f func(int) int
    f(3) // 此处f的值为nil, 会引起panic错误
```

​	函数值可以和nil进行比较，但是函数值之间是不可比较的，也不能用函数值作为map的key



### 31、匿名内部函数可以访问和更新局部变量，因为函数值属于引用类型。所以函数值不可比较。

​	go使用闭包技术来实现函数值。在go中变量的生命周期不由它的作用域决定

```Go
// squares返回一个匿名函数。
// 该匿名函数每次被调用时都会返回下一个数的平方。
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    fmt.Println(f()) // "1"
    fmt.Println(f()) // "4"
    fmt.Println(f()) // "9"
    fmt.Println(f()) // "16"
}
```



### 32、defer语句中的函数会在return语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值在内的所有变量，对匿名函数采用defer机制，可以使其观察函数的返回值。



### 33、函数名中带有Must前缀不能接受不合法的输入，是一种针对此类函数的命名约定。



### 34、runtime包允许程序员输出堆栈信息。

​	<span style='color:red'>在Go的Panic机制中，延迟函数的调用在释放堆栈信息之前，所以能输出已经被释放函数的信息</span>

```Go
func main() {
    defer printStack()
    f(3)
}
func printStack() {
    var buf [4096]byte
    n := runtime.Stack(buf[:], false)
    os.Stdout.Write(buf[:n])
}
```



### 35、nil也是一个合法的接收器类型

```go
// An IntList is a linked list of integers.
// A nil *IntList represents the empty list.
type IntList struct {
    Value int
    Tail  *IntList
}
// Sum returns the sum of the list elements.
func (list *IntList) Sum() int {
    if list == nil {
        return 0
    }
    return list.Value + list.Tail.Sum()
}
```



### 36、方法值和方法表达式

​	通常在使用go时，经常会选择一个方法，并在同一个表达式里使用。

​	事实上可以分为两步来执行，先选择具体函数，然后执行。

```go
p := Point{1, 2}
q := Point{4, 6}

distanceFromP := p.Distance        // method value
fmt.Println(distanceFromP(q))      // "5"
var origin Point                   // {0, 0}
fmt.Println(distanceFromP(origin)) // "2.23606797749979", sqrt(5)

scaleP := p.ScaleBy // method value
scaleP(2)           // p becomes (2, 4)
scaleP(3)           //      then (6, 12)
scaleP(10)          //      then (60, 120)
```



### 37、封装优点

1、因为调用方不能直接修改对象的变量值，只需关注少量的语句并且只要弄懂部分变量的值即可。

2、隐藏实现细节，防止调用方依赖可能变化的具体实现。

3、阻止了外部调用方对对象内部的值任意进行修改.



### 38、在go语言中，变量总被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都为nil。

​	可以通过使用判断是否等于nil来判断接口值是否为空。<span style='color:red'>调用一个空接口值的任意方法都会产生panic。</span>

```go
var w io.Writer
w = os.Stdout // 调用了一个具体类型到接口类型的隐式转换，和显式使用io.Writer(os.Stdout)是等价的
w = new(bytes.Buffer)
w = nil // 恢复到和它之前定义时相同的状态
```

​	<span style='color:red'>通常在编译期，不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配</span>



### 39、不论接口值多大，动态值总是可以容下它。接口类型是非常与众不同的。其他类型要么是安全的可比较类型，要么是完全不可比较的类型（切片，映射和函数），但是在比较接口值或者包含接口值的聚合类型时，必须意识到潜在的Panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。

接口值可以使用==和！=来进行比较。两个接口值相等仅当它们都是nil值，或者他们的动态类型相同，并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。

<span style='color:red'>如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且Panic</span>

```go
var x interface{} = []int{1, 2, 3}
fmt.Println(x == x) // panic: comparing uncomparable type []int
```



### 40、一个包含nil指针的接口不是nil接口

一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。

只有在类型值和动态值都是nil的时候才等于nil接口值。

```go
const debug = true

func main() {
    var buf *bytes.Buffer
    if debug {
        buf = new(bytes.Buffer) // enable collection of output
    }
    f(buf) // NOTE: subtly incorrect!
    if debug {
        // ...use buf...
    }
}

// If out is non-nil, output will be written to it.
func f(out io.Writer) {
    // ...do something...
    if out != nil {
        out.Write([]byte("done!\n")) // debug为false时会发生panic
    }
}
```

```go
// 正确方式
var buf io.Writer
if debug {
    buf = new(bytes.Buffer) // enable collection of output
}
f(buf) // OK
```



### 41、sort.Reverse

采用组合思想。sort包定义了一个不公开的struct类型reverse，它嵌入了一个sort.Interface。reverse的Less方法调用了内嵌的sort.Interface值的Less方法，但是通过交换索引的方式使排序结果变成逆序。

```go
package sort

type reverse struct{ Interface } // that is, sort.Interface

func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) }

func Reverse(data Interface) Interface { return reverse{data} }
```



### 42、适配器：让函数值满足一个接口的适配器。

```go
package http

// 函数适配器
type HandlerFunc func(w ResponseWriter, r *Request)

func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
```



### 43、syscall包提供了Go语言底层系统调用API。在多个平台上，它定义了一个实现error接口的数字类型Errno，并且在Unix平台上，Errno的Error方法会从一个字符串表中查找错误信息。

```go
package syscall

type Errno uintptr // operating system error code

var errors = [...]string{
    1:   "operation not permitted",   // EPERM
    2:   "no such file or directory", // ENOENT
    3:   "no such process",           // ESRCH
    // ...
}

func (e Errno) Error() string {
    if 0 <= int(e) && int(e) < len(errors) {
        return errors[e]
    }
    return fmt.Sprintf("errno %d", e)
}
```



### 44、类型断言

是一个使用在接口值上的操作。语法上x.(T)被称为断言类型，x表示一个接口类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言类型匹配。

如果断言的类型T是一个具体的类型，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。

具体类型的类型断言从它的操作对象中获取具体的值，检查失败会抛出panic。

```go
var w io.Writer
w = os.Stdout
f := w.(*os.File)      // success: f == os.Stdout
c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer
```

<span style='color:red'>如果类型断言的T是一个接口类型，类型断言检查是否x的动态类型满足T。如果检查成功，动态值没有获取到，这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T，对于一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合，但是保留了接口值内部的动态类型和值的部分</span>

```go
// w和rw都持有os.Stdout，因此都有一个动态类型*os.File，但w只对外公开Write方法，而rw还公开了Read方法
var w io.Writer
w = os.Stdout
rw := w.(io.ReadWriter) // success: *os.File has both Read and Write
w = new(ByteCounter)
rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method
```

如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么，这个类型断言都会失败。

```go
w = rw             // io.ReadWriter is assignable to io.Writer
w = rw.(io.Writer) // fails only if rw == nil
```

采用如下操作，不会在失败的时候发生panic

```go
var w io.Writer = os.Stdout
f, ok := w.(*os.File)      // success:  ok, f == os.Stdout
b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil
```



### 45、避免不必要的抽象，一个接口只被一个单一的具体类型实现时有一个例外<span style='color:red'>就是由于它的依赖，这个具体的类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式，</span>新的类型出现的时候，小的接口更容易满足。对于接口设计的一个好的标准就是<span style='color:red'> ask only for what you need（只考虑你需要的东西）</span>



### 46、主函数返回时，所有的goroutine都会被直接打断，程序退出。除了从主函数退出或者意外终止程序之外，没有其他的编程方法能够让一个goroutine来打断另一个的执行。



### 47、两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较结果为真。



### 48、channel支持close操作，用于关闭channel。随后基于channel的任何发送操作都将导致Panic一场。对一个已经被close的channel进行接收操作依然可以接收到之前已经成功发送的数据，<span style='color:red'>如果channel中已经没有数据将产生一个零值数据。</span>



### 49、关闭网络连接中的写方向的连接将导致server程序收到一个文件结束的信号。关闭网络连接中读方向的连接将导致后台goroutine的io.Copy函数调用返回一个“read from closed connection”（“从关闭的连接读”）类似的错误。

```Go
func main() {
    conn, err := net.Dial("tcp", "localhost:8000")
    if err != nil {
        log.Fatal(err)
    }
    done := make(chan struct{})
    go func() {
        io.Copy(os.Stdout, conn) // NOTE: ignoring errors
        log.Println("done")
        done <- struct{}{} // signal the main goroutine
    }()
    mustCopy(conn, os.Stdin)
    conn.Close()
    <-done // wait for background goroutine to finish
}
```



### 50、channels可以用于将多个goroutine连接在一起，一个channel的输出作为下一个channel的输入。这种串联的channels就是管道（pipeline）。

pipeline是一种用于处理连续操作的机制，它将多个操作链接在一起，以便顺序执行。

pipeline并不是事务的，因为没有提供事务的ACID属性（原子性，一致性，隔离性和持久性）。事务是一种保证数据操作的完整性和一致性的机制，要么全部成功执行，要么全部回滚到初始状态。

相比之下，pipeline的操作是连续执行的，每个步骤的结果会传递给下一个步骤，但没有提供回滚或撤销的机制。如果pipeline中的某个步骤失败，整个流程可能就会，但之前已经执行的步骤无法自动回滚。



### 51、没有办法直接测试一个channel是否被关闭，但是接收操作有一个变体形式。

不管一个channel是否被关闭，当它没有被引用时将会被垃圾回收器回收

```Go
// Squarer
go func() {
    for {
      	// ok 为true表示成功从channel中接收到值，false表示channels已经被关闭并且没有值可接收。
        x, ok := <-naturals
        if !ok {
            break // channel was closed and drained
        }
        squares <- x * x
    }
    close(squares)
}()

go func() {
  			// range循环可直接在channels上面迭代，当channel被关闭并且没有值可接收时跳出循环。
        for x := range naturals {
            squares <- x * x
        }
        close(squares)
    }()
```



### 52、打开文件忘记关闭，会导致一些问题

1. 资源泄漏：打开的文件会占用系统资源，包括内存描述符。如果不关闭文件，这些资源将一直被占用，可能导致系统资源的浪费和不足。
2. 文件锁定：在某些操作系统中，打开的文件可能被锁定，阻止其他进该文件的访问。如果忘记关闭文件，其他进程可能无法访问或修改该文件，导致操作失败或数据不一致。
3. 内存泄漏：如果在打开文件时分配了内存，但在不关闭文件的情况下不释放内存，可能导致内存泄漏，随着时间推移，内存泄漏可能导致系统性能下降或者崩溃。
4. 数据丢失：如果在打开进行了写操作，但在不关闭文件的情况下终止程序或系统崩溃，可能导致数据丢失或者文件损坏。



### 53、当一个channel作为一个函数参数时，一般总是被专门用于只发送或者只接收。

任何双向channel向单向channel变量的赋值操作都将导致隐式转换，但是不能将一个单向型的channel转换为双向型channel。



### 54、goroutines泄漏

慢的goroutines没有人接收会产生这样的问题，泄漏的goroutines不会自动回收，因此需要确保每个不再需要的goroutine能正常退出。

防止泄漏，最好使用带合适缓存的channel。

```go
// makeThumbnails4 makes thumbnails for the specified files in parallel.
// It returns an error if any step failed.
// 当遇到第一个非nil的error时会直接将error返回调用方，使得没有一个goroutine去排空errors channel，剩下的goroutine发送值时，就会阻塞，并且永远不会退出，导致goroutine泄漏。
func makeThumbnails4(filenames []string) error {
    errors := make(chan error)

    for _, f := range filenames {
        go func(f string) {
            _, err := thumbnail.ImageFile(f)
            errors <- err
        }(f)
    }

    for range filenames {
        if err := <-errors; err != nil {
            return err // NOTE: incorrect: goroutine leak!
        }
    }

    return nil
}
```



### 55、无缓存的channel更强的保证了每个发送操作与相应的同步接收操作，对于带缓存的channel，这些操作是解耦的，根据生产各个阶段的要求选择合适的channel。



### 56、限制并发过度

1. 限制最大并发协程
2. 创建常驻协程



### 57、channel的零值是nil，nil的channel也有用处，对一个nil的channel发送和接收操作会永远阻塞，在select语句操作nil的channel永远不会被select到，所以nil的channel会在select里的case相当于禁用了。



### 58、数据竞争

<span style='color:red'>不要使用共享数据来通信，使用通信来共享数据</span>

数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作的时候发生。

避免数据竞争的方法：

1. 避免不必要的写变量。
2. 避免从多个goroutine访问变量。
3. 允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问。



### 59、互斥锁

可以使用一个带缓存的channel作为一个计数信号量，当容量只有1的时候可以保证最多只有一个goroutine在同一时刻访问一个共享变量。一个只能为1和0的信号量叫做二元信号量。

```go
var (
    sema    = make(chan struct{}, 1) // a binary semaphore guarding balance
    balance int
)

func Deposit(amount int) {
    sema <- struct{}{} // acquire token
    balance = balance + amount
    <-sema // release token
}

func Balance() int {
    sema <- struct{}{} // acquire token
    b := balance
    <-sema // release token
    return b
}

// 第二次获取互斥锁，无法被重入，go里没有重入锁。
// NOTE: incorrect!
func Withdraw(amount int) bool {
    mu.Lock()
    defer mu.Unlock()
    Deposit(-amount)
    if Balance() < 0 {
        Deposit(amount)
        return false // insufficient funds
    }
    return true
}
```

重入锁：一种同步机制，允许同一个线程多次获取锁而不会发生死锁。当一个线程已经获取锁而不会被阻塞。可重入锁是一种可重入的互斥锁，也被称为递归锁。它可以避免同一个线程对同一个锁的重复获取导致的死锁问题。

<span style='color:red'>go不支持重入锁</span>

通用解决方案是将一个函数分离为多个函数。当使用互斥锁时，确保mutex和其保护的变量没有被导出

```go
func Withdraw(amount int) bool {
    mu.Lock()
    defer mu.Unlock()
    deposit(-amount)
    if balance < 0 {
        deposit(amount)
        return false // insufficient funds
    }
    return true
}

func Deposit(amount int) {
    mu.Lock()
    defer mu.Unlock()
    deposit(amount)
}

func Balance() int {
    mu.Lock()
    defer mu.Unlock()
    return balance
}

// This function requires that the lock be held.
func deposit(amount int) { balance += amount }
```



### 60、读写锁

允许多个只读操作并行执行，但写操作完全互斥。

只有当获得锁的大部分goroutine都是读操作，读写锁才能带来好处。



### 61、内存同步

现代计算机中可能有一堆处理器，每一个都会有其本地缓存。为了效率，对内存的写入一般会在每个处理器中缓冲，并在必要时一起flush到主存。这种情况下这些数据可能会以与当初goroutine写入顺序不同的顺序被提交到主存。像channel通信或者互斥量操作这样的原语会使处理器将其聚集的写入flush并commit，这样goroutine在某个时间点上的执行结果才能被其他处理器上运行的goroutine得到。

```go
var x, y int
go func() {
    x = 1 // A1
    fmt.Print("y:", y, " ") // A2
}()
go func() {
    y = 1                   // B1
    fmt.Print("x:", x, " ") // B2
}()

// y:0 x:1
// x:0 y:1
// x:1 y:1
// y:1 x:1
// 重要
// 在不使用mutex和channel这样的显式同步操作时，没法保证事件在不同的goroutine中看到的执行顺序是一致的
// A中一定需要观察到x=1执行成功之后才会去读y，但是A没法确保自己观察得到B中对y的写入，A还可能会打印出y的一个旧值
// x:0 y:0
// y:0 x:0
```

在一个独立的goroutine中，每一个语句的执行顺序是可以保证的，也就是说goroutine内顺序是连贯的。

赋值和打印语句指向不同的变量，编译器可能会断定两条语句的顺序不会影响执行结果，并且会交换两个语句的执行顺序。

如果两个goroutine在不同的cpu上执行，每一个核心有自己的缓存，这样一个goroutine的写入对于其他goroutine的Print，在主存同步之前是不可见的。

<span style='color:red'>所有并发问题都可以用一致，简单的既定模式来规避。可能的话，将变量限定在goroutine内部；如果是goroutine都需要访问的变量，使用互斥条件来访问</span>



### 62、惰性初始化

如果初始化成本比较大，那么将初始化延迟到需要的时候再去做是一个比较好的选择，还可以减少程序启动时间，并且因为执行的时候可能不需要这些变量，可以避免产生浪费。

<span style='color:red'>当缺少显式同步时，编译器和CPU是可以随意更改访问内存的指令顺序，以任意方式，只要保证每一个goroutine自己的执行顺序一致。</span>

使用sync.Once进行惰性初始化

一次性的初始化需要一个互斥量mutex来保护boolean变量和客户端数据结构和一个boolean变量来记录初始化是不是已经完成了

```go
var loadIconsOnce sync.Once
var icons map[string]image.Image
// Concurrency-safe.
func Icon(name string) image.Image {
  	// 先判断boolean变量是否为1，不为1才会锁定mutex，不需要每次都锁定
  	// 第一次调用时，boolean变量的值为false，Do会调用并会将boolean变量设置为true，随后的调用什么都不做
    loadIconsOnce.Do(loadIcons)
    return icons[name]
}
```



### 63、Goroutines和线程

1、动态栈

每一个OS线程都有一个固定大小的内存块来做栈，一般是2MB，这个栈会用来存储当前正在被调用或挂起的函数的内部变量。固定大小的栈可能会造成很大的内存浪费，固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。<span style='color:red'>修改固定的大小可以提升空间的利用率，允许创建更多的线程，并且可以允许更深的递归调用，这两者不可同时兼备。</span>

一个goroutine会以一个很小的栈开始生命周期，一般只需要2KB，栈的大小会根据需要动态的伸缩。goroutine的栈的最大值有1GB。

2、调度

OS线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫做scheduler的内核函数。这个函数会挂起当前执行的线程并将它的寄存器内容保存到内存中，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。

因为操作系统线程是被内核所调度，所以一个线程向另一个移动需要完整的上下文切换。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行CPU的周期。

Go的运行时包含其自己的调度器，这个调度器使用了一些技术手段，比如m:n调度，因为其会在n个操作系统线程上多工m个goroutine。Go调度器的工作和内核的调度是相似的，但这个调度器只关注单独的Go程序中的goroutine。

<span style='color:red'>和操作系统的线程调度不同，Go调度器并不是用一个硬件定时器，而是被go语言建筑本身进行调度，这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低的多。</span>

3、GOMAXPROCS

go的调度器通过一个全局变量来决定会有多少个操作系统的线程同时执行Go的代码。

其默认的值是运行机器上的CPU的核心数。

在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来做调度的。

在I/O中或系统调用中或调用非Go语言函数时，是需要一个对应的操作系统线程的，但是这个全局变量不要将这些情况考虑在内。

4、Goroutine没有ID号

在大多数支持多线程的操作系统和程序语言中，当前线程会有一个独特的身份id，这个信息可以被很容易获取到，可以实现线程本地存储。

goroutine是不可以的，线程本地存储总是被滥用
