



# 关键字

## 1、defer

延迟语句，defer的语义表明，它会在函数返回、产生恐慌或者runtime.Goexit时被调用。<span style='color:red'>直觉上看，defer应该由编译器直接将需要的函数调用插入到该调用的地方，似乎是一个编译期特性，不应该存在运行时性能问题，非常类似于C++的RALL范式（当离开资源的作用域，自动执行析构函数）。但实际情况是，由于defer并没有与其依赖资源挂钩，也允许在条件、循环语句中出现，从而不再是一个作用域相关的概念，这就使得defer的语义变得相对复杂。在一些复杂情况下，无法在编译期决定有多少个defer调用。</span>

Go语言的语句在执行buildssa阶段中，会由state.stmt完成函数中各个语句SSA处理。

对于延迟语句而言，其中间表示会产生三种不同的延迟形式，第一种是最一般情况下的在堆上分配的延迟语句，第二种是允许在栈上分配的延迟语句，最后一种则是开放式编码的延迟语句。

- 堆上分配的延迟语句：在大多数情况下，defer语句会在堆上分配，以确保延迟函数在函数返回之前被正确调用。堆上分配的优点是灵活性高，但也会带来一定的性能开销，因为堆分配需要内存管理操作。堆上分配的defer需要最多的运行时支持，因而产生的运行时开销也最大。
- 栈上分配的延迟语句：在某些情况下，defer语句可以在栈上分配，从而减少堆分配的开销。栈上分配的延迟语句通常用于简单的函数调用，不涉及复杂的闭包捕获，栈上分配的延迟语句执行速度快，因为它们避免了堆分配和垃圾收集的开销。
- 开放式编码的延迟语句：这是一种编译器优化技术，编译器在生成代码时，会将延迟函数直接嵌入到返回路径中，从而避免了堆栈分配，这种方式适用于那些不需要复杂延迟函数的场景，提高了性能 ，但限制了延迟函数的灵活性。

编译阶段

```go
// src/cmd/compile/internal/gc/ssa.go
func buildssa(fn *Node, worker int) *ssa.Func {
	var s state
	...
	s.stmtList(fn.Nbody)
	...
}
func (s *state) stmtList(l Nodes) {
	for _, n := range l.Slice() { s.stmt(n) }
}
```

```go
// src/cmd/compile/internal/gc/ssa.go
func (s *state) stmt(n *Node) {
	...
	switch n.Op {
	case ODEFER:
		n := n.(*ir.GoDeferStmt)
        if base.Debug.Defer > 0 {
            // defer函数类型
            var defertype string
            if s.hasOpenDefers {
                // 开放编码式 defer
                defertype = "open-coded"
            } else if n.Esc() == ir.EscNever {
                // 栈上分配的defer
                defertype = "stack-allocated"
            } else {
                // 堆上分配的defer
                defertype = "heap-allocated"
            }
            base.WarnfAt(n.Pos(), "%s defer", defertype)
        }
        // 执行函数结束时需要执行所记录的defer代码块
        if s.hasOpenDefers {
            // 开放式编码处理
            s.openDeferRecord(n.Call.(*ir.CallExpr))
        } else {
            // 默认堆分配
            d := callDefer
            // 逃逸分析，成功采用栈分配
            // defer在循环嵌套里会分配在堆上
            if n.Esc() == ir.EscNever {
                d = callDeferStack
            }
            s.callResult(n.Call.(*ir.CallExpr), d)
        }
	case ...
	}
	...
}
```

state.call调用会生成用于记录延迟调用参数的指令，并创建一个deferproc的调用指令，而后在state.exit调用在函数返回前插入deferreturn调用指令。

```go
// src/cmd/compile/internal/ssagen/ssa.go
// Calls the function n using the specified call type.
// Returns the address of the return value (or nil if none).
// 用于处理函数调用的方法，包括普通调用、尾调用、defer调用和go调用
func (s *state) call(n *ir.CallExpr, k callKind, returnResultAddr bool) *ssa.Value {
    s.prevCall = nil
    var callee *ir.Name    // target function (if static) 调用目标
    var closure *ssa.Value // ptr to closure to run (if dynamic) 闭包
    var codeptr *ssa.Value // ptr to target code (if dynamic) 代码指针
    var rcvr *ssa.Value    // receiver to set 接收者
    fn := n.X
    var ACArgs []*types.Type    // AuxCall args 辅助调用的参数类型
    var ACResults []*types.Type // AuxCall results 辅助调用的结果类型
    var callArgs []*ssa.Value   // For late-expansion, the args themselves (not stored, args to the call instead).

    callABI := s.f.ABIDefault

    // 如果调用类型不是普通调用或尾调用，并且有参数或是接口调用或有返回结果，则报错。
    if k != callNormal && k != callTail && (len(n.Args) != 0 || n.Op() == ir.OCALLINTER || n.X.Type().NumResults() != 0) {
        s.Fatalf("go/defer call with arguments: %v", n)
    }

    switch n.Op() {
    case ir.OCALLFUNC:
        // 静态调用，直接获取目标函数
        if (k == callNormal || k == callTail) && fn.Op() == ir.ONAME && fn.(*ir.Name).Class == ir.PFUNC {
            fn := fn.(*ir.Name)
            callee = fn
            if buildcfg.Experiment.RegabiArgs {
                // This is a static call, so it may be
                // a direct call to a non-ABIInternal
                // function. fn.Func may be nil for
                // some compiler-generated functions,
                // but those are all ABIInternal.
                if fn.Func != nil {
                    callABI = abiForFunc(fn.Func, s.f.ABI0, s.f.ABI1)
                }
            } else {
                // TODO(register args) remove after register abi is working
                inRegistersImported := fn.Pragma()&ir.RegisterParams != 0
                inRegistersSamePackage := fn.Func != nil && fn.Func.Pragma&ir.RegisterParams != 0
                if inRegistersImported || inRegistersSamePackage {
                    callABI = s.f.ABI1
                }
            }
            break
        }
        // 动态调用，获取闭包
        closure = s.expr(fn)
        if k != callDefer && k != callDeferStack {
            // Deferred nil function needs to panic when the function is invoked,
            // not the point of defer statement.
            s.maybeNilCheckClosure(closure, k)
        }
    case ir.OCALLINTER:
        // 接口调用，获取闭包和接收者
        if fn.Op() != ir.ODOTINTER {
            s.Fatalf("OCALLINTER: n.Left not an ODOTINTER: %v", fn.Op())
        }
        fn := fn.(*ir.SelectorExpr)
        var iclosure *ssa.Value
        iclosure, rcvr = s.getClosureAndRcvr(fn)
        if k == callNormal {
            codeptr = s.load(types.Types[types.TUINTPTR], iclosure)
        } else {
            closure = iclosure
        }
    }

    // 计算参数和结果的大小
    params := callABI.ABIAnalyze(n.X.Type(), false /* Do not set (register) nNames from caller side -- can cause races. */)
    types.CalcSize(fn.Type())
    stksize := params.ArgWidth() // includes receiver, args, and results

    res := n.X.Type().Results()
    if k == callNormal || k == callTail {
        for _, p := range params.OutParams() {
            ACResults = append(ACResults, p.Type)
        }
    }

    var call *ssa.Value
    if k == callDeferStack {
        // 栈上的defer
        // Make a defer struct d on the stack.
        if stksize != 0 {
            s.Fatalf("deferprocStack with non-zero stack size %d: %v", stksize, n)
        }

        t := deferstruct() // 创建defer结构
        d := typecheck.TempAt(n.Pos(), s.curfn, t)

        // 如果这个defer结构体包含指针，记录该变量的内存状态
        if t.HasPointers() {
            s.vars[memVar] = s.newValue1A(ssa.OpVarDef, types.TypeMem, d, s.mem())
        }
        // 获取defer结构体的地址
        addr := s.addr(d)

        // 在栈上预留_defer结构体各个字段的空间
        // Must match deferstruct() below and src/runtime/runtime2.go:_defer.
        // 0: started, set in deferprocStack
        // 1: heap, set in deferprocStack
        // 2: openDefer
        // 3: sp, set in deferprocStack
        // 4: pc, set in deferprocStack
        // 5: fn
        // 均采用闭包类型
        s.store(closure.Type,
            s.newValue1I(ssa.OpOffPtr, closure.Type.PtrTo(), t.FieldOff(5), addr),
            closure)
        // 6: panic, set in deferprocStack
        // 7: link, set in deferprocStack
        // 8: fd
        // 9: varp
        // 10: framepc

        // Call runtime.deferprocStack with pointer to _defer record.
        // 创建deferprocStack调用，传递 _defer 记录的指针，记录到协程栈中
        ACArgs = append(ACArgs, types.Types[types.TUINTPTR])
        aux := ssa.StaticAuxCall(ir.Syms.DeferprocStack, s.f.ABIDefault.ABIAnalyzeTypes(nil, ACArgs, ACResults))
        callArgs = append(callArgs, addr, s.mem())
        call = s.newValue0A(ssa.OpStaticLECall, aux.LateExpansionResultType(), aux)
        call.AddArgs(callArgs...)
        call.AuxInt = int64(types.PtrSize) // deferprocStack takes a *_defer arg
    } else {
        // Store arguments to stack, including defer/go arguments and receiver for method calls.
        // These are written in SP-offset order.
        argStart := base.Ctxt.Arch.FixedFrameSize
        // Defer/go args.
        // defer和go均涉及闭包
        if k != callNormal && k != callTail {
            // Write closure (arg to newproc/deferproc).
            // 把闭包函数写入newproc或deferproc中
            ACArgs = append(ACArgs, types.Types[types.TUINTPTR]) // not argExtra
            callArgs = append(callArgs, closure)
            stksize += int64(types.PtrSize)
            argStart += int64(types.PtrSize)
        }

        // Set receiver (for interface calls).
        if rcvr != nil {
            callArgs = append(callArgs, rcvr)
        }

        // Write args.
        t := n.X.Type()
        args := n.Args

        for _, p := range params.InParams() { // includes receiver for interface calls
            ACArgs = append(ACArgs, p.Type)
        }

        // Split the entry block if there are open defers, because later calls to
        // openDeferSave may cause a mismatch between the mem for an OpDereference
        // and the call site which uses it. See #49282.
        if s.curBlock.ID == s.f.Entry.ID && s.hasOpenDefers {
            b := s.endBlock()
            b.Kind = ssa.BlockPlain
            curb := s.f.NewBlock(ssa.BlockPlain)
            b.AddEdgeTo(curb)
            s.startBlock(curb)
        }

        // 放入参数
        for i, n := range args {
            callArgs = append(callArgs, s.putArg(n, t.Params().Field(i).Type))
        }

        callArgs = append(callArgs, s.mem())

        // call target
        switch {
        case k == callDefer:
            // 创建deferproc调用，记录到堆中
            aux := ssa.StaticAuxCall(ir.Syms.Deferproc, s.f.ABIDefault.ABIAnalyzeTypes(nil, ACArgs, ACResults)) // TODO paramResultInfo for DeferProc
            call = s.newValue0A(ssa.OpStaticLECall, aux.LateExpansionResultType(), aux)
        case k == callGo:
            aux := ssa.StaticAuxCall(ir.Syms.Newproc, s.f.ABIDefault.ABIAnalyzeTypes(nil, ACArgs, ACResults))
            call = s.newValue0A(ssa.OpStaticLECall, aux.LateExpansionResultType(), aux) // TODO paramResultInfo for NewProc
        case closure != nil:
            // rawLoad because loading the code pointer from a
            // closure is always safe, but IsSanitizerSafeAddr
            // can't always figure that out currently, and it's
            // critical that we not clobber any arguments already
            // stored onto the stack.
            codeptr = s.rawLoad(types.Types[types.TUINTPTR], closure)
            aux := ssa.ClosureAuxCall(callABI.ABIAnalyzeTypes(nil, ACArgs, ACResults))
            call = s.newValue2A(ssa.OpClosureLECall, aux.LateExpansionResultType(), aux, codeptr, closure)
        case codeptr != nil:
            // Note that the "receiver" parameter is nil because the actual receiver is the first input parameter.
            aux := ssa.InterfaceAuxCall(params)
            call = s.newValue1A(ssa.OpInterLECall, aux.LateExpansionResultType(), aux, codeptr)
        case callee != nil:
            aux := ssa.StaticAuxCall(callTargetLSym(callee), params)
            call = s.newValue0A(ssa.OpStaticLECall, aux.LateExpansionResultType(), aux)
            if k == callTail {
                call.Op = ssa.OpTailLECall
                stksize = 0 // Tail call does not use stack. We reuse caller's frame.
            }
        default:
            s.Fatalf("bad call type %v %v", n.Op(), n)
        }
        // 追加调用参数
        call.AddArgs(callArgs...)
        call.AuxInt = stksize // Call operations carry the argsize of the callee along with them
    }
    // 结束处理
    s.prevCall = call
    s.vars[memVar] = s.newValue1I(ssa.OpSelectN, types.TypeMem, int64(len(ACResults)), call)
    // Insert VarLive opcodes.
    for _, v := range n.KeepAlive {
        if !v.Addrtaken() {
            s.Fatalf("KeepAlive variable %v must have Addrtaken set", v)
        }
        switch v.Class {
        case ir.PAUTO, ir.PPARAM, ir.PPARAMOUT:
        default:
            s.Fatalf("KeepAlive variable %v must be Auto or Arg", v)
        }
        s.vars[memVar] = s.newValue1A(ssa.OpVarLive, types.TypeMem, v, s.mem())
    }

    // Finish block for defers
    // 结束defer块
    if k == callDefer || k == callDeferStack {
        b := s.endBlock()
        b.Kind = ssa.BlockDefer
        b.SetControl(call)
        bNext := s.f.NewBlock(ssa.BlockPlain)
        b.AddEdgeTo(bNext)
        // Add recover edge to exit code.
        r := s.f.NewBlock(ssa.BlockPlain)
        s.startBlock(r)
        s.exit()
        b.AddEdgeTo(r)
        b.Likely = ssa.BranchLikely
        s.startBlock(bNext)
    }

    // 检查返回值
    if res.NumFields() == 0 || k != callNormal {
        // call has no return value. Continue with the next statement.
        // 没有返回值或者调用类型不是普通调用，返回nil
        return nil
    }
    fp := res.Field(0)
    // 判断是返回地址还是直接返回结果
    if returnResultAddr {
        // 返回结果地址
        return s.resultAddrOfCall(call, 0, fp.Type)
    }
    // 创建一个选择节点，返回结果
    return s.newValue1I(ssa.OpSelectN, fp.Type, 0, call)
}
```

在编译的SSA阶段会翻译成两个主体。

​	deferproc：一个运行时函数，用于注册一个defer调用，当代码中使用defer语句时，Go编译器会生成对deferproc的调用，deferproc会将defer语句的调用信息保存在当前goroutine的栈中，以便在函数返回时执行这些defer语句。

​	deferreturn：也是一个运行时函数，在函数返回时被调用，以执行所有已注册的defer调用，每个注册的defer调用都会被依次执行，按照后进先出的顺序。

defer结构：

```go
// A _defer holds an entry on the list of deferred calls.
// If you add a field here, add code to clear it in deferProcStack.
// This struct must match the code in cmd/compile/internal/ssagen/ssa.go:deferstruct
// and cmd/compile/internal/ssagen/ssa.go:(*state).call.
// Some defers will be allocated on the stack and some on the heap.
// All defers are logically part of the stack, so write barriers to
// initialize them are not required. All defers must be manually scanned,
// and for heap defers, marked.
// 该结构保存延迟调用列表中的一个条目
type _defer struct {
    started bool // 两种情况会为true：panic或退出协程
    heap    bool // 堆或非堆
    // openDefer indicates that this _defer is for a frame with open-coded
    // defers. We have only one defer record for the entire frame (which may
    // currently have 0, 1, or more defers active).
    openDefer bool    // 开放代码优化
    sp        uintptr // sp at time of defer 栈指针
    pc        uintptr // pc at time of defer 程序计数器
    fn        func()  // can be nil for open-coded defers 要执行的函数（闭包形式）
    _panic    *_panic // panic that is running defer 正在运行的defer的panic
    link      *_defer // next defer on G; can point to either heap or stack! 链表指针，指向下一个defer

    // If openDefer is true, the fields below record values about the stack
    // frame and associated function that has the open-coded defer(s). sp
    // above will be the sp for the frame, and pc will be address of the
    // deferreturn call in the function.
    fd   unsafe.Pointer // funcdata for the function associated with the frame
    varp uintptr        // value of varp for the stack frame
    // framepc is the current pc associated with the stack frame. Together,
    // with sp above (which is the sp associated with the stack frame),
    // framepc/sp can be used as pc/sp pair to continue a stack trace via
    // gentraceback().
    framepc uintptr // 栈帧指针
}
```

![img](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/confluenceImport/9169811946972288116/confluenceIMG/46530617/49643543.png)

```go
// src/runtime/panic.go
// 主要用于堆中分配的延迟函数
// 将被defer调用的函数做一次记录
// Create a new deferred function fn, which has no arguments and results.
// The compiler turns a defer statement into a call to this.
func deferproc(fn func()) {
    gp := getg()
    if gp.m.curg != gp {
        // go code on the system stack can't defer
        throw("defer on system stack")
    }

    d := newdefer()
    if d._panic != nil {
        throw("deferproc: d.panic != nil after newdefer")
    }
    // 头添加
    d.link = gp._defer
    gp._defer = d
    // 保存调用该defer的goroutine的上下文
    d.fn = fn
    d.pc = getcallerpc()
    // We must not be preempted between calling getcallersp and
    // storing it to d.sp because getcallersp's result is a
    // uintptr stack pointer.
    d.sp = getcallersp()

    // deferproc returns 0 normally.
    // a deferred func that stops a panic
    // makes the deferproc return 1.
    // the code the compiler generates always
    // checks the return value and jumps to the
    // end of the function if deferproc returns != 0.
    return0()
    // No code can go here - the C return register has
    // been set and must not be clobbered.
}
```

```go
// 将新的延迟函数和相关记录记录在栈中，主要用于栈中分配的延迟函数
// deferprocStack queues a new deferred function with a defer record on the stack.
// The defer record must have its fn field initialized.
// All other fields can contain junk.
// Nosplit because of the uninitialized pointer fields on the stack.
//
//go:nosplit
func deferprocStack(d *_defer) {
    gp := getg()
    if gp.m.curg != gp {
        // go code on the system stack can't defer
        throw("defer on system stack")
    }
    // fn is already set.
    // The other fields are junk on entry to deferprocStack and
    // are initialized here.
    d.started = false
    d.heap = false
    d.openDefer = false
    d.sp = getcallersp()
    d.pc = getcallerpc()
    d.framepc = 0
    d.varp = 0
    // The lines below implement:
    //   d.panic = nil
    //   d.fd = nil
    //   d.link = gp._defer
    //   gp._defer = d
    // But without write barriers. The first three are writes to
    // the stack so they don't need a write barrier, and furthermore
    // are to uninitialized memory, so they must not use a write barrier.
    // The fourth write does not require a write barrier because we
    // explicitly mark all the defer structures, so we don't need to
    // keep track of pointers to them with a write barrier.
  	// 尽管在栈上分配，并串联链表
    *(*uintptr)(unsafe.Pointer(&d._panic)) = 0
    *(*uintptr)(unsafe.Pointer(&d.fd)) = 0
    *(*uintptr)(unsafe.Pointer(&d.link)) = uintptr(unsafe.Pointer(gp._defer))
    *(*uintptr)(unsafe.Pointer(&gp._defer)) = uintptr(unsafe.Pointer(d))

    return0()
    // No code can go here - the C return register has
    // been set and must not be clobbered.
}
```

```go
// Allocate a Defer, usually using per-P pool.
// Each defer must be released with freedefer.  The defer is not
// added to any defer chain yet.
// 在性能上，通过P或者调度器上的本地或全局defer池来复用已经在堆上分配的内存
func newdefer() *_defer {
    var d *_defer
    mp := acquirem()
    pp := mp.p.ptr()
    // p的池中没有，调度器还有，就从调度器获取
    if len(pp.deferpool) == 0 && sched.deferpool != nil {
        lock(&sched.deferlock)
        // 从全局池中获取一半defer，来填充p的本地资源
        for len(pp.deferpool) < cap(pp.deferpool)/2 && sched.deferpool != nil {
            d := sched.deferpool
            sched.deferpool = d.link
            d.link = nil
            pp.deferpool = append(pp.deferpool, d)
        }
        unlock(&sched.deferlock)
    }
    // P中有，那就直接取一个
    if n := len(pp.deferpool); n > 0 {
        d = pp.deferpool[n-1]
        pp.deferpool[n-1] = nil
        pp.deferpool = pp.deferpool[:n-1]
    }
    releasem(mp)
    mp, pp = nil, nil

    // 没有可用的缓存，直接从堆上分配
    if d == nil {
        // Allocate new defer.
        d = new(_defer)
    }
    d.heap = true
    return d
}

// 释放_defer结构体
// Free the given defer.
// The defer cannot be used after this call.
//
// This is nosplit because the incoming defer is in a perilous state.
// It's not on any defer list, so stack copying won't adjust stack
// pointers in it (namely, d.link). Hence, if we were to copy the
// stack, d could then contain a stale pointer.
//
//go:nosplit
func freedefer(d *_defer) {
    d.link = nil
    // After this point we can copy the stack.

    if d._panic != nil {
        freedeferpanic()
    }
    if d.fn != nil {
        freedeferfn()
    }
    // 不在堆上直接返回，清空栈
    if !d.heap {
        return
    }

    mp := acquirem()
    pp := mp.p.ptr()
    if len(pp.deferpool) == cap(pp.deferpool) {
        // Transfer half of local cache to the central cache.
        // 将一半的本地池存到全局
        var first, last *_defer
        for len(pp.deferpool) > cap(pp.deferpool)/2 {
            n := len(pp.deferpool)
            d := pp.deferpool[n-1]
            pp.deferpool[n-1] = nil
            pp.deferpool = pp.deferpool[:n-1]
            if first == nil {
                first = d
            } else {
                last.link = d
            }
            last = d
        }
        lock(&sched.deferlock)
        last.link = sched.deferpool
        sched.deferpool = first
        unlock(&sched.deferlock)
    }

    *d = _defer{}

    pp.deferpool = append(pp.deferpool, d)

    releasem(mp)
    mp, pp = nil, nil
}
```

deferreturn被编译器插入到函数末尾，当跳转到它时，会将需要被defer的入口地址取出，然后跳转并执行：

```go
// src/cmd/compile/internal/ssagen/ssa.go
// exit processes any code that needs to be generated just before returning.
// It returns a BlockRet block that ends the control flow. Its control value
// will be set to the final memory state.
// 函数返回前的一些操作
func (s *state) exit() *ssa.Block {
    // 调用defer
    if s.hasdefer {
        if s.hasOpenDefers {
            if shareDeferExits && s.lastDeferExit != nil && len(s.openDefers) == s.lastDeferCount {
                if s.curBlock.Kind != ssa.BlockPlain {
                    panic("Block for an exit should be BlockPlain")
                }
                s.curBlock.AddEdgeTo(s.lastDeferExit)
                s.endBlock()
                return s.lastDeferFinalBlock
            }
            s.openDeferExit()
        } else {
            // 调用deferreturn
            s.rtcall(ir.Syms.Deferreturn, true, nil)
        }
    }

    var b *ssa.Block
    var m *ssa.Value
    // Do actual return.
    // These currently turn into self-copies (in many cases).
    resultFields := s.curfn.Type().Results().FieldSlice()
    results := make([]*ssa.Value, len(resultFields)+1, len(resultFields)+1)
    m = s.newValue0(ssa.OpMakeResult, s.f.OwnAux.LateExpansionResultType())
    // Store SSAable and heap-escaped PPARAMOUT variables back to stack locations.
    for i, f := range resultFields {
        n := f.Nname.(*ir.Name)
        if s.canSSA(n) { // result is in some SSA variable
            if !n.IsOutputParamInRegisters() && n.Type().HasPointers() {
                // We are about to store to the result slot.
                s.vars[memVar] = s.newValue1A(ssa.OpVarDef, types.TypeMem, n, s.mem())
            }
            results[i] = s.variable(n, n.Type())
        } else if !n.OnStack() { // result is actually heap allocated
            // We are about to copy the in-heap result to the result slot.
            if n.Type().HasPointers() {
                s.vars[memVar] = s.newValue1A(ssa.OpVarDef, types.TypeMem, n, s.mem())
            }
            ha := s.expr(n.Heapaddr)
            s.instrumentFields(n.Type(), ha, instrumentRead)
            results[i] = s.newValue2(ssa.OpDereference, n.Type(), ha, s.mem())
        } else { // result is not SSA-able; not escaped, so not on heap, but too large for SSA.
            // Before register ABI this ought to be a self-move, home=dest,
            // With register ABI, it's still a self-move if parameter is on stack (i.e., too big or overflowed)
            // No VarDef, as the result slot is already holding live value.
            results[i] = s.newValue2(ssa.OpDereference, n.Type(), s.addr(n), s.mem())
        }
    }

    // Run exit code. Today, this is just racefuncexit, in -race mode.
    // TODO(register args) this seems risky here with a register-ABI, but not clear it is right to do it earlier either.
    // Spills in register allocation might just fix it.
    s.stmtList(s.curfn.Exit)

    results[len(results)-1] = s.mem()
    m.AddArgs(results...)

    b = s.endBlock()
    b.Kind = ssa.BlockRet
    b.SetControl(m)
    if s.hasdefer && s.hasOpenDefers {
        s.lastDeferFinalBlock = b
    }
    return b
}

// deferreturn runs deferred functions for the caller's frame.
// The compiler inserts a call to this at the end of any
// function which calls defer.
func deferreturn() {
    gp := getg()
    for {
        d := gp._defer
        if d == nil {
            return
        }
        // 确定defer的调用方是不是当前deferreturn的调用方
        sp := getcallersp()
        if d.sp != sp {
            return
        }
        // 是否是开放编码
        if d.openDefer {
            done := runOpenDeferFrame(d)
            if !done {
                throw("unfinished open-coded defers in deferreturn")
            }
            gp._defer = d.link
            freedefer(d)
            // If this frame uses open defers, then this
            // must be the only defer record for the
            // frame, so we can just return.
            return
        }

        // 获得被延迟调用的函数fn的入口地址，将_defer结构体释放掉
      	// 闭包函数指针
        fn := d.fn
        d.fn = nil
        gp._defer = d.link
        freedefer(d)
        // 执行
        fn()
    }
}
```

开放式编码defer

在函数末尾直接对延迟函数进行调用，不需要额外开销。

```go
// src/cmd/compile/internal/ssagen/ssa.go

// 开放式编码defer条件判断
    // 1、没有禁用编译优化选项，即没有设置 -gcflags "-N"
    // 2、存在defer调用
    // 3、当前函数是否允许开放式编码
    s.hasOpenDefers = base.Flag.N == 0 && s.hasdefer && !s.curfn.OpenCodedDeferDisallowed()
    switch {
    case base.Debug.NoOpenDefer != 0:
        // 4、debug选项没有禁用
        s.hasOpenDefers = false
    case s.hasOpenDefers && (base.Ctxt.Flag_shared || base.Ctxt.Flag_dynlink) && base.Ctxt.Arch.Name == "386":
        // Don't support open-coded defers for 386 ONLY when using shared
        // libraries, because there is extra code (added by rewriteToUseGot())
        // preceding the deferreturn/ret code that we don't track correctly.
        // 5、386架构，如果使用共享库或动态链接，则禁用开放编码的defer。在这种情况下，前置代码会干扰deferreturn/ret代码段
        s.hasOpenDefers = false
    }
    if s.hasOpenDefers && len(s.curfn.Exit) > 0 {
        // Skip doing open defers if there is any extra exit code (likely
        // race detection), since we will not generate that code in the
        // case of the extra deferreturn/ret segment.
        // 6、如果当前函数有额外的退出代码（可能是静态检测），则禁用开放编码的defer，这些代码不会在deferreturn/ret段中生成
        s.hasOpenDefers = false
    }
    if s.hasOpenDefers {
        // Similarly, skip if there are any heap-allocated result
        // parameters that need to be copied back to their stack slots.
        // 有任何需要从堆复制回栈的结果参数，则禁用开放编码
        for _, f := range s.curfn.Type().Results().FieldSlice() {
            if !f.Nname.(*ir.Name).OnStack() {
                s.hasOpenDefers = false
                break
            }
        }
    }
    if s.hasOpenDefers &&
        s.curfn.NumReturns*s.curfn.NumDefers > 15 {
        // Since we are generating defer calls at every exit for
        // open-coded defers, skip doing open-coded defers if there are
        // too many returns (especially if there are multiple defers).
        // Open-coded defers are most important for improving performance
        // for smaller functions (which don't have many returns).
        // 如果返回语句和defer语句的数量乘积超过15，则禁用开放编码的defer。
        // 因为在每个退出点生成defer调用，对于有大量返回点的函数来说会增加开销
        // 开放编码更适用于较小的函数。
        s.hasOpenDefers = false
    }
```

```go
// src/cmd/compile/internal/walk/stmt.go
func walkStmt(n ir.Node) ir.Node {
	switch n.Op() {
	case ir.ODEFER:
        n := n.(*ir.GoDeferStmt)
        ir.CurFunc.SetHasDefer(true)
        ir.CurFunc.NumDefers++
        if ir.CurFunc.NumDefers > maxOpenDefers {
            // Don't allow open-coded defers if there are more than
            // 8 defers in the function, since we use a single
            // byte to record active defers.
            // 超过 8 个 defer 时，禁用对 defer 进行开放编码
            ir.CurFunc.SetOpenCodedDeferDisallowed(true)
        }
        // 存在循环语句中的 defer，禁用对 defer 进行开放编码。
        // 是否有 defer 发生在循环语句内，会在 SSA 之前的逃逸分析中进行判断，
        // 逃逸分析会检查是否存在循环（loopDepth）：
        // if where.Op == ODEFER && e.loopDepth == 1 {
        // 	where.Esc = EscNever
        // 	...
        // }
        if n.Esc() != ir.EscNever {
            // If n.Esc is not EscNever, then this defer occurs in a loop,
            // so open-coded defers cannot be used in this function.
            ir.CurFunc.SetOpenCodedDeferDisallowed(true)
        }
        fallthrough
	}
}
```



正常编写的defer可以直接被编译器分析得出，但在开放编码defer中，需要在编译期完全确定，而不能依靠运行时，这个时候需要引入延迟比特。

比如在条件语句中，需要在编译期确定在条件成立时被正确执行，这就需要一种机制，能够记录存在延迟语句的条件分支是否被执行，这种机制在Go中叫做延迟比特。

在创建延迟调用阶段，首先通过延迟比特的特定位置记录哪些带条件的defer被触发。这个延迟比特是一个长度为8位的二进制码，<span style='color:red'>因为开放编码的defer最多允许8个，以每一位是否被设置为1，来判断延迟语句是否在运行时被设置，如果设置，则发生调用。</span>

1）创建一个长度为8位的临时变量

```go
// src/cmd/compile/internal/ssagen/ssa.go
func buildssa(fn *Node, worker int) *ssa.Func {
	...
	if s.hasOpenDefers {
        // Create the deferBits variable and stack slot.  deferBits is a
        // bitmask showing which of the open-coded defers in this function
        // have been activated.
        // 延迟bit，创建deferbits变量
        // 开放式编码的数量不能超过8个，所以延迟bit被设置为8位
        deferBitsTemp := typecheck.TempAt(src.NoXPos, s.curfn, types.Types[types.TUINT8])
        deferBitsTemp.SetAddrtaken(true)
        s.deferBitsTemp = deferBitsTemp
        // For this value, AuxInt is initialized to zero by default
        // 初始化为0
        startDeferBits := s.entryNewValue0(ssa.OpConst8, types.Types[types.TUINT8])
        s.vars[deferBitsVar] = startDeferBits
        s.deferBitsAddr = s.addr(deferBitsTemp)
        s.store(types.Types[types.TUINT8], s.deferBitsAddr, startDeferBits)
        // Make sure that the deferBits stack slot is kept alive (for use
        // by panics) and stores to deferBits are not eliminated, even if
        // all checking code on deferBits in the function exit can be
        // eliminated, because the defer statements were all
        // unconditional.
        s.vars[memVar] = s.newValue1Apos(ssa.OpVarLive, types.TypeMem, deferBitsTemp, s.mem(), false)
    }
	...
	s.stmtList(fn.Nbody) // 调用 s.stmt
	...
}
```

2）针对出现的defer语句，进行编码

```go
// src/cmd/compile/internal/ssagen/ssa.go
func (s *state) stmt(n *Node) {
	...
	switch n.Op {
	case ODEFER:
		// 开放编码式 defer
		if s.hasOpenDefers {
			s.openDeferRecord(n.Left)
		} else { ... }
	case ...
	}
	...
}

// Information about each open-coded defer.
// 存储每个开放式编码的defer信息
type openDeferInfo struct {
    // The node representing the call of the defer
    n *ir.CallExpr
    // If defer call is closure call, the address of the argtmp where the
    // closure is stored.
    closure *ssa.Value
    // The node representing the argtmp where the closure is stored - used for
    // function, method, or interface call, to store a closure that panic
    // processing can use for this defer.
    closureNode *ir.Name
}

// openDeferRecord adds code to evaluate and store the function for an open-code defer
// call, and records info about the defer, so we can generate proper code on the
// exit paths. n is the sub-node of the defer node that is the actual function
// call. We will also record funcdata information on where the function is stored
// (as well as the deferBits variable), and this will enable us to run the proper
// defer calls during panics.
func (s *state) openDeferRecord(n *ir.CallExpr) {
    if len(n.Args) != 0 || n.Op() != ir.OCALLFUNC || n.X.Type().NumResults() != 0 {
        s.Fatalf("defer call with arguments or results: %v", n)
    }

    // 记录defer相关信息
    opendefer := &openDeferInfo{
        n: n,
    }
    fn := n.X
    // We must always store the function value in a stack slot for the
    // runtime panic code to use. But in the defer exit code, we will
    // call the function directly if it is a static function.
    // 立即求值并存储
    closureVal := s.expr(fn)
    closure := s.openDeferSave(fn.Type(), closureVal)
    // 函数指针存储
    opendefer.closureNode = closure.Aux.(*ir.Name)
    // 记录函数地址
    if !(fn.Op() == ir.ONAME && fn.(*ir.Name).Class == ir.PFUNC) {
        opendefer.closure = closure
    }
    index := len(s.openDefers)
    s.openDefers = append(s.openDefers, opendefer)

    // Update deferBits only after evaluation and storage to stack of
    // the function is successful.
    // 每多出现一个 defer，len(defers) 会增加，进而
    // 延迟比特 deferBits |= 1<<len(defers) 被设置在不同的位上
    bitvalue := s.constInt8(types.Types[types.TUINT8], 1<<uint(index))
    newDeferBits := s.newValue2(ssa.OpOr8, types.Types[types.TUINT8], s.variable(deferBitsVar, types.Types[types.TUINT8]), bitvalue)
    s.vars[deferBitsVar] = newDeferBits
    s.store(types.Types[types.TUINT8], s.deferBitsAddr, newDeferBits)
}
```

3）在函数返回退出前，state的exit函数会依次倒序创建对延迟比特的检查代码，从而顺序调用被延迟的函数调用：

```go
// src/cmd/compile/internal/ssagen/ssa.go
func (s *state) exit() *ssa.Block {
	if s.hasdefer {
		if s.hasOpenDefers {
			...
			s.openDeferExit()
		} else {
			...
		}
	}
	...
}

// openDeferExit generates SSA for processing all the open coded defers at exit.
// The code involves loading deferBits, and checking each of the bits to see if
// the corresponding defer statement was executed. For each bit that is turned
// on, the associated defer call is made.
func (s *state) openDeferExit() {
    deferExit := s.f.NewBlock(ssa.BlockPlain)
    s.endBlock().AddEdgeTo(deferExit)
    s.startBlock(deferExit)
    s.lastDeferExit = deferExit
    s.lastDeferCount = len(s.openDefers)
    zeroval := s.constInt8(types.Types[types.TUINT8], 0)
    // Test for and run defers in reverse order
    // 倒序检查
    for i := len(s.openDefers) - 1; i >= 0; i-- {
        r := s.openDefers[i]
        bCond := s.f.NewBlock(ssa.BlockPlain)
        bEnd := s.f.NewBlock(ssa.BlockPlain)

        // 检查deferbits
        deferBits := s.variable(deferBitsVar, types.Types[types.TUINT8])
        // Generate code to check if the bit associated with the current
        // defer is set.
        bitval := s.constInt8(types.Types[types.TUINT8], 1<<uint(i))
        andval := s.newValue2(ssa.OpAnd8, types.Types[types.TUINT8], deferBits, bitval)
        eqVal := s.newValue2(ssa.OpEq8, types.Types[types.TBOOL], andval, zeroval)
        b := s.endBlock()
        b.Kind = ssa.BlockIf
        b.SetControl(eqVal)
        b.AddEdgeTo(bEnd)
        b.AddEdgeTo(bCond)
        bCond.AddEdgeTo(bEnd)
        s.startBlock(bCond)

        // Clear this bit in deferBits and force store back to stack, so
        // we will not try to re-run this defer call if this defer call panics.
        nbitval := s.newValue1(ssa.OpCom8, types.Types[types.TUINT8], bitval)
        maskedval := s.newValue2(ssa.OpAnd8, types.Types[types.TUINT8], deferBits, nbitval)
        s.store(types.Types[types.TUINT8], s.deferBitsAddr, maskedval)
        // Use this value for following tests, so we keep previous
        // bits cleared.
        s.vars[deferBitsVar] = maskedval

        // Generate code to call the function call of the defer, using the
        // closure that were stored in argtmps at the point of the defer
        // statement.
        // 延迟处理函数调用
        fn := r.n.X
        stksize := fn.Type().ArgWidth()
        var callArgs []*ssa.Value
        var call *ssa.Value
        if r.closure != nil {
            v := s.load(r.closure.Type.Elem(), r.closure)
            s.maybeNilCheckClosure(v, callDefer)
            codeptr := s.rawLoad(types.Types[types.TUINTPTR], v)
            aux := ssa.ClosureAuxCall(s.f.ABIDefault.ABIAnalyzeTypes(nil, nil, nil))
            call = s.newValue2A(ssa.OpClosureLECall, aux.LateExpansionResultType(), aux, codeptr, v)
        } else {
            // 静态函数直接使用函数指针
            aux := ssa.StaticAuxCall(fn.(*ir.Name).Linksym(), s.f.ABIDefault.ABIAnalyzeTypes(nil, nil, nil))
            call = s.newValue0A(ssa.OpStaticLECall, aux.LateExpansionResultType(), aux)
        }
        callArgs = append(callArgs, s.mem())
        call.AddArgs(callArgs...)
        call.AuxInt = stksize
        s.vars[memVar] = s.newValue1I(ssa.OpSelectN, types.TypeMem, 0, call)
        // Make sure that the stack slots with pointers are kept live
        // through the call (which is a pre-emption point). Also, we will
        // use the first call of the last defer exit to compute liveness
        // for the deferreturn, so we want all stack slots to be live.
        if r.closureNode != nil {
            s.vars[memVar] = s.newValue1Apos(ssa.OpVarLive, types.TypeMem, r.closureNode, s.mem(), false)
        }

        s.endBlock()
        s.startBlock(bEnd)
    }
}
```

注意：defer在编译期被统一为闭包处理。

​	1.	**统一处理**：将所有的 defer 调用都当作闭包来处理，可以简化编译器的实现。编译器只需要一种机制来处理所有的 defer 调用，无论它们是否是闭包。这种统一处理方式避免了编译器在处理 defer 调用时，需要区分普通函数调用和闭包调用。

​	2.	**延迟执行上下文**：

​	即使是普通的函数调用，defer 也需要记录函数指针和调用的上下文（例如参数值）。将其作为闭包处理，可以方便地将这些信息保存在一起。

​	这也确保了在处理 panic 或函数退出时，可以正确地恢复和执行延迟调用。
