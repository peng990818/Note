
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>内部包 · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="内存一致模型.html" />
    
    
    <link rel="prev" href="类型.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    介绍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="./">
            
                <a href="./">
            
                    
                    Go
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="go 内存逃逸.html">
            
                <a href="go 内存逃逸.html">
            
                    
                    内存逃逸
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="go闭包.html">
            
                <a href="go闭包.html">
            
                    
                    闭包
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="go embed.html">
            
                <a href="go embed.html">
            
                    
                    embed
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="编译指令.html">
            
                <a href="编译指令.html">
            
                    
                    编译指令
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="工具链.html">
            
                <a href="工具链.html">
            
                    
                    工具链
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="反射.html">
            
                <a href="反射.html">
            
                    
                    反射
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="unsafe.html">
            
                <a href="unsafe.html">
            
                    
                    unsafe
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="interface.html">
            
                <a href="interface.html">
            
                    
                    接口
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="环境变量.html">
            
                <a href="环境变量.html">
            
                    
                    环境变量
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="plan9.html">
            
                <a href="plan9.html">
            
                    
                    plan9汇编
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="相关问题.html">
            
                <a href="相关问题.html">
            
                    
                    相关问题
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="编译流程.html">
            
                <a href="编译流程.html">
            
                    
                    编译流程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13" data-path="runtime.html">
            
                <a href="runtime.html">
            
                    
                    运行时
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.14" data-path="内置关键字.html">
            
                <a href="内置关键字.html">
            
                    
                    内置关键字
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.15" data-path="类型.html">
            
                <a href="类型.html">
            
                    
                    类型
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.16" data-path="内部包.html">
            
                <a href="内部包.html">
            
                    
                    内部包
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.17" data-path="内存一致模型.html">
            
                <a href="内存一致模型.html">
            
                    
                    内存一致模型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.18" data-path="并发调度.html">
            
                <a href="并发调度.html">
            
                    
                    并发调度
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../node/">
            
                <a href="../node/">
            
                    
                    Node
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../node/相关问题.html">
            
                <a href="../node/相关问题.html">
            
                    
                    相关问题
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../Linux/">
            
                <a href="../Linux/">
            
                    
                    Linux
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../Linux/基本概念.html">
            
                <a href="../Linux/基本概念.html">
            
                    
                    基本概念
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../Project/">
            
                <a href="../Project/">
            
                    
                    Project
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../Project/oauth2.html">
            
                <a href="../Project/oauth2.html">
            
                    
                    oauth2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../Project/web.html">
            
                <a href="../Project/web.html">
            
                    
                    网络协议
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../Project/后端.html">
            
                <a href="../Project/后端.html">
            
                    
                    后端
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../Project/敏感词处理.html">
            
                <a href="../Project/敏感词处理.html">
            
                    
                    敏感词处理
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../算法/">
            
                <a href="../算法/">
            
                    
                    算法
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../算法/数据结构.html">
            
                <a href="../算法/数据结构.html">
            
                    
                    数据结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../算法/算法.html">
            
                <a href="../算法/算法.html">
            
                    
                    算法
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../中间件/">
            
                <a href="../中间件/">
            
                    
                    中间件
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../中间件/mysql.html">
            
                <a href="../中间件/mysql.html">
            
                    
                    mysql
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../常见问题/">
            
                <a href="../常见问题/">
            
                    
                    常见问题
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../常见问题/Go语言.html">
            
                <a href="../常见问题/Go语言.html">
            
                    
                    GO语言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../常见问题/mysql.html">
            
                <a href="../常见问题/mysql.html">
            
                    
                    mysql
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../常见问题/redis.html">
            
                <a href="../常见问题/redis.html">
            
                    
                    redis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="../常见问题/Linux.html">
            
                <a href="../常见问题/Linux.html">
            
                    
                    Linux
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >内部包</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="&#x5185;&#x90E8;&#x5305;">&#x5185;&#x90E8;&#x5305;</h1>
<h2 id="1&#x3001;&#x4E92;&#x65A5;&#x9501;">1&#x3001;&#x4E92;&#x65A5;&#x9501;</h2>
<h3 id="&#x7ED3;&#x6784;">&#x7ED3;&#x6784;</h3>
<pre><code class="lang-go"><span class="hljs-comment">// src/sync/mutex.go</span>
<span class="hljs-comment">// A Mutex is a mutual exclusion lock.</span>
<span class="hljs-comment">// The zero value for a Mutex is an unlocked mutex.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// A Mutex must not be copied after first use.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In the terminology of the Go memory model,</span>
<span class="hljs-comment">// the n&apos;th call to Unlock &#x201C;synchronizes before&#x201D; the m&apos;th call to Lock</span>
<span class="hljs-comment">// for any n &lt; m.</span>
<span class="hljs-comment">// A successful call to TryLock is equivalent to a call to Lock.</span>
<span class="hljs-comment">// A failed call to TryLock does not establish any &#x201C;synchronizes before&#x201D;</span>
<span class="hljs-comment">// relation at all.</span>
<span class="hljs-comment">// &#x4E92;&#x65A5;&#x9501;&#x662F;&#x4E00;&#x79CD;&#x4E92;&#x65A5;&#x9501;&#x3002;&#x4E92;&#x65A5;&#x4F53;&#x7684;&#x96F6;&#x503C;&#x662F;&#x672A;&#x9501;&#x5B9A;&#x7684;&#x4E92;&#x65A5;&#x4F53;&#x3002;&#x9996;&#x6B21;&#x4F7F;&#x7528;&#x540E;&#x4E0D;&#x5F97;&#x590D;&#x5236;&#x4E92;&#x65A5;&#x9501;&#x3002;</span>
<span class="hljs-comment">// &#x5728; Go &#x5185;&#x5B58;&#x6A21;&#x578B;&#x7684;&#x672F;&#x8BED;&#x4E2D;&#xFF0C;&#x5BF9;&#x4E8E;&#x4EFB;&#x610F; n &lt; m&#xFF0C;&#x7B2C; n &#x6B21; Unlock &#x8C03;&#x7528;&#x201C;&#x540C;&#x6B65;&#x4E8E;&#x201D;&#x7B2C; m &#x6B21; Lock &#x8C03;&#x7528;&#x4E4B;&#x524D;&#x3002;</span>
<span class="hljs-comment">// &#x6210;&#x529F;&#x8C03;&#x7528; TryLock &#x76F8;&#x5F53;&#x4E8E;&#x8C03;&#x7528; Lock&#x3002;&#x5BF9; TryLock &#x7684;&#x5931;&#x8D25;&#x8C03;&#x7528;&#x6839;&#x672C;&#x4E0D;&#x4F1A;&#x5EFA;&#x7ACB;&#x4EFB;&#x4F55;&#x201C;&#x540C;&#x6B65;&#x4E4B;&#x524D;&#x201D;&#x5173;&#x7CFB;&#x3002;</span>
<span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> {
    state <span class="hljs-keyword">int32</span>  <span class="hljs-comment">// &#x9501;&#x5F53;&#x524D;&#x7684;&#x72B6;&#x6001;</span>
    sema  <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// &#x4FE1;&#x53F7;&#x91CF;&#xFF0C;&#x7528;&#x4E8E;&#x5524;&#x9192;&#x534F;&#x7A0B;</span>
}
</code></pre>
<h3 id="&#x72B6;&#x6001;">&#x72B6;&#x6001;</h3>
<pre><code class="lang-go"><span class="hljs-keyword">const</span> (
    mutexLocked      = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// mutex is locked &#x9501;&#x662F;&#x5426;&#x88AB;&#x5360;&#x7528;</span>
    mutexWoken                   <span class="hljs-comment">// &#x662F;&#x5426;&#x6709;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x88AB;&#x5524;&#x9192;</span>
    mutexStarving                <span class="hljs-comment">// &#x5F53;&#x524D;&#x9501;&#x662F;&#x5426;&#x5904;&#x4E8E;&#x9965;&#x997F;&#x6A21;&#x5F0F;&#xFF0C;&#x9965;&#x997F;&#x6A21;&#x5F0F;&#x4E0B;&#x9501;&#x4F1A;&#x4F18;&#x5148;&#x4F20;&#x9012;&#x7ED9;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x6700;&#x957F;&#x7684;&#x534F;&#x7A0B;</span>
    mutexWaiterShift = <span class="hljs-literal">iota</span>      <span class="hljs-comment">// &#x8BB0;&#x5F55;&#x6709;&#x591A;&#x5C11;&#x4E2A;&#x534F;&#x7A0B;&#x5728;&#x7B49;&#x5F85;&#x83B7;&#x53D6;&#x9501;</span>

    <span class="hljs-comment">// Mutex fairness.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Mutex can be in 2 modes of operations: normal and starvation.</span>
    <span class="hljs-comment">// In normal mode waiters are queued in FIFO order, but a woken up waiter</span>
    <span class="hljs-comment">// does not own the mutex and competes with new arriving goroutines over</span>
    <span class="hljs-comment">// the ownership. New arriving goroutines have an advantage -- they are</span>
    <span class="hljs-comment">// already running on CPU and there can be lots of them, so a woken up</span>
    <span class="hljs-comment">// waiter has good chances of losing. In such case it is queued at front</span>
    <span class="hljs-comment">// of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,</span>
    <span class="hljs-comment">// it switches mutex to the starvation mode.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// In starvation mode ownership of the mutex is directly handed off from</span>
    <span class="hljs-comment">// the unlocking goroutine to the waiter at the front of the queue.</span>
    <span class="hljs-comment">// New arriving goroutines don&apos;t try to acquire the mutex even if it appears</span>
    <span class="hljs-comment">// to be unlocked, and don&apos;t try to spin. Instead they queue themselves at</span>
    <span class="hljs-comment">// the tail of the wait queue.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// If a waiter receives ownership of the mutex and sees that either</span>
    <span class="hljs-comment">// (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span>
    <span class="hljs-comment">// it switches mutex back to normal operation mode.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Normal mode has considerably better performance as a goroutine can acquire</span>
    <span class="hljs-comment">// a mutex several times in a row even if there are blocked waiters.</span>
    <span class="hljs-comment">// Starvation mode is important to prevent pathological cases of tail latency.</span>
    starvationThresholdNs = <span class="hljs-number">1e6</span> <span class="hljs-comment">// &#x9965;&#x997F;&#x9608;&#x503C;</span>
)
</code></pre>
<p>&#x4E92;&#x65A5;&#x9501;&#x53EF;&#x80FD;&#x5904;&#x4E8E;&#x4E24;&#x79CD;&#x4E0D;&#x540C;&#x7684;&#x6A21;&#x5F0F;&#xFF1A;&#x6B63;&#x5E38;&#x6A21;&#x5F0F;&#x548C;&#x9965;&#x997F;&#x6A21;&#x5F0F;&#x3002;</p>
<p>&#x5728;&#x6B63;&#x5E38;&#x6A21;&#x5F0F;&#x4E2D;&#xFF0C;&#x7B49;&#x5F85;&#x8005;&#x6309;&#x7167;FIFO&#x7684;&#x987A;&#x5E8F;&#x6392;&#x961F;&#x83B7;&#x53D6;&#x9501;&#xFF0C;&#x4F46;&#x662F;&#x4E00;&#x4E2A;&#x88AB;&#x5524;&#x9192;&#x7684;&#x7B49;&#x5F85;&#x8005;&#x6709;&#x65F6;&#x5019;&#x5E76;&#x4E0D;&#x80FD;&#x83B7;&#x53D6;mutex&#xFF0C;&#x5B83;&#x8FD8;&#x9700;&#x8981;&#x548C;&#x65B0;&#x5230;&#x6765;&#x7684;&#x534F;&#x7A0B;&#x7ADE;&#x4E89;mutex&#x7684;&#x4F7F;&#x7528;&#x6743;&#x3002;&#x65B0;&#x5230;&#x6765;&#x7684;&#x534F;&#x7A0B;&#x5B58;&#x5728;&#x4E00;&#x4E2A;&#x4F18;&#x52BF;&#xFF0C;&#x5B83;&#x4EEC;&#x5DF2;&#x7ECF;&#x5728;CPU&#x4E0A;&#x8FD0;&#x884C;&#x4E14;&#x6570;&#x91CF;&#x5F88;&#x591A;&#xFF0C;&#x56E0;&#x6B64;&#x4E00;&#x4E2A;&#x88AB;&#x5524;&#x9192;&#x7684;&#x7B49;&#x5F85;&#x8005;&#x6709;&#x5F88;&#x5927;&#x7684;&#x6982;&#x7387;&#x83B7;&#x53D6;&#x4E0D;&#x5230;&#x9501;&#xFF0C;&#x5728;&#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x4E0B;&#x5B83;&#x5904;&#x5728;&#x7B49;&#x5F85;&#x961F;&#x5217;&#x7684;&#x524D;&#x9762;&#x3002;&#x5982;&#x679C;&#x4E00;&#x4E2A;&#x534F;&#x7A0B;&#x7B49;&#x5F85;mutex&#x91CA;&#x653E;&#x7684;&#x65F6;&#x95F4;&#x8D85;&#x8FC7;1ms&#xFF0C;&#x5B83;&#x5C31;&#x4F1A;&#x5C06;mutex&#x5207;&#x6362;&#x5230;&#x9965;&#x997F;&#x6A21;&#x5F0F;&#x3002;</p>
<p>&#x5728;&#x9965;&#x997F;&#x6A21;&#x5F0F;&#x4E2D;&#xFF0C;mutex&#x7684;&#x6240;&#x6709;&#x6743;&#x76F4;&#x63A5;&#x4ECE;&#x89E3;&#x9501;&#x7684;&#x534F;&#x7A0B;&#x9012;&#x4EA4;&#x5230;&#x7B49;&#x5F85;&#x961F;&#x5217;&#x4E2D;&#x6392;&#x5728;&#x6700;&#x524D;&#x65B9;&#x7684;&#x534F;&#x7A0B;&#x3002;&#x65B0;&#x5230;&#x8FBE;&#x7684;&#x534F;&#x7A0B;&#x4E0D;&#x8981;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;mutex&#xFF0C;&#x5373;&#x4F7F;&#x5B83;&#x770B;&#x8D77;&#x6765;&#x662F;&#x5728;&#x89E3;&#x9501;&#x72B6;&#x6001;&#xFF0C;&#x4E5F;&#x4E0D;&#x8981;&#x8BD5;&#x56FE;&#x81EA;&#x65CB;&#xFF0C;&#x800C;&#x662F;&#x6392;&#x5230;&#x7B49;&#x5F85;&#x961F;&#x5217;&#x7684;&#x5C3E;&#x90E8;&#x3002;</p>
<p>&#x5982;&#x679C;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x8005;&#x83B7;&#x5F97;mutex&#x7684;&#x6240;&#x6709;&#x6743;&#xFF0C;&#x5E76;&#x4E14;&#x770B;&#x5230;&#x4EE5;&#x4E0B;&#x4E24;&#x79CD;&#x60C5;&#x51B5;&#x4E2D;&#x7684;&#x4EFB;&#x610F;&#x4E00;&#x79CD;&#xFF1A;</p>
<p>1&#xFF09;&#x5B83;&#x662F;&#x7B49;&#x5F85;&#x961F;&#x5217;&#x4E2D;&#x7684;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x3002;</p>
<p>2&#xFF09;&#x5B83;&#x7B49;&#x5F85;&#x7684;&#x65F6;&#x95F4;&#x5C11;&#x4E8E;1ms&#xFF0C;&#x5B83;&#x4FBF;&#x5C06;mutex&#x5207;&#x6362;&#x56DE;&#x6B63;&#x5E38;&#x64CD;&#x4F5C;&#x6A21;&#x5F0F;</p>
<p>&#x6B63;&#x5E38;&#x6A21;&#x5F0F;&#x4E0B;&#x7684;&#x6027;&#x80FD;&#x4F1A;&#x66F4;&#x597D;&#xFF0C;&#x56E0;&#x4E3A;&#x4E00;&#x4E2A;&#x534F;&#x7A0B;&#x80FD;&#x5728;&#x5373;&#x4F7F;&#x6709;&#x5F88;&#x591A;&#x963B;&#x585E;&#x7684;&#x7B49;&#x5F85;&#x8005;&#x65F6;&#x591A;&#x6B21;&#x8FDE;&#x7EED;&#x7684;&#x83B7;&#x5F97;&#x4E00;&#x4E2A;mutex&#xFF0C;<span style="color:red">&#x9965;&#x997F;&#x6A21;&#x5F0F;&#x7684;&#x91CD;&#x8981;&#x6027;&#x5728;&#x4E8E;&#x907F;&#x514D;&#x4E86;&#x75C5;&#x6001;&#x60C5;&#x51B5;&#x4E0B;&#x7684;&#x5C3E;&#x90E8;&#x5EF6;&#x8FDF;&#x3002;</span></p>
<h3 id="&#x52A0;&#x9501;">&#x52A0;&#x9501;</h3>
<p>Lock&#x5BF9;&#x7533;&#x8BF7;&#x9501;&#x7684;&#x60C5;&#x51B5;&#x5206;&#x4E3A;&#x4E09;&#x79CD;&#xFF1A;</p>
<ol>
<li>&#x65E0;&#x51B2;&#x7A81;&#xFF0C;&#x901A;&#x8FC7;CAS&#x64CD;&#x4F5C;&#x628A;&#x5F53;&#x524D;&#x72B6;&#x6001;&#x8BBE;&#x7F6E;&#x4E3A;&#x52A0;&#x9501;&#x72B6;&#x6001;</li>
<li>&#x6709;&#x51B2;&#x7A81;&#xFF0C;&#x5F00;&#x59CB;&#x81EA;&#x65CB;&#xFF0C;&#x5E76;&#x7B49;&#x5F85;&#x9501;&#x91CA;&#x653E;&#xFF0C;&#x5982;&#x679C;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x5728;&#x8FD9;&#x6BB5;&#x65F6;&#x95F4;&#x5185;&#x91CA;&#x653E;&#x8BE5;&#x9501;&#xFF0C;&#x76F4;&#x63A5;&#x83B7;&#x5F97;&#x8BE5;&#x9501;&#xFF1B;&#x6CA1;&#x6709;&#x91CA;&#x653E;&#x5219;&#x4E3A;&#x4E0B;&#x4E00;&#x79CD;&#x60C5;&#x51B5;&#x3002;</li>
<li>&#x6709;&#x51B2;&#x7A81;&#xFF0C;&#x4E14;&#x5DF2;&#x7ECF;&#x8FC7;&#x4E86;&#x81EA;&#x65CB;&#x9636;&#x6BB5;&#xFF0C;&#x901A;&#x8FC7;&#x8C03;&#x7528;semrelease&#x8BA9;&#x534F;&#x7A0B;&#x8FDB;&#x5165;&#x7B49;&#x5F85;&#x72B6;&#x6001;&#x3002;</li>
</ol>
<pre><code class="lang-go"><span class="hljs-comment">// Lock locks m.</span>
<span class="hljs-comment">// If the lock is already in use, the calling goroutine</span>
<span class="hljs-comment">// blocks until the mutex is available.</span>
<span class="hljs-keyword">func</span> (m *Mutex) Lock() {
    <span class="hljs-comment">// Fast path: grab unlocked mutex.</span>
    <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) {
        <span class="hljs-comment">// &#x9501;&#x5728;&#x8C03;&#x7528;&#x65F6;&#x672A;&#x88AB;&#x5360;&#x7528;&#xFF0C;&#x5219;&#x8BBE;&#x7F6E;&#x4E3A;&#x9501;&#x5B9A;&#x72B6;&#x6001;</span>
        <span class="hljs-keyword">if</span> race.Enabled {
            <span class="hljs-comment">// &#x542F;&#x7528;&#x7ADF;&#x6001;&#x68C0;&#x6D4B;&#xFF0C;&#x8BB0;&#x5F55;&#x9501;&#x7684;&#x6076;&#x83B7;&#x53D6;</span>
            race.Acquire(unsafe.Pointer(m))
        }
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-comment">// Slow path (outlined so that the fast path can be inlined)</span>
    <span class="hljs-comment">// &#x9501;&#x5DF2;&#x88AB;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x6301;&#x6709;&#x5219;&#x8FDB;&#x5165;&#x6162;&#x901F;&#x8DEF;&#x5F84;&#x8FDB;&#x884C;&#x5904;&#x7406;</span>
    m.lockSlow()
}

<span class="hljs-keyword">func</span> (m *Mutex) lockSlow() {
    <span class="hljs-keyword">var</span> waitStartTime <span class="hljs-keyword">int64</span> <span class="hljs-comment">// &#x8BB0;&#x5F55;&#x5F00;&#x59CB;&#x7B49;&#x5F85;&#x7684;&#x65F6;&#x95F4;</span>
    starving := <span class="hljs-literal">false</span>       <span class="hljs-comment">// &#x8868;&#x793A;&#x5F53;&#x524D;&#x662F;&#x5426;&#x5904;&#x4E8E;&#x9965;&#x997F;&#x6A21;&#x5F0F;</span>
    awoke := <span class="hljs-literal">false</span>          <span class="hljs-comment">// &#x8868;&#x793A;&#x5F53;&#x524D;&#x534F;&#x7A0B;&#x662F;&#x5426;&#x5DF2;&#x88AB;&#x5524;&#x9192;</span>
    iter := <span class="hljs-number">0</span>               <span class="hljs-comment">// &#x7528;&#x4E8E;&#x8BB0;&#x5F55;&#x81EA;&#x65CB;&#x6B21;&#x6570;</span>
    old := m.state          <span class="hljs-comment">// &#x4FDD;&#x5B58;&#x9501;&#x7684;&#x5F53;&#x524D;&#x72B6;&#x6001;</span>
    <span class="hljs-keyword">for</span> {
        <span class="hljs-comment">// Don&apos;t spin in starvation mode, ownership is handed off to waiters</span>
        <span class="hljs-comment">// so we won&apos;t be able to acquire the mutex anyway.</span>
        <span class="hljs-comment">// &#x9501;&#x5DF2;&#x88AB;&#x5360;&#x7528;&#x4F46;&#x5C1A;&#x672A;&#x5904;&#x4E8E;&#x9965;&#x997F;&#x72B6;&#x6001;&#x5E76;&#x4E14;&#x6EE1;&#x8DB3;&#x81EA;&#x65CB;&#x6761;&#x4EF6;</span>
        <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
            <span class="hljs-comment">// &#x901A;&#x8FC7;&#x81EA;&#x65CB;&#x7684;&#x65B9;&#x5F0F;&#x83B7;&#x53D6;&#x9501;&#x800C;&#x4E0D;&#x662F;&#x7ACB;&#x5373;&#x8FDB;&#x5165;&#x963B;&#x585E;&#x72B6;&#x6001;</span>
            <span class="hljs-comment">// Active spinning makes sense.</span>
            <span class="hljs-comment">// Try to set mutexWoken flag to inform Unlock</span>
            <span class="hljs-comment">// to not wake other blocked goroutines.</span>
            <span class="hljs-comment">// mutexWoken&#x672A;&#x8BBE;&#x7F6E;&#x5E76;&#x4E14;&#x6709;&#x7B49;&#x5F85;&#x7684;&#x534F;&#x7A0B;&#xFF0C;&#x5219;&#x5C1D;&#x8BD5;&#x8BBE;&#x7F6E;mutexWoken&#xFF0C;&#x544A;&#x77E5;&#x540E;&#x7EED;&#x7684;&#x89E3;&#x9501;&#x64CD;&#x4F5C;&#x4E0D;&#x8981;&#x5524;&#x9192;&#x5176;&#x4ED6;&#x534F;&#x7A0B;</span>
            <span class="hljs-keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="hljs-number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="hljs-number">0</span> &amp;&amp;
                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                awoke = <span class="hljs-literal">true</span>
            }
            runtime_doSpin()
            iter++
            old = m.state
            <span class="hljs-keyword">continue</span>
        }
        <span class="hljs-built_in">new</span> := old
        <span class="hljs-comment">// Don&apos;t try to acquire starving mutex, new arriving goroutines must queue.</span>
        <span class="hljs-comment">// &#x4E0D;&#x8981;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x9965;&#x997F;&#x7684;&#x9501;&#xFF0C;&#x65B0;&#x5230;&#x6765;&#x7684;&#x534F;&#x7A0B;&#x5FC5;&#x987B;&#x5728;&#x961F;&#x5217;&#x4E2D;</span>
        <span class="hljs-keyword">if</span> old&amp;mutexStarving == <span class="hljs-number">0</span> {
            <span class="hljs-comment">// &#x9501;&#x672A;&#x5904;&#x4E8E;&#x9965;&#x997F;&#x72B6;&#x6001;&#xFF0C;&#x5F53;&#x524D;&#x534F;&#x7A0B;&#x4E0D;&#x662F;&#x5728;&#x88AB;&#x5524;&#x9192;&#x540E;&#x91CD;&#x65B0;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x9501;&#xFF0C;&#x5219;&#x5C06;&#x72B6;&#x6001;&#x66F4;&#x65B0;&#x4E3A;&#x5DF2;&#x9501;&#x4F4F;</span>
            <span class="hljs-built_in">new</span> |= mutexLocked
        }
        <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="hljs-number">0</span> {
            <span class="hljs-comment">// &#x5F53;&#x524D;&#x9501;&#x5DF2;&#x88AB;&#x9501;&#x5B9A;&#x6216;&#x6B63;&#x5904;&#x4E8E;&#x9965;&#x997F;&#x6A21;&#x5F0F;&#xFF0C;&#x5219;&#x589E;&#x52A0;&#x7B49;&#x5F85;&#x534F;&#x7A0B;&#x8BA1;&#x6570;&#xFF0C;&#x8868;&#x793A;&#x6709;&#x66F4;&#x591A;&#x7684;&#x534F;&#x7A0B;&#x5728;&#x7B49;&#x5F85;</span>
            <span class="hljs-built_in">new</span> += <span class="hljs-number">1</span> &lt;&lt; mutexWaiterShift
        }
        <span class="hljs-comment">// The current goroutine switches mutex to starvation mode.</span>
        <span class="hljs-comment">// But if the mutex is currently unlocked, don&apos;t do the switch.</span>
        <span class="hljs-comment">// Unlock expects that starving mutex has waiters, which will not</span>
        <span class="hljs-comment">// be true in this case.</span>
        <span class="hljs-comment">// &#x9965;&#x997F;&#x6A21;&#x5F0F;&#x5904;&#x7406;</span>
        <span class="hljs-comment">// &#x5F53;&#x9501;&#x8FDB;&#x5165;&#x9965;&#x997F;&#x6A21;&#x5F0F;&#x540E;&#xFF0C;&#x65B0;&#x6765;&#x7684;&#x534F;&#x7A0B;&#x5C06;&#x4E0D;&#x518D;&#x5C1D;&#x8BD5;&#x81EA;&#x65CB;&#x83B7;&#x53D6;&#x9501;&#xFF0C;&#x76F4;&#x63A5;&#x6392;&#x961F;&#x7B49;&#x5F85;</span>
        <span class="hljs-keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="hljs-number">0</span> {
            <span class="hljs-built_in">new</span> |= mutexStarving
        }
        <span class="hljs-keyword">if</span> awoke {
            <span class="hljs-comment">// The goroutine has been woken from sleep,</span>
            <span class="hljs-comment">// so we need to reset the flag in either case.</span>
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexWoken == <span class="hljs-number">0</span> {
                throw(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)
            }
            <span class="hljs-built_in">new</span> &amp;^= mutexWoken
        }
        <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) {
            <span class="hljs-comment">// &#x9501;&#x83B7;&#x53D6;&#x6210;&#x529F;</span>
            <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="hljs-number">0</span> {
                <span class="hljs-keyword">break</span> <span class="hljs-comment">// locked the mutex with CAS</span>
            }
            <span class="hljs-comment">// If we were already waiting before, queue at the front of the queue.</span>
            <span class="hljs-comment">// &#x5F53;&#x524D;&#x534F;&#x7A0B;&#x4E4B;&#x524D;&#x5C31;&#x5728;&#x7B49;&#x5F85;&#x9501;&#x4E86;&#xFF0C;&#x5E94;&#x8BE5;&#x6392;&#x5728;&#x7B49;&#x5F85;&#x961F;&#x5217;&#x524D;&#x9762;</span>
            queueLifo := waitStartTime != <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> waitStartTime == <span class="hljs-number">0</span> {
                <span class="hljs-comment">// &#x7B2C;&#x4E00;&#x6B21;&#x8FDB;&#x5165;&#x7B49;&#x5F85;&#x72B6;&#x6001;&#xFF0C;&#x5219;&#x5C06;&#x5F53;&#x524D;&#x7684;&#x7EB3;&#x79D2;&#x65F6;&#x95F4;&#x6233;&#x8BB0;&#x5F55;&#xFF0C;&#x8868;&#x793A;&#x4ECE;&#x8FD9;&#x4E00;&#x523B;&#x5F00;&#x59CB;&#x8BB0;&#x5F55;&#x7B49;&#x5F85;&#x65F6;&#x95F4;</span>
                waitStartTime = runtime_nanotime()
            }
            <span class="hljs-comment">// &#x963B;&#x585E;&#x7B49;&#x5F85;</span>
            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="hljs-number">1</span>)
            <span class="hljs-comment">// &#x68C0;&#x67E5;&#x534F;&#x7A0B;&#x662F;&#x5426;&#x8FDB;&#x5165;&#x4E86;&#x9965;&#x997F;&#x6A21;&#x5F0F;&#xFF0C;&#x963B;&#x585E;&#x65F6;&#x95F4;&#x5927;&#x4E8E;1ms&#x6216;&#x8005;&#x6B63;&#x5904;&#x4E8E;&#x9965;&#x997F;&#x6A21;&#x5F0F;</span>
            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
            old = m.state
            <span class="hljs-keyword">if</span> old&amp;mutexStarving != <span class="hljs-number">0</span> {
                <span class="hljs-comment">// If this goroutine was woken and mutex is in starvation mode,</span>
                <span class="hljs-comment">// ownership was handed off to us but mutex is in somewhat</span>
                <span class="hljs-comment">// inconsistent state: mutexLocked is not set and we are still</span>
                <span class="hljs-comment">// accounted as waiter. Fix that.</span>
                <span class="hljs-comment">// &#x4FEE;&#x6B63;&#x9501;&#x7684;&#x72B6;&#x6001;&#xFF1A;&#x5982;&#x679C;&#x5F53;&#x524D;&#x534F;&#x7A0B;&#x88AB;&#x5524;&#x9192;&#x5E76;&#x5904;&#x4E8E;&#x9965;&#x997F;&#x6A21;&#x5F0F;&#xFF0C;&#x90A3;&#x4E48;&#x9501;&#x7684;&#x6240;&#x6709;&#x6743;&#x4F1A;&#x88AB;&#x76F4;&#x63A5;&#x4EA4;&#x7ED9;&#x5F53;&#x524D;&#x534F;&#x7A0B;&#x3002;</span>
                <span class="hljs-comment">// &#x4F46;&#x6B64;&#x65F6;&#x9501;&#x7684;&#x72B6;&#x6001;&#x53EF;&#x80FD;&#x4E0D;&#x4E00;&#x81F4;&#xFF0C;&#x7279;&#x522B;&#x662F;&#x9501;&#x7684;mutexLocked&#x6807;&#x5FD7;&#x4F4D;&#x53EF;&#x80FD;&#x6CA1;&#x6709;&#x88AB;&#x91CD;&#x7F6E;&#x3002;</span>
                <span class="hljs-comment">// &#x867D;&#x7136;&#x5F53;&#x524D;&#x534F;&#x7A0B;&#x5DF2;&#x7ECF;&#x83B7;&#x53D6;&#x4E86;&#x9501;&#xFF0C;&#x56E0;&#x6B64;&#x9700;&#x8981;&#x4FEE;&#x6B63;</span>
                <span class="hljs-comment">// &#x5982;&#x679C;&#x8FD9;&#x4E24;&#x4E2A;&#x6807;&#x5FD7;&#x4F4D;&#x4ECD;&#x7136;&#x88AB;&#x91CD;&#x7F6E;&#xFF0C;&#x6216;&#x8005;&#x7B49;&#x5F85;&#x8BA1;&#x6570;&#x4E3A;0&#xFF0C;&#x4F1A;&#x89E6;&#x53D1;&#x5F02;&#x5E38;&#xFF0C;&#x8868;&#x793A;&#x9501;&#x7684;&#x72B6;&#x6001;&#x4E0D;&#x4E00;&#x81F4;</span>
                <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="hljs-number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> {
                    throw(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)
                }
                <span class="hljs-comment">// &#x4FEE;&#x6B63;&#x9501;&#x7684;&#x72B6;&#x6001;</span>
                <span class="hljs-comment">// &#x8BBE;&#x7F6E;&#x9501;&#x5B9A;&#x6807;&#x5FD7;&#x4F4D;&#x5E76;&#x51CF;&#x5C11;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x8005;&#x5F15;&#x7528;&#x8BA1;&#x6570;</span>
                delta := <span class="hljs-keyword">int32</span>(mutexLocked - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift)
                <span class="hljs-keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">1</span> {
                    <span class="hljs-comment">// &#x5F53;&#x524D;&#x534F;&#x7A0B;&#x6CA1;&#x6709;&#x8FDB;&#x5165;&#x9965;&#x997F;&#x6A21;&#x5F0F;&#xFF0C;&#x6216;&#x8005;&#x8FD9;&#x662F;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x8005;&#xFF0C;&#x5219;&#x89E3;&#x9664;&#x9965;&#x997F;&#x6A21;&#x5F0F;</span>
                    <span class="hljs-comment">// Exit starvation mode.</span>
                    <span class="hljs-comment">// Critical to do it here and consider wait time.</span>
                    <span class="hljs-comment">// Starvation mode is so inefficient, that two goroutines</span>
                    <span class="hljs-comment">// can go lock-step infinitely once they switch mutex</span>
                    <span class="hljs-comment">// to starvation mode.</span>
                    delta -= mutexStarving
                }
                <span class="hljs-comment">// &#x4FEE;&#x6B63;</span>
                atomic.AddInt32(&amp;m.state, delta)
                <span class="hljs-keyword">break</span>
            }
            awoke = <span class="hljs-literal">true</span>
            iter = <span class="hljs-number">0</span>
        } <span class="hljs-keyword">else</span> {
            old = m.state
        }
    }

    <span class="hljs-keyword">if</span> race.Enabled {
        race.Acquire(unsafe.Pointer(m))
    }
}
</code></pre>
<h3 id="&#x89E3;&#x9501;">&#x89E3;&#x9501;</h3>
<pre><code class="lang-go">
<span class="hljs-comment">// Unlock unlocks m.</span>
<span class="hljs-comment">// It is a run-time error if m is not locked on entry to Unlock.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// A locked Mutex is not associated with a particular goroutine.</span>
<span class="hljs-comment">// It is allowed for one goroutine to lock a Mutex and then</span>
<span class="hljs-comment">// arrange for another goroutine to unlock it.</span>
<span class="hljs-keyword">func</span> (m *Mutex) Unlock() {
    <span class="hljs-keyword">if</span> race.Enabled {
        _ = m.state
        race.Release(unsafe.Pointer(m))
    }

    <span class="hljs-comment">// Fast path: drop lock bit.</span>
    <span class="hljs-comment">// &#x6E05;&#x9664;&#x6807;&#x8BB0;&#xFF0C;&#x89E3;&#x9501;</span>
    <span class="hljs-built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span> != <span class="hljs-number">0</span> {
        <span class="hljs-comment">// Outlined slow path to allow inlining the fast path.</span>
        <span class="hljs-comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span>
        <span class="hljs-comment">// &#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x5728;&#x7B49;&#x5F85;&#x6B64;&#x9501;&#x6216;&#x5176;&#x4ED6;&#x72B6;&#x6001;&#x4F4D;&#x88AB;&#x8BBE;&#x7F6E;&#xFF0C;&#x56E0;&#x6B64;&#x8FDB;&#x5165;&#x6162;&#x901F;&#x8DEF;&#x5F84;&#x5904;&#x7406;</span>
        m.unlockSlow(<span class="hljs-built_in">new</span>)
    }
}

<span class="hljs-keyword">func</span> (m *Mutex) unlockSlow(<span class="hljs-built_in">new</span> <span class="hljs-keyword">int32</span>) {
    <span class="hljs-comment">// &#x91CD;&#x590D;&#x89E3;&#x9501;&#x5224;&#x5B9A;</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="hljs-number">0</span> {
        fatal(<span class="hljs-string">&quot;sync: unlock of unlocked mutex&quot;</span>)
    }
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexStarving == <span class="hljs-number">0</span> {
        <span class="hljs-comment">// &#x975E;&#x9965;&#x997F;&#x6A21;&#x5F0F;</span>
        old := <span class="hljs-built_in">new</span>
        <span class="hljs-keyword">for</span> {
            <span class="hljs-comment">// If there are no waiters or a goroutine has already</span>
            <span class="hljs-comment">// been woken or grabbed the lock, no need to wake anyone.</span>
            <span class="hljs-comment">// In starvation mode ownership is directly handed off from unlocking</span>
            <span class="hljs-comment">// goroutine to the next waiter. We are not part of this chain,</span>
            <span class="hljs-comment">// since we did not observe mutexStarving when we unlocked the mutex above.</span>
            <span class="hljs-comment">// So get off the way.</span>
            <span class="hljs-keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="hljs-number">0</span> {
                <span class="hljs-comment">// &#x6CA1;&#x6709;&#x7B49;&#x5F85;&#x8005;&#xFF0C;&#x9501;&#x5DF2;&#x7ECF;&#x88AB;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x83B7;&#x53D6;&#x6216;&#x8005;&#x5904;&#x4E8E;&#x9965;&#x997F;&#x6A21;&#x5F0F;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;</span>
                <span class="hljs-keyword">return</span>
            }
            <span class="hljs-comment">// Grab the right to wake someone.</span>
            <span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x66F4;&#x65B0;&#x72B6;&#x6001;</span>
            <span class="hljs-built_in">new</span> = (old - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken
            <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) {
                <span class="hljs-comment">// &#x5524;&#x9192;&#x4E00;&#x4E2A;&#x963B;&#x585E;&#x7684;&#x534F;&#x7A0B;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x5524;&#x9192;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x8005;</span>
                runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)
                <span class="hljs-keyword">return</span>
            }
            old = m.state
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Starving mode: handoff mutex ownership to the next waiter, and yield</span>
        <span class="hljs-comment">// our time slice so that the next waiter can start to run immediately.</span>
        <span class="hljs-comment">// Note: mutexLocked is not set, the waiter will set it after wakeup.</span>
        <span class="hljs-comment">// But mutex is still considered locked if mutexStarving is set,</span>
        <span class="hljs-comment">// so new coming goroutines won&apos;t acquire it.</span>
        <span class="hljs-comment">// &#x9965;&#x997F;&#x6A21;&#x5F0F;&#x4E0B;&#xFF0C;&#x9501;&#x7684;&#x6240;&#x6709;&#x6743;&#x4F1A;&#x76F4;&#x63A5;&#x4EA4;&#x7ED9;&#x4E0B;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x8005;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x7531;&#x521A;&#x91CA;&#x653E;&#x9501;&#x7684;&#x534F;&#x7A0B;&#x7EE7;&#x7EED;&#x5360;&#x6709;&#x9501;</span>
        <span class="hljs-comment">// &#x5524;&#x9192;&#x4E0B;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x8005;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x7B49;&#x5F85;&#x961F;&#x5217;&#x6700;&#x524D;&#x7AEF;&#x7684;&#x534F;&#x7A0B;</span>
        runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>)
    }
}
</code></pre>
<h3 id="&#x5E76;&#x53D1;&#x5B89;&#x5168;&#x7684;&#x5355;&#x4F8B;&#x6A21;&#x5F0F;">&#x5E76;&#x53D1;&#x5B89;&#x5168;&#x7684;&#x5355;&#x4F8B;&#x6A21;&#x5F0F;</h3>
<p>&#x5229;&#x7528;&#x539F;&#x5B50;&#x64CD;&#x4F5C;&#x548C;&#x4E92;&#x65A5;&#x9501;&#xFF0C;&#x53EF;&#x4EE5;&#x8F7B;&#x677E;&#x5B9E;&#x73B0;&#x4E00;&#x4E2A;&#x975E;&#x5E38;&#x7B80;&#x5355;&#x7684;&#x5E76;&#x53D1;&#x5B89;&#x5168;&#x7684;&#x5355;&#x4F8B;&#x6A21;&#x5F0F;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Once is an object that will perform exactly one action.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// A Once must not be copied after first use.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In the terminology of the Go memory model,</span>
<span class="hljs-comment">// the return from f &#x201C;synchronizes before&#x201D;</span>
<span class="hljs-comment">// the return from any call of once.Do(f).</span>
<span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// done indicates whether the action has been performed.</span>
    <span class="hljs-comment">// It is first in the struct because it is used in the hot path.</span>
    <span class="hljs-comment">// The hot path is inlined at every call site.</span>
    <span class="hljs-comment">// Placing done first allows more compact instructions on some architectures (amd64/386),</span>
    <span class="hljs-comment">// and fewer instructions (to calculate offset) on other architectures.</span>
    <span class="hljs-comment">// done&#x8868;&#x793A;&#x67D0;&#x4E2A;&#x52A8;&#x4F5C;&#x662F;&#x5426;&#x88AB;&#x6267;&#x884C;&#xFF0C;done&#x653E;&#x5728;&#x7B2C;&#x4E00;&#x4F4D;&#xFF0C;&#x5728;&#x67D0;&#x4E9B;&#x67B6;&#x6784;&#x4E0B;&#x53EF;&#x4EE5;&#x83B7;&#x5F97;&#x66F4;&#x52A0;&#x7D27;&#x51D1;&#x7684;&#x6307;&#x4EE4;</span>
    done <span class="hljs-keyword">uint32</span>
    m    Mutex
}

<span class="hljs-comment">// Do calls the function f if and only if Do is being called for the</span>
<span class="hljs-comment">// first time for this instance of Once. In other words, given</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//    var once Once</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// if once.Do(f) is called multiple times, only the first call will invoke f,</span>
<span class="hljs-comment">// even if f has a different value in each invocation. A new instance of</span>
<span class="hljs-comment">// Once is required for each function to execute.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Do is intended for initialization that must be run exactly once. Since f</span>
<span class="hljs-comment">// is niladic, it may be necessary to use a function literal to capture the</span>
<span class="hljs-comment">// arguments to a function to be invoked by Do:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//    config.once.Do(func() { config.init(filename) })</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Because no call to Do returns until the one call to f returns, if f causes</span>
<span class="hljs-comment">// Do to be called, it will deadlock.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// If f panics, Do considers it to have returned; future calls of Do return</span>
<span class="hljs-comment">// without calling f.</span>
<span class="hljs-comment">// Do&#x5F53;&#x4E14;&#x4EC5;&#x5F53;&#x7B2C;&#x4E00;&#x6B21;&#x8C03;&#x7528;&#x65F6;&#xFF0C;f&#x4F1A;&#x88AB;&#x6267;&#x884C;</span>
<span class="hljs-comment">// f&#x5982;&#x679C;&#x8C03;&#x7528;&#x4E86;Do&#x4F1A;&#x5BFC;&#x81F4;&#x6B7B;&#x9501;</span>
<span class="hljs-comment">// &#x5373;&#x4F7F;f&#x53D1;&#x751F;&#x4E86;panic&#xFF0C;&#x4E5F;&#x4E0D;&#x4F1A;&#x518D;&#x6B21;&#x8C03;&#x7528;</span>
<span class="hljs-keyword">func</span> (o *Once) Do(f <span class="hljs-keyword">func</span>()) {
    <span class="hljs-comment">// Note: Here is an incorrect implementation of Do:</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">//    if atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) {</span>
    <span class="hljs-comment">//        f()</span>
    <span class="hljs-comment">//    }</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Do guarantees that when it returns, f has finished.</span>
    <span class="hljs-comment">// This implementation would not implement that guarantee:</span>
    <span class="hljs-comment">// given two simultaneous calls, the winner of the cas would</span>
    <span class="hljs-comment">// call f, and the second would return immediately, without</span>
    <span class="hljs-comment">// waiting for the first&apos;s call to f to complete.</span>
    <span class="hljs-comment">// This is why the slow path falls back to a mutex, and why</span>
    <span class="hljs-comment">// the atomic.StoreUint32 must be delayed until after f returns.</span>
    <span class="hljs-comment">// &#x539F;&#x5B50;&#x8BFB;&#x53D6;Once&#x5185;&#x90E8;&#x7684;done&#x5C5E;&#x6027;&#xFF0C;&#x4E3A;0&#x5219;&#x8FDB;&#x5165;&#x6162;&#x901F;&#x8DEF;&#x5F84;&#xFF0C;&#x5426;&#x5219;&#x76F4;&#x63A5;&#x8C03;&#x7528;</span>
    <span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">0</span> {
        <span class="hljs-comment">// Outlined slow-path to allow inlining of the fast-path.</span>
        o.doSlow(f)
    }
}

<span class="hljs-keyword">func</span> (o *Once) doSlow(f <span class="hljs-keyword">func</span>()) {
    <span class="hljs-comment">// &#x5FC5;&#x987B;&#x52A0;&#x9501;&#xFF0C;&#x6709;&#x53EF;&#x80FD;&#x6709;&#x5F88;&#x591A;&#x4E2A;&#x534F;&#x7A0B;&#x8BFB;&#x5230;0</span>
    o.m.Lock()
    <span class="hljs-keyword">defer</span> o.m.Unlock()
    <span class="hljs-comment">// &#x4E00;&#x4E2A;&#x534F;&#x7A0B;&#x62FF;&#x5230;&#x9501;</span>
    <span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> {
        <span class="hljs-comment">// &#x5982;&#x679C;&#x662F;0&#xFF0C;&#x4EE3;&#x8868;&#x6CA1;&#x6267;&#x884C;&#x8FC7;&#xFF0C;&#x6267;&#x884C;f&#xFF0C;&#x5E76;&#x66F4;&#x65B0;done&#x503C;</span>
        <span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)
        f()
    }
}
</code></pre>
<h2 id="2&#x3001;&#x539F;&#x5B50;&#x64CD;&#x4F5C;">2&#x3001;&#x539F;&#x5B50;&#x64CD;&#x4F5C;</h2>
<p>atomic&#x5305;&#x4E2D;&#x5305;&#x542B;&#x4E86;&#x5F88;&#x591A;&#x539F;&#x5B50;&#x578B;&#x64CD;&#x4F5C;&#x3002;&#x5B83;&#x4EEC;&#x5747;&#x57FA;&#x4E8E;&#x8FD0;&#x884C;<code>runtime/internal/atomic</code> &#x7684;&#x5B9E;&#x73B0;&#x3002;</p>
<p>&#x539F;&#x5B50;&#x64CD;&#x4F5C;&#x4F9D;&#x8D56;&#x786C;&#x4EF6;&#x6307;&#x4EE4;&#x7684;&#x652F;&#x6301;&#xFF0C;&#x4F46;&#x540C;&#x65F6;&#x8FD8;&#x9700;&#x8981;&#x8FD0;&#x884C;&#x65F6;&#x8C03;&#x5EA6;&#x5668;&#x7684;&#x914D;&#x5408;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-keyword">func</span> CompareAndSwapPointer(addr *unsafe.Pointer, old, <span class="hljs-built_in">new</span> unsafe.Pointer) (swapped <span class="hljs-keyword">bool</span>)
</code></pre>
<p>&#x51FD;&#x6570;&#x4EC5;&#x6709;&#x5B9A;&#x4E49;&#xFF0C;&#x5176;&#x672C;&#x8EAB;&#x7531;&#x8FD0;&#x884C;&#x65F6;&#x5B9E;&#x73B0;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">//go:linkname sync_atomic_CompareAndSwapUintptr sync/atomic.CompareAndSwapUintptr</span>
<span class="hljs-keyword">func</span> sync_atomic_CompareAndSwapUintptr(ptr *<span class="hljs-keyword">uintptr</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">uintptr</span>) <span class="hljs-keyword">bool</span>

<span class="hljs-comment">//go:linkname sync_atomic_CompareAndSwapPointer sync/atomic.CompareAndSwapPointer</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-keyword">func</span> sync_atomic_CompareAndSwapPointer(ptr *unsafe.Pointer, old, <span class="hljs-built_in">new</span> unsafe.Pointer) <span class="hljs-keyword">bool</span> {
    <span class="hljs-keyword">if</span> writeBarrier.enabled {
        atomicwb(ptr, <span class="hljs-built_in">new</span>)
    }
    <span class="hljs-keyword">return</span> sync_atomic_CompareAndSwapUintptr((*<span class="hljs-keyword">uintptr</span>)(noescape(unsafe.Pointer(ptr))), <span class="hljs-keyword">uintptr</span>(old), <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">new</span>))
}
</code></pre>
<pre><code class="lang-text">// bool    &#xB7;Cas64(uint64 *val, uint64 old, uint64 new)
// Atomically:
//    if(*val == old){
//        *val = new;
//        return 1;
//    } else {
//        return 0;
//    }
TEXT &#xB7;Cas64(SB), NOSPLIT, $0-25
    MOVQ    ptr+0(FP), BX
    MOVQ    old+8(FP), AX
    MOVQ    new+16(FP), CX
    LOCK
    CMPXCHGQ    CX, 0(BX)
    SETEQ    ret+24(FP)
    RET
</code></pre>
<p>&#x5B9E;&#x73B0;&#x7684;&#x672C;&#x8D28;&#x662F;&#x4F7F;&#x7528;CPU&#x7684;LOCK&#x548C;CMPXCHGQ&#x6307;&#x4EE4;&#x3002;<span style="color:red">&#x539F;&#x5B50;&#x64CD;&#x4F5C;&#x672C;&#x8D28;&#x4E0A;&#x5747;&#x4E3A;&#x4F7F;&#x7528;CPU&#x6307;&#x4EE4;&#x8FDB;&#x884C;&#x5B9E;&#x73B0;&#x3002;</span></p>
<p>&#x539F;&#x5B50;&#x503C;&#x9700;&#x8981;&#x8FD0;&#x884C;&#x65F6;&#x7684;&#x652F;&#x6301;&#xFF0C;&#x5728;&#x539F;&#x5B50;&#x503C;&#x8FDB;&#x884C;&#x4FEE;&#x6539;&#x65F6;&#xFF0C;&#x534F;&#x7A0B;&#x4E0D;&#x5E94;&#x8BE5;&#x88AB;&#x62A2;&#x5360;&#xFF0C;&#x56E0;&#x6B64;&#x9700;&#x8981;&#x9501;&#x5B9A;MP&#x4E4B;&#x95F4;&#x7684;&#x7ED1;&#x5B9A;&#x5173;&#x7CFB;</p>
<pre><code class="lang-go"><span class="hljs-comment">// src/runtime/proc.go</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-keyword">func</span> procPin() <span class="hljs-keyword">int</span> {
    gp := getg()
    mp := gp.m

    mp.locks++
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">int</span>(mp.p.ptr().id)
}

<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-keyword">func</span> procUnpin() {
    gp := getg()
    gp.m.locks--
}

<span class="hljs-comment">//go:linkname sync_runtime_procPin sync.runtime_procPin</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-keyword">func</span> sync_runtime_procPin() <span class="hljs-keyword">int</span> {
    <span class="hljs-keyword">return</span> procPin()
}

<span class="hljs-comment">//go:linkname sync_runtime_procUnpin sync.runtime_procUnpin</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-keyword">func</span> sync_runtime_procUnpin() {
    procUnpin()
}

<span class="hljs-comment">//go:linkname sync_atomic_runtime_procPin sync/atomic.runtime_procPin</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-keyword">func</span> sync_atomic_runtime_procPin() <span class="hljs-keyword">int</span> {
    <span class="hljs-keyword">return</span> procPin()
}

<span class="hljs-comment">//go:linkname sync_atomic_runtime_procUnpin sync/atomic.runtime_procUnpin</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-keyword">func</span> sync_atomic_runtime_procUnpin() {
    procUnpin()
}
</code></pre>
<p>&#x539F;&#x5B50;&#x503C;atomic.Value&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x79CD;&#x5177;&#x5907;&#x539F;&#x5B50;&#x5B58;&#x53D6;&#x7684;&#x7ED3;&#x6784;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// src/sync/atomic/value.go</span>
<span class="hljs-comment">// A Value provides an atomic load and store of a consistently typed value.</span>
<span class="hljs-comment">// The zero value for a Value returns nil from Load.</span>
<span class="hljs-comment">// Once Store has been called, a Value must not be copied.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// A Value must not be copied after first use.</span>
<span class="hljs-keyword">type</span> Value <span class="hljs-keyword">struct</span> {
    v any
}
</code></pre>
<p>&#x8BFB;&#x53D6;&#x65B9;&#x6CD5;&#xFF1A;&#x8FD9;&#x4E2A;Load&#x65B9;&#x6CD5;&#x5B9E;&#x9645;&#x4E0A;&#x4F7F;&#x7528;&#x4E86;Go&#x8FD0;&#x884C;&#x65F6;&#x7C7B;&#x578B;&#x7CFB;&#x7EDF;interface{}&#x8FD9;&#x4E00;&#x7C7B;&#x578B;&#x672C;&#x8D28;&#x4E0A;&#x7531;&#x4E24;&#x6BB5;&#x5185;&#x5BB9;&#x7EC4;&#x6210;&#xFF0C;&#x4E00;&#x4E2A;&#x662F;&#x7C7B;&#x578B;typ&#x533A;&#x57DF;&#xFF0C;&#x53E6;&#x4E00;&#x4E2A;&#x662F;&#x5B9E;&#x9645;&#x6570;&#x636E;data&#x533A;&#x57DF;&#x3002;Load&#x65B9;&#x6CD5;&#x7684;&#x5B9E;&#x73B0;&#x672C;&#x8D28;&#x4E0A;&#x5C31;&#x662F;&#x5C06;&#x5185;&#x90E8;&#x5B58;&#x50A8;&#x7684;&#x7C7B;&#x578B;&#x548C;&#x6570;&#x636E;&#x90FD;&#x590D;&#x5236;&#x4E00;&#x4EFD;&#x5E76;&#x8FD4;&#x56DE;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// interface{}&#x7C7B;&#x578B;&#x7684;&#x5185;&#x90E8;&#x8868;&#x793A;</span>
<span class="hljs-comment">// efaceWords is interface{} internal representation.</span>
<span class="hljs-keyword">type</span> efaceWords <span class="hljs-keyword">struct</span> {
    typ  unsafe.Pointer <span class="hljs-comment">// &#x7C7B;&#x578B;&#x90E8;&#x5206;</span>
    data unsafe.Pointer <span class="hljs-comment">// &#x6570;&#x503C;&#x90E8;&#x5206;</span>
}

<span class="hljs-comment">// Load returns the value set by the most recent Store.</span>
<span class="hljs-comment">// It returns nil if there has been no call to Store for this Value.</span>
<span class="hljs-keyword">func</span> (v *Value) Load() (val any) {
    <span class="hljs-comment">// &#x83B7;&#x5F97;interface&#x7ED3;&#x6784;&#x6307;&#x9488;</span>
    vp := (*efaceWords)(unsafe.Pointer(v))
    <span class="hljs-comment">// &#x83B7;&#x5F97;&#x5B58;&#x50A8;&#x503C;&#x7684;&#x7C7B;&#x578B;&#x6307;&#x9488;</span>
    typ := LoadPointer(&amp;vp.typ)
    <span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> || typ == unsafe.Pointer(&amp;firstStoreInProgress) {
        <span class="hljs-comment">// First store not yet completed.</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
    <span class="hljs-comment">// &#x83B7;&#x5F97;&#x5B58;&#x50A8;&#x503C;&#x7684;&#x6570;&#x636E;&#x6307;&#x9488;</span>
    data := LoadPointer(&amp;vp.data)
    <span class="hljs-comment">// &#x590D;&#x5236;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61;&#x8D4B;&#x503C;&#x5E76;&#x8FD4;&#x56DE;</span>
    vlp := (*efaceWords)(unsafe.Pointer(&amp;val))
    vlp.typ = typ
    vlp.data = data
    <span class="hljs-keyword">return</span>
}
</code></pre>
<p>&#x5B58;&#x50A8;&#x65B9;&#x6CD5;&#xFF1A;&#x7531;&#x4E8E;&#x7C7B;&#x578B;&#x7CFB;&#x7EDF;&#x7684;&#x4E24;&#x6BB5;&#x5F0F;&#x8868;&#x793A;&#xFF08;typ&#x548C;data&#xFF09;&#x7684;&#x5B58;&#x5728;&#xFF0C;&#x5B58;&#x50A8;&#x64CD;&#x4F5C;&#x6BD4;&#x8BFB;&#x53D6;&#x64CD;&#x4F5C;&#x7684;&#x5B9E;&#x73B0;&#x8981;&#x66F4;&#x52A0;&#x5C0F;&#x5FC3;&#xFF0C;&#x8981;&#x8003;&#x8651;&#x5F53;&#x4E24;&#x4E2A;&#x4E0D;&#x540C;&#x7684;&#x534F;&#x7A0B;&#x5BF9;&#x4E24;&#x6BB5;&#x503C;&#x8FDB;&#x884C;&#x5199;&#x5165;&#x65F6;&#xFF0C;&#x9700;&#x8981;&#x907F;&#x514D;&#x5199;&#x7ADE;&#x4E89;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-keyword">var</span> firstStoreInProgress <span class="hljs-keyword">byte</span>

<span class="hljs-comment">// Store sets the value of the Value v to val.</span>
<span class="hljs-comment">// All calls to Store for a given Value must use values of the same concrete type.</span>
<span class="hljs-comment">// Store of an inconsistent type panics, as does Store(nil).</span>
<span class="hljs-keyword">func</span> (v *Value) Store(val any) {
    <span class="hljs-keyword">if</span> val == <span class="hljs-literal">nil</span> {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync/atomic: store of nil value into Value&quot;</span>)
    }
    vp := (*efaceWords)(unsafe.Pointer(v))
    vlp := (*efaceWords)(unsafe.Pointer(&amp;val))
    <span class="hljs-keyword">for</span> {
        typ := LoadPointer(&amp;vp.typ)
        <span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> {
            <span class="hljs-comment">// &#x7B2C;&#x4E00;&#x6B21;&#x5B58;&#x50A8;&#x6570;&#x636E;&#xFF0C;&#x8981;&#x4FDD;&#x8BC1;&#x7B2C;&#x4E00;&#x6B21;&#x5B58;&#x50A8;&#x987A;&#x5229;&#x5B8C;&#x6210;</span>
            <span class="hljs-comment">// Attempt to start first store.</span>
            <span class="hljs-comment">// Disable preemption so that other goroutines can use</span>
            <span class="hljs-comment">// active spin wait to wait for completion.</span>
            <span class="hljs-comment">// &#x7981;&#x6B62;&#x62A2;&#x5360;&#x5F53;&#x524D;&#x534F;&#x7A0B;&#x6765;&#x786E;&#x4FDD;&#x5B58;&#x50A8;&#x987A;&#x5229;&#x5B8C;&#x6210;</span>
            runtime_procPin()
            <span class="hljs-keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="hljs-literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) {
                <span class="hljs-comment">// &#x5982;&#x679C;&#x6CA1;&#x6709;&#x6210;&#x529F;&#xFF0C;&#x53D6;&#x6D88;&#x4E0D;&#x53EF;&#x62A2;&#x5360;&#xFF0C;&#x4E0B;&#x6B21;&#x518D;&#x8BD5;</span>
                runtime_procUnpin()
                <span class="hljs-keyword">continue</span>
            }
            <span class="hljs-comment">// Complete first store.</span>
            <span class="hljs-comment">// &#x6807;&#x5FD7;&#x4F4D;&#x8BBE;&#x7F6E;&#x6210;&#x529F;&#xFF0C;&#x5219;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x4E0D;&#x4F1A;&#x5199;&#x5165;&#xFF0C;&#x653E;&#x5FC3;&#x5B58;&#x50A8;</span>
            StorePointer(&amp;vp.data, vlp.data)
            StorePointer(&amp;vp.typ, vlp.typ)
            <span class="hljs-comment">// &#x53D6;&#x6D88;&#x4E0D;&#x53EF;&#x62A2;&#x5360;&#xFF0C;&#x8FD4;&#x56DE;</span>
            runtime_procUnpin()
            <span class="hljs-keyword">return</span>
        }

        <span class="hljs-comment">// &#x7B49;&#x5F85;&#x521D;&#x6B21;&#x5B58;&#x50A8;&#x5B8C;&#x6210;</span>
        <span class="hljs-keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) {
            <span class="hljs-comment">// First store in progress. Wait.</span>
            <span class="hljs-comment">// Since we disable preemption around the first store,</span>
            <span class="hljs-comment">// we can wait with active spinning.</span>
            <span class="hljs-keyword">continue</span>
        }
        <span class="hljs-comment">// First store completed. Check type and overwrite data.</span>
        <span class="hljs-comment">// &#x68C0;&#x67E5;&#x7C7B;&#x578B;&#x662F;&#x5426;&#x4E00;&#x81F4;</span>
        <span class="hljs-keyword">if</span> typ != vlp.typ {
            <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync/atomic: store of inconsistently typed value into Value&quot;</span>)
        }
        <span class="hljs-comment">// &#x7C7B;&#x578B;&#x5DF2;&#x7ECF;&#x5199;&#x5165;&#xFF0C;&#x76F4;&#x63A5;&#x4FDD;&#x5B58;&#x6570;&#x636E;</span>
        <span class="hljs-comment">// &#x4E0D;&#x662F;&#x7B2C;&#x4E00;&#x6B21;&#x5B58;&#x50A8;&#xFF0C;&#x53EA;&#x9700;&#x8981;&#x539F;&#x5B50;&#x66F4;&#x65B0;&#x503C;&#x5373;&#x53EF;</span>
        StorePointer(&amp;vp.data, vlp.data)
        <span class="hljs-keyword">return</span>
    }
}
</code></pre>
<p>&#x53EA;&#x6709;&#x5728;&#x7B2C;&#x4E00;&#x6B21;&#x5B58;&#x50A8;&#x65F6;&#xFF0C;&#x7981;&#x6B62;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x62A2;&#x5360;&#xFF0C;&#x4EE5;&#x786E;&#x4FDD;&#x7C7B;&#x578B;&#x8D4B;&#x503C;&#x8FD9;&#x4E2A;&#x5173;&#x952E;&#x64CD;&#x4F5C;&#x80FD;&#x987A;&#x5229;&#x5B8C;&#x6210;&#x3002;&#x5728;&#x7B2C;&#x4E00;&#x6B21;&#x5B58;&#x50A8;&#x65F6;&#xFF0C;sync/atomic.Value&#x9700;&#x8981;&#x521D;&#x59CB;&#x5316;&#x7C7B;&#x578B;&#x4FE1;&#x606F;&#xFF0C;&#x5E76;&#x5C06;&#x6570;&#x636E;&#x6307;&#x9488;&#x4E0E;&#x7C7B;&#x578B;&#x6307;&#x9488;&#x4E00;&#x8D77;&#x539F;&#x5B50;&#x6027;&#x5730;&#x5B58;&#x50A8;&#x5230;Value&#x4E2D;&#x3002;</p>
<p>&#x7B2C;&#x4E00;&#x6B21;&#x5B58;&#x50A8;&#x65F6;&#x7981;&#x6B62;&#x62A2;&#x5360;&#x7684;&#x76EE;&#x7684;&#x662F;&#x4E3A;&#x4E86;&#x907F;&#x514D;&#x5728;&#x5B58;&#x50A8;&#x8FC7;&#x7A0B;&#x4E2D;&#x88AB;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x6253;&#x65AD;&#xFF0C;&#x786E;&#x4FDD;typ&#x548C;data&#x7684;&#x5B58;&#x50A8;&#x64CD;&#x4F5C;&#x80FD;&#x591F;&#x8FDE;&#x7EED;&#x5B8C;&#x6210;&#x3002;&#x5982;&#x679C;&#x5728;&#x7B2C;&#x4E00;&#x6B21;&#x5B58;&#x50A8;&#x65F6;&#x88AB;&#x62A2;&#x5360;&#xFF0C;&#x53EF;&#x80FD;&#x4F1A;&#x5BFC;&#x81F4;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x5728;&#x8BFB;&#x53D6;&#x6216;&#x5B58;&#x50A8;&#x6570;&#x636E;&#x65F6;&#x9047;&#x5230;&#x4E0D;&#x4E00;&#x81F4;&#x7684;&#x72B6;&#x6001;&#x3002;</p>
<p>&#x5728;&#x7B2C;&#x4E00;&#x6B21;&#x5B58;&#x50A8;&#x4E4B;&#x540E;&#xFF0C;Value&#x7684;typ&#x5B57;&#x6BB5;&#x5DF2;&#x7ECF;&#x8BBE;&#x7F6E;&#x5B8C;&#x6210;&#xFF0C;&#x6B64;&#x65F6;&#x518D;&#x8FDB;&#x884C;&#x5B58;&#x50A8;&#x65F6;&#x4E0D;&#x518D;&#x9700;&#x8981;&#x7981;&#x6B62;&#x62A2;&#x5360;&#xFF0C;&#x56E0;&#x4E3A;&#x540E;&#x7EED;&#x7684;&#x5B58;&#x50A8;&#x64CD;&#x4F5C;&#x53EA;&#x9700;&#x8981;&#x68C0;&#x67E5;&#x7C7B;&#x578B;&#x4E00;&#x81F4;&#x6027;&#x5E76;&#x66F4;&#x65B0;&#x6570;&#x636E;&#x5373;&#x53EF;&#xFF0C;&#x4E0D;&#x6D89;&#x53CA;&#x521D;&#x59CB;&#x5316;&#x64CD;&#x4F5C;&#x3002;&#x540E;&#x7EED;&#x5B58;&#x50A8;&#x7684;&#x7C7B;&#x578B;&#x68C0;&#x67E5;&#x548C;&#x6570;&#x636E;&#x66F4;&#x65B0;&#x64CD;&#x4F5C;&#x90FD;&#x662F;&#x539F;&#x5B50;&#x6027;&#x7684;&#xFF0C;&#x53EF;&#x4EE5;&#x5728;&#x534F;&#x7A0B;&#x88AB;&#x62A2;&#x5360;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x5B89;&#x5168;&#x8FDB;&#x884C;&#x3002;</p>
<h2 id="3&#x3001;&#x6761;&#x4EF6;&#x53D8;&#x91CF;">3&#x3001;&#x6761;&#x4EF6;&#x53D8;&#x91CF;</h2>
<p>&#x4E00;&#x79CD;&#x540C;&#x6B65;&#x539F;&#x8BED;&#xFF0C;&#x7528;&#x4E8E;&#x534F;&#x7A0B;&#xFF08;&#x6216;&#x7EBF;&#x7A0B;&#xFF09;&#x4E4B;&#x95F4;&#x7684;&#x534F;&#x8C03;&#x4E0E;&#x901A;&#x4FE1;&#x3002;&#x5B83;&#x5141;&#x8BB8;&#x4E00;&#x4E2A;&#x6216;&#x591A;&#x4E2A;&#x534F;&#x7A0B;&#x7B49;&#x5F85;&#x67D0;&#x4E2A;&#x6761;&#x4EF6;&#x6EE1;&#x8DB3;&#xFF0C;&#x5E76;&#x5728; &#x6761;&#x4EF6;&#x6EE1;&#x8DB3;&#x65F6;&#x88AB;&#x5524;&#x9192;&#xFF0C;&#x7EE7;&#x7EED;&#x6267;&#x884C;&#x540E;&#x7EED;&#x64CD;&#x4F5C;&#x3002;<span style="color:red">&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x901A;&#x5E38;&#x4E0E;&#x4E92;&#x65A5;&#x9501;&#x4E00;&#x8D77;&#x4F7F;&#x7528;&#xFF0C;&#x4EE5;&#x786E;&#x4FDD;&#x5BF9;&#x5171;&#x4EAB;&#x8D44;&#x6E90;&#x7684;&#x5B89;&#x5168;&#x8BBF;&#x95EE;&#x3002;</span></p>
<p><span style="color:red">&#x5728;&#x5171;&#x4EAB;&#x8D44;&#x6E90;&#x4E0D;&#x6EE1;&#x8DB3;&#x67D0;&#x4E9B;&#x6761;&#x4EF6;&#x65F6;&#xFF0C;&#x5C06;&#x534F;&#x7A0B;&#x6302;&#x8D77;&#xFF0C;&#x4ECE;&#x800C;&#x907F;&#x514D;&#x5FD9;&#x7B49;&#xFF0C;&#x5E76;&#x5728;&#x6761;&#x4EF6;&#x6EE1;&#x8DB3;&#x65F6;&#x901A;&#x8FC7;&#x901A;&#x77E5;&#x673A;&#x5236;&#x5524;&#x9192;&#x7B49;&#x5F85;&#x7684;&#x534F;&#x7A0B;&#x3002;</span></p>
<p>&#x4F7F;&#x7528;&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x7684;&#x6B65;&#x9AA4;&#xFF1A;</p>
<ol>
<li>&#x83B7;&#x53D6;&#x9501;&#xFF1A;&#x5728;&#x64CD;&#x4F5C;&#x5171;&#x4EAB;&#x8D44;&#x6E90;&#x4E4B;&#x524D;&#xFF0C;&#x901A;&#x5E38;&#x9700;&#x8981;&#x5148;&#x83B7;&#x53D6;&#x4E92;&#x65A5;&#x9501;&#x3002;</li>
<li>&#x68C0;&#x67E5;&#x6761;&#x4EF6;&#xFF1A;&#x68C0;&#x67E5;&#x5171;&#x4EAB;&#x8D44;&#x6E90;&#x662F;&#x5426;&#x6EE1;&#x8DB3;&#x67D0;&#x4E2A;&#x6761;&#x4EF6;&#x3002;&#x5982;&#x679C;&#x6761;&#x4EF6;&#x4E0D;&#x6EE1;&#x8DB3;&#xFF0C;&#x5219;&#x8C03;&#x7528;&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x7684;&#x7B49;&#x5F85;&#x65B9;&#x6CD5;&#xFF0C;&#x5C06;&#x5F53;&#x524D;&#x534F;&#x7A0B;&#x6302;&#x8D77;&#xFF0C;&#x5E76;&#x91CA;&#x653E;&#x4E92;&#x65A5;&#x9501;&#x3002;</li>
<li>&#x7B49;&#x5F85;&#x6761;&#x4EF6;&#xFF1A;&#x5728;&#x7B49;&#x5F85;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x5F53;&#x524D;&#x534F;&#x7A0B;&#x4F1A;&#x88AB;&#x6302;&#x8D77;&#xFF0C;&#x4E0D;&#x5360;&#x7528;CPU&#x8D44;&#x6E90;&#x3002;&#x6B64;&#x65F6;&#xFF0C;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x53EF;&#x4EE5;&#x83B7;&#x53D6;&#x4E92;&#x65A5;&#x9501;&#x5E76;&#x4FEE;&#x6539;&#x5171;&#x4EAB;&#x8D44;&#x6E90;&#x3002;</li>
<li>&#x6761;&#x4EF6;&#x6EE1;&#x8DB3;&#x88AB;&#x5524;&#x9192;&#xFF1A;&#x5F53;&#x6761;&#x4EF6;&#x6EE1;&#x8DB3;&#x65F6;&#xFF0C;&#x67D0;&#x4E2A;&#x534F;&#x7A0B;&#x4F1A;&#x901A;&#x8FC7;&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x7684;&#x901A;&#x77E5;&#x65B9;&#x6CD5;&#x5524;&#x9192;&#x7B49;&#x5F85;&#x7684;&#x534F;&#x7A0B;&#x3002;</li>
<li>&#x91CD;&#x65B0;&#x83B7;&#x53D6;&#x9501;&#xFF1A;&#x88AB;&#x5524;&#x9192;&#x7684;&#x534F;&#x7A0B;&#x4F1A;&#x91CD;&#x65B0;&#x83B7;&#x53D6;&#x4E92;&#x65A5;&#x9501;&#xFF0C;&#x5E76;&#x7EE7;&#x7EED;&#x6267;&#x884C;&#x540E;&#x7EED;&#x64CD;&#x4F5C;&#x3002;</li>
<li>&#x91CA;&#x653E;&#x9501;&#xFF1A;&#x64CD;&#x4F5C;&#x5B8C;&#x6210;&#x540E;&#xFF0C;&#x91CA;&#x653E;&#x4E92;&#x65A5;&#x9501;&#x3002;</li>
</ol>
<p>&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x7ED3;&#x6784;&#xFF1A;</p>
<p>&#x5185;&#x90E8;&#x7ED3;&#x6784;&#x5305;&#x542B;&#x4E00;&#x4E2A;&#x9501;&#xFF0C;&#x901A;&#x77E5;&#x5217;&#x8868;&#x4EE5;&#x53CA;&#x4E00;&#x4E2A;&#x590D;&#x5236;&#x68C0;&#x67E5;&#x5668;&#xFF0C;<span style="color:red">&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x7ED3;&#x6784;&#x4E0D;&#x5141;&#x8BB8;&#x88AB;&#x590D;&#x5236;&#x3002;</span></p>
<pre><code class="lang-go"><span class="hljs-comment">// src/sync/conf.go</span>
<span class="hljs-comment">// Cond implements a condition variable, a rendezvous point</span>
<span class="hljs-comment">// for goroutines waiting for or announcing the occurrence</span>
<span class="hljs-comment">// of an event.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Each Cond has an associated Locker L (often a *Mutex or *RWMutex),</span>
<span class="hljs-comment">// which must be held when changing the condition and</span>
<span class="hljs-comment">// when calling the Wait method.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// A Cond must not be copied after first use.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In the terminology of the Go memory model, Cond arranges that</span>
<span class="hljs-comment">// a call to Broadcast or Signal &#x201C;synchronizes before&#x201D; any Wait call</span>
<span class="hljs-comment">// that it unblocks.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// For many simple use cases, users will be better off using channels than a</span>
<span class="hljs-comment">// Cond (Broadcast corresponds to closing a channel, and Signal corresponds to</span>
<span class="hljs-comment">// sending on a channel).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// For more on replacements for sync.Cond, see [Roberto Clapis&apos;s series on</span>
<span class="hljs-comment">// advanced concurrency patterns], as well as [Bryan Mills&apos;s talk on concurrency</span>
<span class="hljs-comment">// patterns].</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// [Roberto Clapis&apos;s series on advanced concurrency patterns]: https://blogtitle.github.io/categories/concurrency/</span>
<span class="hljs-comment">// [Bryan Mills&apos;s talk on concurrency patterns]: https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view</span>
<span class="hljs-keyword">type</span> Cond <span class="hljs-keyword">struct</span> {
    noCopy noCopy

    <span class="hljs-comment">// L is held while observing or changing the condition</span>
    L Locker

    notify  notifyList
    checker copyChecker
}

<span class="hljs-comment">// NewCond returns a new Cond with Locker l.</span>
<span class="hljs-keyword">func</span> NewCond(l Locker) *Cond {
    <span class="hljs-keyword">return</span> &amp;Cond{L: l}
}
</code></pre>
<p>&#x590D;&#x5236;&#x68C0;&#x67E5;&#x5668;&#xFF1A;</p>
<pre><code class="lang-go"><span class="hljs-comment">// copyChecker holds back pointer to itself to detect object copying.</span>
<span class="hljs-keyword">type</span> copyChecker <span class="hljs-keyword">uintptr</span>

<span class="hljs-keyword">func</span> (c *copyChecker) check() {
    <span class="hljs-comment">// &#x6BD4;&#x8F83;&#x5B58;&#x50A8;&#x5728;copyChecker&#x4E2D;&#x7684;&#x5730;&#x5740;&#x548C;&#x672C;&#x8EAB;&#x7684;&#x5185;&#x5B58;&#x5730;&#x5740;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x540C;&#x90A3;&#x4E48;&#x53EF;&#x80FD;&#x88AB;&#x590D;&#x5236;&#x4E86;</span>
    <span class="hljs-comment">// &#x5982;&#x679C;&#x4E0D;&#x540C;&#xFF0C;&#x5219;&#x5C1D;&#x8BD5;&#x8BBE;&#x7F6E;&#x4E3A;&#x5F53;&#x524D;&#x5BF9;&#x8C61;&#x7684;&#x5730;&#x5740;&#x3002;</span>
    <span class="hljs-comment">// &#x7136;&#x540E;&#x518D;&#x6B21;&#x8FDB;&#x884C;&#x6BD4;&#x8F83;</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(*c) != <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;
        !atomic.CompareAndSwapUintptr((*<span class="hljs-keyword">uintptr</span>)(c), <span class="hljs-number">0</span>, <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;
        <span class="hljs-keyword">uintptr</span>(*c) != <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(c)) {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync.Cond is copied&quot;</span>)
    }
}
</code></pre>
<p>Wait/Signal/Broadcast</p>
<p>Wait&#x65B9;&#x6CD5;&#x5411;notifyList&#x6CE8;&#x518C;&#x4E00;&#x4E2A;&#x901A;&#x77E5;&#xFF0C;&#x7136;&#x540E;&#x963B;&#x585E;&#x5230;&#x88AB;&#x901A;&#x77E5;&#xFF0C;Signal&#x5219;&#x8D1F;&#x8D23;&#x901A;&#x77E5;&#x4E00;&#x4E2A;&#x5728;notifyList&#x6CE8;&#x518C;&#x8FC7;&#x7684;&#x7B49;&#x5F85;&#x8005;&#x534F;&#x7A0B;&#x53D1;&#x51FA;&#x901A;&#x77E5;&#xFF0C;Broadcast&#x76F4;&#x63A5;&#x7C97;&#x66B4;&#x7684;&#x5411;&#x6240;&#x6709;&#x7B49;&#x5F85;&#x8005;&#x90FD;&#x53D1;&#x51FA;&#x901A;&#x77E5;&#x3002;</p>
<p>&#x7EC6;&#x8282;&#xFF1A;</p>
<p>Wait&#xFF1A;</p>
<p>1&#x3001;Wait&#x539F;&#x5B50;&#x5F0F;&#x7684;&#x89E3;&#x9501;&#xFF0C;&#x5E76;&#x6682;&#x505C;&#x6267;&#x884C;&#x8C03;&#x7528;&#x7684;&#x534F;&#x7A0B;&#x3002;&#x5B83;&#x4F1A;&#x81EA;&#x52A8;&#x5730;&#x3001;&#x539F;&#x5B50;&#x5730;&#x89E3;&#x9501;&#x4E0E;&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x5173;&#x8054;&#x7684;&#x4E92;&#x65A5;&#x9501;&#xFF0C;&#x7136;&#x540E;&#x4F1A;&#x5C06;&#x8C03;&#x7528;Wait&#x7684;&#x534F;&#x7A0B;&#x7F6E;&#x4E8E;&#x963B;&#x585E;&#x72B6;&#x6001;&#xFF0C;&#x7B49;&#x5F85;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x901A;&#x8FC7;Signal&#x6216;Broadcast&#x5524;&#x9192;&#x5B83;&#x3002;</p>
<p><span style="color:red">&#x89E3;&#x9501;&#x64CD;&#x4F5C;&#x662F;&#x539F;&#x5B50;&#x6027;&#x7684;&#xFF0C;&#x610F;&#x5473;&#x7740;&#x5728;&#x534F;&#x7A0B;&#x88AB;&#x963B;&#x585E;&#x4E4B;&#x524D;&#xFF0C;&#x9501;&#x4F1A;&#x88AB;&#x91CA;&#x653E;&#xFF0C;&#x4ECE;&#x800C;&#x5141;&#x8BB8;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x8FDB;&#x5165;&#x4E34;&#x754C;&#x533A;&#x64CD;&#x4F5C;&#x3002;</span></p>
<p>2&#x3001;&#x5728;&#x7A0D;&#x540E;&#x6267;&#x884C;&#x540E;&#xFF0C;Wait&#x4F1A;&#x5728;&#x8FD4;&#x56DE;&#x524D;&#x52A0;&#x9501;&#x3002;&#x5F53;Wait&#x88AB;Signal&#x6216;Broadcast&#x5524;&#x9192;&#x65F6;&#xFF0C;Wait&#x65B9;&#x6CD5;&#x4F1A;&#x5728;&#x8FD4;&#x56DE;&#x4E4B;&#x524D;&#x91CD;&#x65B0;&#x9501;&#x5B9A;&#x4E0E;&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x5173;&#x8054;&#x7684;&#x4E92;&#x65A5;&#x9501;&#x3002;</p>
<p><span style="color:red">Wait&#x8FD4;&#x56DE;&#x65F6;&#xFF0C;&#x8C03;&#x7528;&#x5B83;&#x7684;&#x534F;&#x7A0B;&#x5DF2;&#x7ECF;&#x91CD;&#x65B0;&#x83B7;&#x53D6;&#x4E86;&#x4E92;&#x65A5;&#x9501;&#xFF0C;&#x786E;&#x4FDD;&#x8C03;&#x7528;&#x8005;&#x53EF;&#x4EE5;&#x5B89;&#x5168;&#x5730;&#x68C0;&#x67E5;&#x5E76;&#x64CD;&#x4F5C;&#x5171;&#x4EAB;&#x8D44;&#x6E90;&#x3002;</span></p>
<p>3&#x3001;&#x4E0E;&#x5176;&#x4ED6;&#x7CFB;&#x7EDF;&#x4E0D;&#x540C;&#xFF0C;&#x9664;&#x975E;&#x88AB;Broadcast&#x6216;Signal&#x5524;&#x9192;&#xFF0C;&#x5426;&#x5219;&#x7B49;&#x5F85;&#x65E0;&#x6CD5;&#x8FD4;&#x56DE;&#x3002;</p>
<p><span style="color:red">POSIX&#x7EBF;&#x7A0B;&#x5E93;&#x4E2D;&#x7684;&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x5B9E;&#x73B0;&#x53EF;&#x80FD;&#x5B58;&#x5728;&#x865A;&#x5047;&#x5524;&#x9192;&#xFF08;&#x5373;Wait&#x6CA1;&#x6709;&#x660E;&#x786E;&#x5524;&#x9192;&#x5C31;&#x8FD4;&#x56DE;&#xFF09;&#xFF0C;</span>Go&#x4E2D;&#x7684;&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x7684;&#x5B9E;&#x73B0;&#x4FDD;&#x8BC1;&#x53EA;&#x6709;&#x5728;&#x63A5;&#x6536;&#x5230;Signal&#x6216;Broadcast&#x540E;&#xFF0C;Wait&#x624D;&#x4F1A;&#x8FD4;&#x56DE;&#x3002;</p>
<p>4&#x3001;&#x56E0;&#x4E3A;&#x7B49;&#x5F85;&#x7B2C;&#x4E00;&#x6B21;&#x6062;&#x590D;&#x65F6;&#x6CA1;&#x6709;&#x5904;&#x4E8E;&#x9501;&#x5B9A;&#x72B6;&#x6001;&#xFF0C;&#x6240;&#x4EE5;&#x5F53;Wait&#x8FD4;&#x56DE;&#x65F6;&#xFF0C;&#x8C03;&#x7528;&#x8005;&#x901A;&#x5E38;&#x4E0D;&#x80FD;&#x8BA4;&#x4E3A;&#x6761;&#x4EF6;&#x4E3A;&#x771F;&#x3002;</p>
<p>&#x5F53;Wait&#x8FD4;&#x56DE;&#x65F6;&#xFF0C;&#x4E0D;&#x80FD;&#x76F4;&#x63A5;&#x5047;&#x8BBE;&#x7B49;&#x5F85;&#x7684;&#x6761;&#x4EF6;&#x5DF2;&#x7ECF;&#x6EE1;&#x8DB3;&#x4E86;&#xFF0C;&#x867D;&#x7136;Wait&#x8C03;&#x7528;&#x540E;&#x4F1A;&#x91CD;&#x65B0;&#x83B7;&#x5F97;&#x4E92;&#x65A5;&#x9501;&#xFF0C;&#x4F46;&#x5728;Wait&#x8FD4;&#x56DE;&#x4E4B;&#x524D;&#xFF0C;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x53EF;&#x80FD;&#x5DF2;&#x7ECF;&#x6539;&#x53D8;&#x4E86;&#x5171;&#x4EAB;&#x8D44;&#x6E90;&#x7684;&#x72B6;&#x6001;&#x3002;&#x56E0;&#x6B64;&#xFF0C;&#x6761;&#x4EF6;&#x53EF;&#x80FD;&#x4E0D;&#x518D;&#x4E3A;&#x771F;&#x3002;</p>
<p><span style="color:red">Wait&#x8FD4;&#x56DE;&#x65F6;&#xFF0C;&#x867D;&#x7136;&#x4E92;&#x65A5;&#x9501;&#x5DF2;&#x88AB;&#x91CD;&#x65B0;&#x83B7;&#x53D6;&#xFF0C;&#x4F46;&#x4ECD;&#x9700;&#x518D;&#x6B21;&#x68C0;&#x67E5;&#x6761;&#x4EF6;&#x662F;&#x5426;&#x6EE1;&#x8DB3;&#x3002;</span></p>
<p>5&#x3001;&#x8C03;&#x7528;&#x8005;&#x5E94;&#x8BE5;&#x5728;&#x5FAA;&#x73AF;&#x4E2D;&#x4F7F;&#x7528;Wait</p>
<p>&#x5BF9;&#x4F7F;&#x7528;&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x7684;&#x6700;&#x4F73;&#x5B9E;&#x8DF5;&#x7684;&#x5EFA;&#x8BAE;&#x3002;&#x7531;&#x4E8E;&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x5728;&#x88AB;&#x5524;&#x9192;&#x65F6;&#xFF0C;&#x6761;&#x4EF6;&#x53EF;&#x80FD;&#x5E76;&#x4E0D;&#x4E00;&#x5B9A;&#x4E3A;&#x771F;&#xFF0C;&#x56E0;&#x6B64;&#x8C03;&#x7528;Wait&#x7684;&#x6B63;&#x786E;&#x65B9;&#x5F0F;&#x662F;&#x5C06;&#x5B83;&#x653E;&#x5728;&#x5FAA;&#x73AF;&#x4E2D;&#xFF0C;&#x5E76;&#x5728;&#x6BCF;&#x6B21;&#x5524;&#x9192;&#x65F6;&#x91CD;&#x65B0;&#x68C0;&#x67E5;&#x6761;&#x4EF6;&#x662F;&#x5426;&#x6EE1;&#x8DB3;&#x3002;</p>
<p>Signal&#xFF1A;</p>
<p>1&#x3001;Signal&#x65B9;&#x6CD5;&#x4F1A;&#x5524;&#x9192;&#x4E00;&#x4E2A;&#x6B63;&#x5728;sync.Cond&#x4E0A;&#x7B49;&#x5F85;&#x7684;&#x534F;&#x7A0B;&#x3002;&#x8FD9;&#x4E2A;&#x5524;&#x9192;&#x7684;&#x534F;&#x7A0B;&#x662F;&#x4E4B;&#x524D;&#x8C03;&#x7528;&#x4E86;Wait&#x65B9;&#x6CD5;&#x5E76;&#x88AB;&#x963B;&#x585E;&#x7684;&#x67D0;&#x4E2A;&#x534F;&#x7A0B;&#x3002;</p>
<p><span style="color:red">Signal&#x53EA;&#x4F1A;&#x5524;&#x9192;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x7684;&#x534F;&#x7A0B;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x6240;&#x6709;&#x7B49;&#x5F85;&#x7684;&#x534F;&#x7A0B;&#x3002;&#x5982;&#x679C;&#x6709;&#x591A;&#x4E2A;&#x534F;&#x7A0B;&#x5728;&#x7B49;&#x5F85;&#xFF0C;&#x53EA;&#x6709;&#x5176;&#x4E2D;&#x4E00;&#x4E2A;&#x4F1A;&#x88AB;&#x5524;&#x9192;&#x3002;</span></p>
<p>2&#x3001;&#x8C03;&#x7528;Signal&#x65B9;&#x6CD5;&#xFF0C;&#x8C03;&#x7528;&#x8005;&#x53EF;&#x4EE5;&#x6301;&#x6709;sync.Cond&#x5173;&#x8054;&#x7684;&#x4E92;&#x65A5;&#x9501;&#xFF0C;&#x4F46;&#x8FD9;&#x4E0D;&#x662F;&#x5FC5;&#x987B;&#x7684;&#x3002;</p>
<p><span style="color:red">&#x5728;&#x67D0;&#x4E9B;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x6301;&#x6709;&#x4E92;&#x65A5;&#x9501;&#x6765;&#x8C03;&#x7528;Signal&#x53EF;&#x4EE5;&#x786E;&#x4FDD;&#x8C03;&#x7528;Signal&#x7684;&#x7EBF;&#x7A0B;&#x4E0E;&#x88AB;&#x5524;&#x9192;&#x7684;&#x7EBF;&#x7A0B;&#x4E4B;&#x95F4;&#x7684;&#x987A;&#x5E8F;&#x548C;&#x6570;&#x636E;&#x4E00;&#x81F4;&#x6027;&#x3002;&#x4F46;Go&#x8BED;&#x8A00;&#x7684;&#x8BBE;&#x8BA1;&#x5141;&#x8BB8;&#x4F60;&#x5728;&#x4E0D;&#x6301;&#x6709;&#x9501;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x8C03;&#x7528;Signal&#xFF0C;&#x8FD9;&#x63D0;&#x4F9B;&#x4E86;&#x66F4;&#x5927;&#x7684;&#x7075;&#x6D3B;&#x6027;&#x3002;</span></p>
<p>3&#x3001;&#x8C03;&#x7528;Signal&#x5E76;&#x4E0D;&#x4F1A;&#x6539;&#x53D8;&#x534F;&#x7A0B;&#x7684;&#x8C03;&#x5EA6;&#x4F18;&#x5148;&#x7EA7;&#x3002;&#x5982;&#x679C;&#x6709;&#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x6B63;&#x5728;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x4E92;&#x65A5;&#x9501;&#xFF0C;&#x8FD9;&#x4E9B;&#x534F;&#x7A0B;&#x53EF;&#x80FD;&#x4F1A;&#x5728;&#x5524;&#x9192;&#x7684;&#x7B49;&#x5F85;&#x534F;&#x7A0B;&#x4E4B;&#x524D;&#x88AB;&#x8C03;&#x5EA6;&#x6267;&#x884C;&#x3002;</p>
<p>Signal&#x53EA;&#x8D1F;&#x8D23;&#x5524;&#x9192;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x7684;&#x534F;&#x7A0B;&#xFF0C;&#x4F46;&#x5728;&#x7ADE;&#x4E89;&#x9501;&#x65F6;&#xFF0C;&#x8C03;&#x5EA6;&#x5668;&#x4E0D;&#x4F1A;&#x4F18;&#x5148;&#x8BA9;&#x8FD9;&#x4E2A;&#x88AB;&#x5524;&#x9192;&#x7684;&#x534F;&#x7A0B;&#x83B7;&#x5F97;&#x9501;&#x3002;&#x8FD9;&#x610F;&#x5473;&#x7740;&#x88AB;&#x5524;&#x9192;&#x7684;&#x534F;&#x7A0B;&#x53EF;&#x80FD;&#x5E76;&#x4E0D;&#x4F1A;&#x7ACB;&#x5373;&#x6267;&#x884C;&#xFF0C;&#x5176;&#x4ED6;&#x5C1D;&#x8BD5;&#x9501;&#x5B9A;&#x7684;&#x534F;&#x7A0B;&#x53EF;&#x80FD;&#x4F1A;&#x5148;&#x6267;&#x884C;&#x3002;</p>
<p><span style="color:red">Signal&#x8C03;&#x7528;&#x672C;&#x8EAB;&#x5E76;&#x4E0D;&#x4F1A;&#x81EA;&#x52A8;&#x89E3;&#x9501;&#x5173;&#x8054;&#x7684;&#x4E92;&#x65A5;&#x9501;&#x3002;&#x5728;&#x4F7F;&#x7528;&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x901A;&#x5E38;&#x7684;&#x505A;&#x6CD5;&#x662F;&#x5148;&#x9501;&#x5B9A;&#x4E92;&#x65A5;&#x9501;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x67D0;&#x4E9B;&#x6761;&#x4EF6;&#x4E0B;&#x8C03;&#x7528;Wait&#x65B9;&#x6CD5;&#x3002;Wait&#x65B9;&#x6CD5;&#x4F1A;&#x5728;&#x8C03;&#x7528;&#x65F6;&#x81EA;&#x52A8;&#x89E3;&#x9501;&#xFF0C;&#x88AB;&#x5524;&#x9192;&#x540E;&#x518D;&#x91CD;&#x65B0;&#x9501;&#x5B9A;&#x3002;&#x4F46;Signal&#x65B9;&#x6CD5;&#x53EA;&#x8D1F;&#x8D23;&#x5524;&#x9192;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x4E2D;&#x7684;&#x534F;&#x7A0B;&#xFF0C;&#x5E76;&#x4E0D;&#x4F1A;&#x89E3;&#x9501;&#x6216;&#x9501;&#x5B9A;&#x3002;</span></p>
<p>&#x5982;&#x679C;&#x5728;&#x8C03;&#x7528;Signal&#x4E4B;&#x524D;&#x6301;&#x6709;&#x4E86;&#x9501;&#xFF0C;&#x9501;&#x4ECD;&#x7136;&#x4F1A;&#x88AB;&#x6301;&#x6709;&#xFF0C;&#x76F4;&#x5230;&#x663E;&#x5F0F;&#x8C03;&#x7528;&#x89E3;&#x9501;&#x3002;</p>
<p>Broadcast&#x548C;Signal&#x539F;&#x7406;&#x5DEE;&#x4E0D;&#x591A;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Wait atomically unlocks c.L and suspends execution</span>
<span class="hljs-comment">// of the calling goroutine. After later resuming execution,</span>
<span class="hljs-comment">// Wait locks c.L before returning. Unlike in other systems,</span>
<span class="hljs-comment">// Wait cannot return unless awoken by Broadcast or Signal.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Because c.L is not locked while Wait is waiting, the caller</span>
<span class="hljs-comment">// typically cannot assume that the condition is true when</span>
<span class="hljs-comment">// Wait returns. Instead, the caller should Wait in a loop:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//    c.L.Lock()</span>
<span class="hljs-comment">//    for !condition() {</span>
<span class="hljs-comment">//        c.Wait()</span>
<span class="hljs-comment">//    }</span>
<span class="hljs-comment">//    ... make use of condition ...</span>
<span class="hljs-comment">//    c.L.Unlock()</span>
<span class="hljs-comment">// Wait &#x539F;&#x5B50;&#x5F0F;&#x7684; unlock c.L&#xFF0C; &#x5E76;&#x6682;&#x505C;&#x6267;&#x884C;&#x8C03;&#x7528;&#x7684; goroutine&#x3002;</span>
<span class="hljs-comment">// &#x5728;&#x7A0D;&#x540E;&#x6267;&#x884C;&#x540E;&#xFF0C;Wait &#x4F1A;&#x5728;&#x8FD4;&#x56DE;&#x524D; lock c.L. &#x4E0E;&#x5176;&#x4ED6;&#x7CFB;&#x7EDF;&#x4E0D;&#x540C;&#xFF0C;</span>
<span class="hljs-comment">// &#x9664;&#x975E;&#x88AB; Broadcast &#x6216; Signal &#x5524;&#x9192;&#xFF0C;&#x5426;&#x5219;&#x7B49;&#x5F85;&#x65E0;&#x6CD5;&#x8FD4;&#x56DE;&#x3002;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x56E0;&#x4E3A;&#x7B49;&#x5F85;&#x7B2C;&#x4E00;&#x6B21; resume &#x65F6; c.L &#x6CA1;&#x6709;&#x88AB;&#x9501;&#x5B9A;&#xFF0C;&#x6240;&#x4EE5;&#x5F53; Wait &#x8FD4;&#x56DE;&#x65F6;&#xFF0C;</span>
<span class="hljs-comment">// &#x8C03;&#x7528;&#x8005;&#x901A;&#x5E38;&#x4E0D;&#x80FD;&#x8BA4;&#x4E3A;&#x6761;&#x4EF6;&#x4E3A;&#x771F;&#x3002;&#x76F8;&#x53CD;&#xFF0C;&#x8C03;&#x7528;&#x8005;&#x5E94;&#x8BE5;&#x5728;&#x5FAA;&#x73AF;&#x4E2D;&#x4F7F;&#x7528; Wait()&#xFF1A;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//    c.L.Lock()</span>
<span class="hljs-comment">//    for !condition() {</span>
<span class="hljs-comment">//        c.Wait()</span>
<span class="hljs-comment">//    }</span>
<span class="hljs-comment">//    ... make use of condition ...</span>
<span class="hljs-comment">//    c.L.Unlock()</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">func</span> (c *Cond) Wait() {
    c.checker.check()
    t := runtime_notifyListAdd(&amp;c.notify)
    c.L.Unlock()
    runtime_notifyListWait(&amp;c.notify, t)
    c.L.Lock()
}

<span class="hljs-comment">// Signal wakes one goroutine waiting on c, if there is any.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// It is allowed but not required for the caller to hold c.L</span>
<span class="hljs-comment">// during the call.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Signal() does not affect goroutine scheduling priority; if other goroutines</span>
<span class="hljs-comment">// are attempting to lock c.L, they may be awoken before a &quot;waiting&quot; goroutine.</span>
<span class="hljs-comment">// Signal &#x5524;&#x9192;&#x4E00;&#x4E2A;&#x7B49;&#x5F85; c &#x7684; goroutine&#xFF08;&#x5982;&#x679C;&#x5B58;&#x5728;&#xFF09;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x5728;&#x8C03;&#x7528;&#x65F6;&#x5B83;&#x53EF;&#x4EE5;&#xFF08;&#x4E0D;&#x5FC5;&#x987B;&#xFF09;&#x6301;&#x6709;&#x4E00;&#x4E2A; c.L</span>
<span class="hljs-keyword">func</span> (c *Cond) Signal() {
    c.checker.check()
    runtime_notifyListNotifyOne(&amp;c.notify)
}

<span class="hljs-comment">// Broadcast wakes all goroutines waiting on c.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// It is allowed but not required for the caller to hold c.L</span>
<span class="hljs-comment">// during the call.</span>
<span class="hljs-comment">// Broadcast &#x5524;&#x9192;&#x7B49;&#x5F85; c &#x7684;&#x6240;&#x6709; goroutine</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x8C03;&#x7528;&#x65F6;&#x5B83;&#x53EF;&#x4EE5;&#xFF08;&#x4E0D;&#x5FC5;&#x987B;&#xFF09;&#x6301;&#x4E45;&#x6709;&#x4E2A; c.L</span>
<span class="hljs-keyword">func</span> (c *Cond) Broadcast() {
    c.checker.check()
    runtime_notifyListNotifyAll(&amp;c.notify)
}
</code></pre>
<p>notifyList</p>
<p>&#x6761;&#x4EF6;&#x53D8;&#x91CF;&#x7684;&#x5B9E;&#x73B0;&#x6838;&#x5FC3;&#x672C;&#x8D28;&#x4E0A;&#x662F;&#x4E00;&#x4E2A;&#x901A;&#x77E5;&#x5217;&#x8868;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x961F;&#x5217;&#x3002;</p>
<p>&#x5F53;&#x4E00;&#x4E2A;Cond&#x8C03;&#x7528;Wait&#x65B9;&#x6CD5;&#x65F6;&#xFF0C;&#x5411;Wait&#x5B57;&#x6BB5;&#x52A0;&#x4E00;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;ticket&#x7F16;&#x53F7;&#xFF0C;&#x7136;&#x540E;&#x4F7F;&#x7528;&#x8FD9;&#x4E2A;ticket&#x7F16;&#x53F7;&#x6765;&#x7B49;&#x5F85;&#x901A;&#x77E5;&#xFF0C;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x4F1A;&#x5C06;&#x7B49;&#x5F85;&#x901A;&#x77E5;&#x7684;&#x534F;&#x7A0B;&#x8FDB;&#x884C;&#x505C;&#x6CCA;&#xFF0C;&#x8FDB;&#x5165;&#x7B49;&#x5F85;&#x72B6;&#x6001;&#xFF0C;&#x5E76;&#x5C06;&#x5176;M&#x4E0E;P&#x89E3;&#x7ED1;&#xFF0C;&#x4ECE;&#x800C;&#x5C06;G&#x4ECE;M&#x8EAB;&#x4E0A;&#x5265;&#x79BB;&#xFF0C;&#x653E;&#x5165;&#x7B49;&#x5F85;&#x961F;&#x5217;sudog&#x4E2D;&#x3002;&#x5F53;Signal&#x8C03;&#x7528;&#x65F6;&#xFF0C;&#x4F1A;&#x6709;&#x4E00;&#x4E2A;&#x5728;&#x7B49;&#x5F85;&#x7684;&#x534F;&#x7A0B;&#x88AB;&#x901A;&#x77E5;&#x5230;&#xFF0C;&#x5177;&#x4F53;&#x8FC7;&#x7A0B;&#x5C31;&#x662F;&#x4ECE;sudog&#x5217;&#x8868;&#x4E2D;&#x627E;&#x5230;&#x8981;&#x901A;&#x77E5;&#x7684;&#x534F;&#x7A0B;&#xFF0C;&#x7136;&#x540E;&#x5C06;&#x5176;goready&#x6765;&#x7B49;&#x5F85;&#x8C03;&#x5EA6;&#x5FAA;&#x73AF;&#x5C06;&#x5176;&#x8C03;&#x5EA6;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// src/runtime/sema.go</span>
<span class="hljs-comment">// notifyList is a ticket-based notification list used to implement sync.Cond.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// It must be kept in sync with the sync package.</span>
<span class="hljs-keyword">type</span> notifyList <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// wait is the ticket number of the next waiter. It is atomically</span>
    <span class="hljs-comment">// incremented outside the lock.</span>
    <span class="hljs-comment">// wait &#x4E3A;&#x4E0B;&#x4E00;&#x4E2A; waiter &#x7684; ticket &#x7F16;&#x53F7;</span>
    <span class="hljs-comment">// &#x5728;&#x6CA1;&#x6709; lock &#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x539F;&#x5B50;&#x81EA;&#x589E;</span>
    wait atomic.Uint32

    <span class="hljs-comment">// notify is the ticket number of the next waiter to be notified. It can</span>
    <span class="hljs-comment">// be read outside the lock, but is only written to with lock held.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Both wait &amp; notify can wrap around, and such cases will be correctly</span>
    <span class="hljs-comment">// handled as long as their &quot;unwrapped&quot; difference is bounded by 2^31.</span>
    <span class="hljs-comment">// For this not to be the case, we&apos;d need to have 2^31+ goroutines</span>
    <span class="hljs-comment">// blocked on the same condvar, which is currently not possible.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// notify &#x662F;&#x4E0B;&#x4E00;&#x4E2A;&#x88AB;&#x901A;&#x77E5;&#x7684; waiter &#x7684; ticket &#x7F16;&#x53F7;</span>
    <span class="hljs-comment">// &#x5B83;&#x53EF;&#x4EE5;&#x5728;&#x6CA1;&#x6709; lock &#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x8FDB;&#x884C;&#x8BFB;&#x53D6;&#xFF0C;&#x4F46;&#x53EA;&#x6709;&#x5728;&#x6301;&#x6709; lock &#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x624D;&#x80FD;&#x8FDB;&#x884C;&#x5199;</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// wait &#x548C; notify &#x4F1A;&#x4EA7;&#x751F; wrap around&#xFF0C;&#x53EA;&#x8981;&#x5B83;&#x4EEC; &quot;unwrapped&quot;</span>
    <span class="hljs-comment">// &#x7684;&#x5DEE;&#x522B;&#x5C0F;&#x4E8E; 2^31&#xFF0C;&#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x53EF;&#x4EE5;&#x88AB;&#x6B63;&#x786E;&#x5904;&#x7406;&#x3002;&#x5BF9;&#x4E8E; wrap around &#x7684;&#x60C5;&#x51B5;&#x800C;&#x8A00;&#xFF0C;</span>
    <span class="hljs-comment">// &#x6211;&#x4EEC;&#x9700;&#x8981;&#x8D85;&#x8FC7; 2^31+ &#x4E2A; goroutine &#x963B;&#x585E;&#x5728;&#x76F8;&#x540C;&#x7684; condvar &#x4E0A;&#xFF0C;&#x8FD9;&#x662F;&#x4E0D;&#x53EF;&#x80FD;&#x7684;&#x3002;</span>
    <span class="hljs-comment">//</span>
    notify <span class="hljs-keyword">uint32</span>

    <span class="hljs-comment">// List of parked waiters.</span>
    <span class="hljs-comment">// waiter &#x5217;&#x8868;.</span>
    lock mutex
    head *sudog
    tail *sudog
}

<span class="hljs-comment">// less checks if a &lt; b, considering a &amp; b running counts that may overflow the</span>
<span class="hljs-comment">// 32-bit range, and that their &quot;unwrapped&quot; difference is always less than 2^31.</span>
<span class="hljs-keyword">func</span> less(a, b <span class="hljs-keyword">uint32</span>) <span class="hljs-keyword">bool</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">int32</span>(a-b) &lt; <span class="hljs-number">0</span>
}

<span class="hljs-comment">// notifyListAdd adds the caller to a notify list such that it can receive</span>
<span class="hljs-comment">// notifications. The caller must eventually call notifyListWait to wait for</span>
<span class="hljs-comment">// such a notification, passing the returned ticket number.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// notifyListAdd &#x5C06;&#x8C03;&#x7528;&#x8005;&#x6DFB;&#x52A0;&#x5230;&#x901A;&#x77E5;&#x5217;&#x8868;&#xFF0C;&#x4EE5;&#x4FBF;&#x63A5;&#x6536;&#x901A;&#x77E5;&#x3002;</span>
<span class="hljs-comment">// &#x8C03;&#x7528;&#x8005;&#x6700;&#x7EC8;&#x5FC5;&#x987B;&#x8C03;&#x7528; notifyListWait &#x7B49;&#x5F85;&#x8FD9;&#x6837;&#x7684;&#x901A;&#x77E5;&#xFF0C;&#x5E76;&#x4F20;&#x9012;&#x8FD4;&#x56DE;&#x7684; ticket &#x7F16;&#x53F7;&#x3002;</span>
<span class="hljs-comment">//go:linkname notifyListAdd sync.runtime_notifyListAdd</span>
<span class="hljs-keyword">func</span> notifyListAdd(l *notifyList) <span class="hljs-keyword">uint32</span> {
    <span class="hljs-comment">// This may be called concurrently, for example, when called from</span>
    <span class="hljs-comment">// sync.Cond.Wait while holding a RWMutex in read mode.</span>
    <span class="hljs-comment">// &#x8FD9;&#x53EF;&#x4EE5;&#x5E76;&#x53D1;&#x8C03;&#x7528;&#xFF0C;&#x4F8B;&#x5982;&#xFF0C;&#x5F53;&#x5728; read &#x6A21;&#x5F0F;&#x4E0B;&#x4FDD;&#x6301; RWMutex &#x65F6;&#x4ECE; sync.Cond.Wait &#x8C03;&#x7528;&#x65F6;&#x3002;</span>
    <span class="hljs-keyword">return</span> l.wait.Add(<span class="hljs-number">1</span>) - <span class="hljs-number">1</span>
}

<span class="hljs-comment">// notifyListWait waits for a notification. If one has been sent since</span>
<span class="hljs-comment">// notifyListAdd was called, it returns immediately. Otherwise, it blocks.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// notifyListWait &#x7B49;&#x5F85;&#x901A;&#x77E5;&#x3002;&#x5982;&#x679C;&#x5728;&#x8C03;&#x7528; notifyListAdd &#x540E;&#x53D1;&#x9001;&#x4E86;&#x4E00;&#x4E2A;&#xFF0C;&#x5219;&#x7ACB;&#x5373;&#x8FD4;&#x56DE;&#x3002;&#x5426;&#x5219;&#xFF0C;&#x5B83;&#x4F1A;&#x963B;&#x585E;&#x3002;</span>
<span class="hljs-comment">//go:linkname notifyListWait sync.runtime_notifyListWait</span>
<span class="hljs-keyword">func</span> notifyListWait(l *notifyList, t <span class="hljs-keyword">uint32</span>) {
    <span class="hljs-comment">// &#x9501;&#x5B9A;&#x901A;&#x77E5;&#x5217;&#x8868;&#xFF0C;&#x786E;&#x4FDD;&#x5E76;&#x53D1;&#x5B89;&#x5168;&#x6027;</span>
    lockWithRank(&amp;l.lock, lockRankNotifyList)

    <span class="hljs-comment">// Return right away if this ticket has already been notified.</span>
    <span class="hljs-comment">// &#x5982;&#x679C; ticket &#x7F16;&#x53F7;&#x5BF9;&#x5E94;&#x7684; goroutine &#x5DF2;&#x7ECF;&#x88AB;&#x901A;&#x77E5;&#x5230;&#xFF0C;&#x5219;&#x7ACB;&#x523B;&#x8FD4;&#x56DE;</span>
    <span class="hljs-keyword">if</span> less(t, l.notify) {
        unlock(&amp;l.lock)
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-comment">// Enqueue itself.</span>
    <span class="hljs-comment">// &#x5C06;&#x5F53;&#x524D;&#x534F;&#x7A0B;&#x52A0;&#x5165;&#x7B49;&#x5F85;&#x961F;&#x5217;</span>
    s := acquireSudog()
    s.g = getg()
    s.ticket = t
    s.releasetime = <span class="hljs-number">0</span>
    t0 := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> {
        t0 = cputicks()
        s.releasetime = <span class="hljs-number">-1</span>
    }
    <span class="hljs-comment">// &#x66F4;&#x65B0;&#x7B49;&#x5F85;&#x961F;&#x5217;</span>
    <span class="hljs-keyword">if</span> l.tail == <span class="hljs-literal">nil</span> {
        l.head = s
    } <span class="hljs-keyword">else</span> {
        l.tail.next = s
    }
    l.tail = s
    <span class="hljs-comment">// &#x6302;&#x8D77;&#x534F;&#x7A0B;&#x5E76;&#x91CA;&#x653E;&#x9501;&#xFF0C;&#x7B49;&#x5F85;&#x88AB;&#x5524;&#x9192;</span>
    goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, <span class="hljs-number">3</span>)
    <span class="hljs-comment">// &#x5524;&#x9192;&#x540E;&#x91CA;&#x653E;sudog</span>
    <span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> {
        blockevent(s.releasetime-t0, <span class="hljs-number">2</span>)
    }
    releaseSudog(s)
}

<span class="hljs-comment">// notifyListNotifyAll notifies all entries in the list.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:linkname notifyListNotifyAll sync.runtime_notifyListNotifyAll</span>
<span class="hljs-keyword">func</span> notifyListNotifyAll(l *notifyList) {
    <span class="hljs-comment">// Fast-path: if there are no new waiters since the last notification</span>
    <span class="hljs-comment">// we don&apos;t need to acquire the lock.</span>
    <span class="hljs-keyword">if</span> l.wait.Load() == atomic.Load(&amp;l.notify) {
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-comment">// Pull the list out into a local variable, waiters will be readied</span>
    <span class="hljs-comment">// outside the lock.</span>
    lockWithRank(&amp;l.lock, lockRankNotifyList)
    s := l.head
    l.head = <span class="hljs-literal">nil</span>
    l.tail = <span class="hljs-literal">nil</span>

    <span class="hljs-comment">// Update the next ticket to be notified. We can set it to the current</span>
    <span class="hljs-comment">// value of wait because any previous waiters are already in the list</span>
    <span class="hljs-comment">// or will notice that they have already been notified when trying to</span>
    <span class="hljs-comment">// add themselves to the list.</span>
    atomic.Store(&amp;l.notify, l.wait.Load())
    unlock(&amp;l.lock)

    <span class="hljs-comment">// Go through the local list and ready all waiters.</span>
    <span class="hljs-keyword">for</span> s != <span class="hljs-literal">nil</span> {
        next := s.next
        s.next = <span class="hljs-literal">nil</span>
        readyWithTime(s, <span class="hljs-number">4</span>)
        s = next
    }
}

<span class="hljs-comment">// notifyListNotifyOne notifies one entry in the list.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x901A;&#x77E5;&#x5217;&#x8868;&#x4E2D;&#x7684;&#x4E00;&#x4E2A;&#x6761;&#x76EE;</span>
<span class="hljs-comment">//go:linkname notifyListNotifyOne sync.runtime_notifyListNotifyOne</span>
<span class="hljs-keyword">func</span> notifyListNotifyOne(l *notifyList) {
    <span class="hljs-comment">// Fast-path: if there are no new waiters since the last notification</span>
    <span class="hljs-comment">// we don&apos;t need to acquire the lock at all.</span>
    <span class="hljs-comment">// &#x5FEB;&#x901F;&#x8DEF;&#x5F84;&#x68C0;&#x67E5;&#xFF1A;&#x51FD;&#x6570;&#x68C0;&#x67E5;&#x81EA;&#x4E0A;&#x6B21;&#x901A;&#x77E5;&#x4EE5;&#x6765;&#x662F;&#x5426;&#x6709;&#x65B0;&#x7684;&#x7B49;&#x5F85;&#x8005;&#xFF0C;&#x5982;&#x679C;wait&#x548C;notify&#x7684;&#x503C;&#x76F8;&#x7B49;</span>
    <span class="hljs-comment">// &#x8868;&#x793A;&#x6CA1;&#x6709;&#x7B49;&#x5F85;&#x8005;&#xFF0C;&#x65E0;&#x9700;&#x7EE7;&#x7EED;&#x6267;&#x884C;&#x64CD;&#x4F5C;</span>
    <span class="hljs-keyword">if</span> l.wait.Load() == atomic.Load(&amp;l.notify) {
        <span class="hljs-keyword">return</span>
    }

    lockWithRank(&amp;l.lock, lockRankNotifyList)

    <span class="hljs-comment">// Re-check under the lock if we need to do anything.</span>
    <span class="hljs-comment">// &#x9501;&#x5185;&#x91CD;&#x6392;&#x68C0;&#x67E5;&#xFF0C;&#x5728;&#x83B7;&#x53D6;&#x9501;&#x540E;&#xFF0C;&#x4E8C;&#x6B21;&#x68C0;&#x67E5;&#x4E24;&#x8005;&#x7684;&#x503C;&#xFF0C;&#x5982;&#x679C;&#x76F8;&#x7B49;&#x5219;&#x8FD8;&#x662F;&#x6CA1;&#x6709;&#x9700;&#x8981;&#x901A;&#x77E5;&#x7684;&#x7B49;&#x5F85;&#x8005;</span>
    t := l.notify
    <span class="hljs-keyword">if</span> t == l.wait.Load() {
        unlock(&amp;l.lock)
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-comment">// Update the next notify ticket number.</span>
    <span class="hljs-comment">// &#x66F4;&#x65B0;&#x901A;&#x77E5;&#x5E8F;&#x53F7;</span>
    atomic.Store(&amp;l.notify, t+<span class="hljs-number">1</span>)

    <span class="hljs-comment">// Try to find the g that needs to be notified.</span>
    <span class="hljs-comment">// If it hasn&apos;t made it to the list yet we won&apos;t find it,</span>
    <span class="hljs-comment">// but it won&apos;t park itself once it sees the new notify number.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// This scan looks linear but essentially always stops quickly.</span>
    <span class="hljs-comment">// Because g&apos;s queue separately from taking numbers,</span>
    <span class="hljs-comment">// there may be minor reorderings in the list, but we</span>
    <span class="hljs-comment">// expect the g we&apos;re looking for to be near the front.</span>
    <span class="hljs-comment">// The g has others in front of it on the list only to the</span>
    <span class="hljs-comment">// extent that it lost the race, so the iteration will not</span>
    <span class="hljs-comment">// be too long. This applies even when the g is missing:</span>
    <span class="hljs-comment">// it hasn&apos;t yet gotten to sleep and has lost the race to</span>
    <span class="hljs-comment">// the (few) other g&apos;s that we find on the list.</span>
    <span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x627E;&#x5230;&#x9700;&#x8981;&#x901A;&#x77E5;&#x7684;sudog</span>
    <span class="hljs-keyword">for</span> p, s := (*sudog)(<span class="hljs-literal">nil</span>), l.head; s != <span class="hljs-literal">nil</span>; p, s = s, s.next {
        <span class="hljs-keyword">if</span> s.ticket == t {
            <span class="hljs-comment">// &#x5728;&#x5217;&#x8868;&#x4E2D;&#x79FB;&#x9664;</span>
            n := s.next
            <span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> {
                p.next = n
            } <span class="hljs-keyword">else</span> {
                l.head = n
            }
            <span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> {
                l.tail = p
            }
            unlock(&amp;l.lock)
            s.next = <span class="hljs-literal">nil</span>
            readyWithTime(s, <span class="hljs-number">4</span>)
            <span class="hljs-keyword">return</span>
        }
    }
    unlock(&amp;l.lock)
}
</code></pre>
<h2 id="4&#x3001;&#x540C;&#x6B65;&#x7EC4;">4&#x3001;&#x540C;&#x6B65;&#x7EC4;</h2>
<p>sync.WaitGroup &#x53EF;&#x4EE5;&#x8FBE;&#x5230;&#x5E76;&#x53D1; Goroutine &#x7684;&#x6267;&#x884C;&#x5C4F;&#x969C;&#x7684;&#x6548;&#x679C;&#xFF0C;&#x7B49;&#x5F85;&#x591A;&#x4E2A; Goroutine &#x6267;&#x884C;&#x5B8C;&#x6BD5;&#x3002;</p>
<p>WaitGroup&#x7684;&#x5185;&#x90E8;&#x7ED3;&#x6784;&#xFF1A;</p>
<p><span style="color:red">WaitGroup &#x5728;&#x7B2C;&#x4E00;&#x6B21;&#x4F7F;&#x7528;&#x540E;&#x4E0D;&#x80FD;&#x88AB;&#x590D;&#x5236;.</span></p>
<pre><code class="lang-go"><span class="hljs-comment">// src/sync/waitgroup.go</span>
<span class="hljs-comment">// A WaitGroup waits for a collection of goroutines to finish.</span>
<span class="hljs-comment">// The main goroutine calls Add to set the number of</span>
<span class="hljs-comment">// goroutines to wait for. Then each of the goroutines</span>
<span class="hljs-comment">// runs and calls Done when finished. At the same time,</span>
<span class="hljs-comment">// Wait can be used to block until all goroutines have finished.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// A WaitGroup must not be copied after first use.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In the terminology of the Go memory model, a call to Done</span>
<span class="hljs-comment">// &#x201C;synchronizes before&#x201D; the return of any Wait call that it unblocks.</span>
<span class="hljs-comment">// WaitGroup &#x7528;&#x4E8E;&#x7B49;&#x5F85;&#x4E00;&#x7EC4; Goroutine &#x6267;&#x884C;&#x5B8C;&#x6BD5;&#x3002;</span>
<span class="hljs-comment">// &#x4E3B; Goroutine &#x8C03;&#x7528; Add &#x6765;&#x8BBE;&#x7F6E;&#x9700;&#x8981;&#x7B49;&#x5F85;&#x7684; Goroutine &#x7684;&#x6570;&#x91CF;</span>
<span class="hljs-comment">// &#x7136;&#x540E;&#x6BCF;&#x4E2A; Goroutine &#x8FD0;&#x884C;&#x5E76;&#x8C03;&#x7528; Done &#x6765;&#x786E;&#x8BA4;&#x5DF2;&#x7ECF;&#x6267;&#x884C;&#x7F51;&#x5B8C;&#x6BD5;</span>
<span class="hljs-comment">// &#x540C;&#x65F6;&#xFF0C;Wait &#x53EF;&#x4EE5;&#x7528;&#x4E8E;&#x963B;&#x585E;&#x5E76;&#x7B49;&#x5F85;&#x6240;&#x6709; Goroutine &#x5B8C;&#x6210;&#x3002;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// WaitGroup &#x5728;&#x7B2C;&#x4E00;&#x6B21;&#x4F7F;&#x7528;&#x540E;&#x4E0D;&#x80FD;&#x88AB;&#x590D;&#x5236;</span>
<span class="hljs-keyword">type</span> WaitGroup <span class="hljs-keyword">struct</span> {
    noCopy noCopy

    <span class="hljs-comment">// &#x9AD8;32&#x4F4D;&#x4E3A;&#x8BA1;&#x6570;&#x5668;&#xFF0C;&#x4F4E;32&#x4E3A;&#x7B49;&#x5F85;&#x8005;&#x8BA1;&#x6570;&#x5668;</span>
    state atomic.Uint64 <span class="hljs-comment">// high 32 bits are counter, low 32 bits are waiter count.</span>
    sema  <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// &#x4FE1;&#x53F7;&#x91CF;</span>
}
</code></pre>
<p>Add/Done</p>
<p>&#x5728;&#x521D;&#x59CB;&#x9636;&#x6BB5;&#xFF0C;&#x7B49;&#x5F85;&#x5668;&#x4E3A;0&#xFF0C;&#x8BA1;&#x6570;&#x5668;&#x968F;&#x7740;Add&#x6B63;&#x6570;&#x7684;&#x8C03;&#x7528;&#x800C;&#x589E;&#x52A0;</p>
<p><span style="color:red">&#x5982;&#x679C;Add&#x4F7F;&#x7528;&#x9519;&#x8BEF;&#x5BFC;&#x81F4;&#x8BA1;&#x6570;&#x5668;&#x4E3A;&#x8D1F;&#xFF0C;&#x5219;&#x4F1A;&#x7ACB;&#x5373;&#x4EA7;&#x751F;panic&#x3002;</span></p>
<p>&#x7531;&#x4E8E;&#x5E76;&#x53D1;&#x7684;&#x6548;&#x679C;&#xFF0C;&#x8BA1;&#x6570;&#x5668;&#x548C;&#x7B49;&#x5F85;&#x5668;&#x7684;&#x503C;&#x662F;&#x5206;&#x5F00;&#x64CD;&#x4F5C;&#x7684;&#xFF0C;&#x56E0;&#x6B64;&#x53EF;&#x80FD;&#x51FA;&#x73B0;&#x8BA1;&#x6570;&#x5668;&#x5DF2;&#x7ECF;&#x4E3A;0&#xFF0C;&#x4F46;&#x7B49;&#x5F85;&#x5668;&#x4E3A;&#x6B63;&#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x4F9D;&#x6B21;&#x8C03;&#x7528;&#x4FE1;&#x53F7;&#x91CF;&#x91CA;&#x653E;&#x4EA7;&#x751F;&#x7684;&#x963B;&#x585E;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Add adds delta, which may be negative, to the WaitGroup counter.</span>
<span class="hljs-comment">// If the counter becomes zero, all goroutines blocked on Wait are released.</span>
<span class="hljs-comment">// If the counter goes negative, Add panics.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Note that calls with a positive delta that occur when the counter is zero</span>
<span class="hljs-comment">// must happen before a Wait. Calls with a negative delta, or calls with a</span>
<span class="hljs-comment">// positive delta that start when the counter is greater than zero, may happen</span>
<span class="hljs-comment">// at any time.</span>
<span class="hljs-comment">// Typically this means the calls to Add should execute before the statement</span>
<span class="hljs-comment">// creating the goroutine or other event to be waited for.</span>
<span class="hljs-comment">// If a WaitGroup is reused to wait for several independent sets of events,</span>
<span class="hljs-comment">// new Add calls must happen after all previous Wait calls have returned.</span>
<span class="hljs-comment">// See the WaitGroup example.</span>
<span class="hljs-comment">// Add &#x5C06; delta&#xFF08;&#x53EF;&#x80FD;&#x4E3A;&#x8D1F;&#xFF09;&#x52A0;&#x5230; WaitGroup &#x7684;&#x8BA1;&#x6570;&#x5668;&#x4E0A;</span>
<span class="hljs-comment">// &#x5982;&#x679C;&#x8BA1;&#x6570;&#x5668;&#x5F52;&#x96F6;&#xFF0C;&#x5219;&#x6240;&#x6709;&#x963B;&#x585E;&#x5728; Wait &#x7684; Goroutine &#x88AB;&#x91CA;&#x653E;</span>
<span class="hljs-comment">// &#x5982;&#x679C;&#x8BA1;&#x6570;&#x5668;&#x4E3A;&#x8D1F;&#xFF0C;&#x5219; panic</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x8BF7;&#x6CE8;&#x610F;&#xFF0C;&#x5F53;&#x8BA1;&#x6570;&#x5668;&#x4E3A; 0 &#x65F6;&#x53D1;&#x751F;&#x7684;&#x5E26;&#x6709;&#x6B63;&#x7684; delta &#x7684;&#x8C03;&#x7528;&#x5FC5;&#x987B;&#x5728; Wait &#x4E4B;&#x524D;&#x3002;</span>
<span class="hljs-comment">// &#x5F53;&#x8BA1;&#x6570;&#x5668;&#x5927;&#x4E8E; 0 &#x65F6;&#xFF0C;&#x5E26;&#x6709;&#x8D1F; delta &#x7684;&#x8C03;&#x7528;&#x6216;&#x5E26;&#x6709;&#x6B63; delta &#x8C03;&#x7528;&#x53EF;&#x80FD;&#x5728;&#x4EFB;&#x4F55;&#x65F6;&#x5019;&#x53D1;&#x751F;&#x3002;</span>
<span class="hljs-comment">// &#x901A;&#x5E38;&#xFF0C;&#x8FD9;&#x610F;&#x5473;&#x7740; Add &#x8C03;&#x7528;&#x5FC5;&#x987B;&#x53D1;&#x751F;&#x5728; Goroutine &#x521B;&#x5EFA;&#x4E4B;&#x524D;&#x6216;&#x5176;&#x4ED6;&#x88AB;&#x7B49;&#x5F85;&#x4E8B;&#x4EF6;&#x4E4B;&#x524D;&#x3002;</span>
<span class="hljs-comment">// &#x5982;&#x679C;&#x4E00;&#x4E2A; WaitGroup &#x88AB;&#x590D;&#x7528;&#x4E8E;&#x7B49;&#x5F85;&#x51E0;&#x4E2A;&#x4E0D;&#x540C;&#x7684;&#x72EC;&#x7ACB;&#x4E8B;&#x4EF6;&#x96C6;&#x5408;&#xFF0C;&#x5FC5;&#x987B;&#x5728;&#x524D;&#x4E00;&#x4E2A; Wait &#x8C03;&#x7528;&#x8FD4;&#x56DE;&#x540E;&#x624D;&#x80FD;&#x8C03;&#x7528; Add&#x3002;</span>
<span class="hljs-keyword">func</span> (wg *WaitGroup) Add(delta <span class="hljs-keyword">int</span>) {
    <span class="hljs-keyword">if</span> race.Enabled {
        <span class="hljs-keyword">if</span> delta &lt; <span class="hljs-number">0</span> {
            <span class="hljs-comment">// Synchronize decrements with Wait.</span>
            race.ReleaseMerge(unsafe.Pointer(wg))
        }
        race.Disable()
        <span class="hljs-keyword">defer</span> race.Enable()
    }
    <span class="hljs-comment">// &#x8BA1;&#x6570;&#x5668;&#x8FFD;&#x52A0;</span>
    state := wg.state.Add(<span class="hljs-keyword">uint64</span>(delta) &lt;&lt; <span class="hljs-number">32</span>)
    <span class="hljs-comment">// &#x8BA1;&#x6570;&#x5668;&#x7684;&#x503C;</span>
    v := <span class="hljs-keyword">int32</span>(state &gt;&gt; <span class="hljs-number">32</span>)
    <span class="hljs-comment">// &#x7B49;&#x5F85;&#x5668;&#x7684;&#x503C;</span>
    w := <span class="hljs-keyword">uint32</span>(state)
    <span class="hljs-keyword">if</span> race.Enabled &amp;&amp; delta &gt; <span class="hljs-number">0</span> &amp;&amp; v == <span class="hljs-keyword">int32</span>(delta) {
        <span class="hljs-comment">// The first increment must be synchronized with Wait.</span>
        <span class="hljs-comment">// Need to model this as a read, because there can be</span>
        <span class="hljs-comment">// several concurrent wg.counter transitions from 0.</span>
        race.Read(unsafe.Pointer(&amp;wg.sema))
    }
    <span class="hljs-comment">// &#x5982;&#x679C;&#x5B9E;&#x9645;&#x8BA1;&#x6570;&#x5668;&#x4E3A;&#x8D1F;&#xFF0C;&#x5219;&#x76F4;&#x63A5;Panic</span>
    <span class="hljs-keyword">if</span> v &lt; <span class="hljs-number">0</span> {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync: negative WaitGroup counter&quot;</span>)
    }
    <span class="hljs-comment">// &#x5728;&#x5DF2;&#x7ECF;&#x8C03;&#x7528; Wait &#x5F00;&#x59CB;&#x7B49;&#x5F85;&#x65F6;&#xFF0C;&#x4ECD;&#x7136;&#x4F7F;&#x7528; Add &#x589E;&#x52A0;&#x8BA1;&#x6570;&#x3002;&#x8FD9;&#x6837;&#x4F1A;&#x5BFC;&#x81F4; WaitGroup &#x7684;&#x8BA1;&#x6570;&#x4E0D;&#x51C6;&#x786E;&#xFF0C;&#x4ECE;&#x800C;&#x53EF;&#x80FD;&#x5BFC;&#x81F4; goroutine &#x6C38;&#x8FDC;&#x65E0;&#x6CD5;&#x9000;&#x51FA;&#x7B49;&#x5F85;&#x72B6;&#x6001;&#xFF0C;&#x6216;&#x8005;&#x5176;&#x4ED6;&#x975E;&#x9884;&#x671F;&#x7684;&#x884C;&#x4E3A;&#x3002;</span>
    <span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; delta &gt; <span class="hljs-number">0</span> &amp;&amp; v == <span class="hljs-keyword">int32</span>(delta) {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)
    }
    <span class="hljs-comment">// &#x6B63;&#x5E38;&#x60C5;&#x51B5;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;</span>
    <span class="hljs-keyword">if</span> v &gt; <span class="hljs-number">0</span> || w == <span class="hljs-number">0</span> {
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-comment">// This goroutine has set counter to 0 when waiters &gt; 0.</span>
    <span class="hljs-comment">// Now there can&apos;t be concurrent mutations of state:</span>
    <span class="hljs-comment">// - Adds must not happen concurrently with Wait,</span>
    <span class="hljs-comment">// - Wait does not increment waiters if it sees counter == 0.</span>
    <span class="hljs-comment">// Still do a cheap sanity check to detect WaitGroup misuse.</span>
    <span class="hljs-comment">// v == 0 w != 0</span>
    <span class="hljs-comment">// &#x5904;&#x7406;&#x7B49;&#x5F85;&#x7684;&#x534F;&#x7A0B;</span>
    <span class="hljs-keyword">if</span> wg.state.Load() != state {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)
    }
    <span class="hljs-comment">// Reset waiters count to 0.</span>
    wg.state.Store(<span class="hljs-number">0</span>)
    <span class="hljs-comment">// &#x5524;&#x9192;&#x6240;&#x6709;&#x7B49;&#x5F85;&#x7684;&#x534F;&#x7A0B;</span>
    <span class="hljs-keyword">for</span> ; w != <span class="hljs-number">0</span>; w-- {
        runtime_Semrelease(&amp;wg.sema, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)
    }
}

<span class="hljs-comment">// Done decrements the WaitGroup counter by one.</span>
<span class="hljs-keyword">func</span> (wg *WaitGroup) Done() {
    wg.Add(<span class="hljs-number">-1</span>)
}
</code></pre>
<p>Wait</p>
<p>&#x5F53;Add&#x548C;Done&#x90FD;&#x88AB;&#x5408;&#x7406;&#x7684;&#x8BBE;&#x7F6E;&#x540E;&#xFF0C;&#x6211;&#x4EEC;&#x5E0C;&#x671B;&#x7B49;&#x5F85;&#x6240;&#x6709;&#x7684;&#x534F;&#x7A0B;&#x7ED3;&#x675F;&#xFF0C;&#x6B64;&#x65F6;&#x9700;&#x8981;&#x8C03;&#x7528;Wait&#x3002;</p>
<p>Wait&#x4F7F;&#x7528;&#x7684;&#x662F;&#x4E00;&#x4E2A;&#x7B80;&#x5355;&#x7684;&#x6B7B;&#x5FAA;&#x73AF;&#x6765;&#x8FDB;&#x884C;&#x64CD;&#x4F5C;&#x3002;&#x5728;&#x5FAA;&#x73AF;&#x4F53;&#x4E2D;&#xFF0C;&#x6BCF;&#x6B21;&#x5148;&#x8BFB;&#x53D6;&#x8BA1;&#x6570;&#x5668;&#x548C;&#x7B49;&#x5F85;&#x5668;&#x7684;&#x503C;&#x3002;&#x7136;&#x540E;&#x7B49;&#x5F85;&#x8BA1;&#x6570;&#xFF0C;&#x5982;&#x679C;&#x589E;&#x52A0;&#x6210;&#x529F;&#xFF0C;&#x4F1A;&#x963B;&#x585E;&#x5F53;&#x524D;&#x7684;&#x6B7B;&#x5FAA;&#x73AF;&#xFF0C;&#x76F4;&#x5230;&#x88AB;&#x91CA;&#x653E;&#x624D;&#x7EE7;&#x7EED;&#x6267;&#x884C;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Wait blocks until the WaitGroup counter is zero.</span>
<span class="hljs-keyword">func</span> (wg *WaitGroup) Wait() {
    <span class="hljs-keyword">if</span> race.Enabled {
        race.Disable()
    }
    <span class="hljs-keyword">for</span> {
        <span class="hljs-comment">// &#x52A0;&#x8F7D;&#x5F53;&#x524D;&#x72B6;&#x6001;</span>
        state := wg.state.Load()
        <span class="hljs-comment">// &#x8BA1;&#x6570;&#x5668;&#x6570;&#x91CF;</span>
        v := <span class="hljs-keyword">int32</span>(state &gt;&gt; <span class="hljs-number">32</span>)
        <span class="hljs-comment">// &#x7B49;&#x5F85;&#x5668;&#x6570;&#x91CF;</span>
        w := <span class="hljs-keyword">uint32</span>(state)
        <span class="hljs-comment">// &#x8BA1;&#x6570;&#x5668;&#x4E3A;0&#xFF0C;&#x8BF4;&#x660E;&#x6240;&#x6709;&#x7684;&#x534F;&#x7A0B;&#x90FD;&#x5DF2;&#x7ECF;&#x5B8C;&#x6210;&#xFF0C;&#x5F53;&#x524D;&#x7684;Wait&#x8C03;&#x7528;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;</span>
        <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> {
            <span class="hljs-comment">// Counter is 0, no need to wait.</span>
            <span class="hljs-keyword">if</span> race.Enabled {
                race.Enable()
                race.Acquire(unsafe.Pointer(wg))
            }
            <span class="hljs-keyword">return</span>
        }
        <span class="hljs-comment">// Increment waiters count.</span>
        <span class="hljs-comment">// &#x589E;&#x52A0;&#x7B49;&#x5F85;&#x8005;&#x8BA1;&#x6570;</span>
        <span class="hljs-keyword">if</span> wg.state.CompareAndSwap(state, state+<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> race.Enabled &amp;&amp; w == <span class="hljs-number">0</span> {
                <span class="hljs-comment">// Wait must be synchronized with the first Add.</span>
                <span class="hljs-comment">// Need to model this is as a write to race with the read in Add.</span>
                <span class="hljs-comment">// As a consequence, can do the write only for the first waiter,</span>
                <span class="hljs-comment">// otherwise concurrent Waits will race with each other.</span>
                race.Write(unsafe.Pointer(&amp;wg.sema))
            }
            <span class="hljs-comment">// &#x963B;&#x585E;&#x7B49;&#x5F85;</span>
            runtime_Semacquire(&amp;wg.sema)
            <span class="hljs-comment">// &#x5982;&#x679C;&#x8BA1;&#x6570;&#x5668;&#x5728;Wait&#x8FD4;&#x56DE;&#x4E4B;&#x524D;&#x6CA1;&#x6709;&#x6062;&#x590D;&#x5230;0&#xFF0C;&#x5219;panic</span>
            <span class="hljs-comment">// WaitGroup&#x88AB;&#x8BEF;&#x7528;&#x5BFC;&#x81F4;Wait&#x6CA1;&#x6709;&#x8FD4;&#x56DE;&#x4E4B;&#x524D;&#x518D;&#x6B21;&#x4F7F;&#x7528;Add</span>
            <span class="hljs-keyword">if</span> wg.state.Load() != <span class="hljs-number">0</span> {
                <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)
            }
            <span class="hljs-keyword">if</span> race.Enabled {
                race.Enable()
                race.Acquire(unsafe.Pointer(wg))
            }
            <span class="hljs-keyword">return</span>
        }
    }
}
</code></pre>
<p>&#x793A;&#x4F8B;&#xFF1A;</p>
<pre><code class="lang-go">wg := sync.WaitGroup{}
wg.Add(<span class="hljs-number">1</span>)
<span class="hljs-keyword">go</span> <span class="hljs-keyword">func</span>() { wg.Done() }()
wg.Wait()
</code></pre>
<p>&#x5728; wg &#x521B;&#x5EFA;&#x4E4B;&#x521D;&#xFF0C;&#x8BA1;&#x6570;&#x5668;&#x3001;&#x7B49;&#x5F85;&#x5668;&#x3001;&#x5B58;&#x50A8;&#x539F;&#x8BED;&#x7684;&#x503C;&#x5747;&#x521D;&#x59CB;&#x5316;&#x4E3A;&#x96F6;&#x503C;&#x3002;&#x4E0D;&#x59A8;&#x5047;&#x8BBE;&#x8C03;&#x7528; <code>wg.Add(1)</code>&#xFF0C;&#x5219;&#x8BA1;&#x6570;&#x5668;&#x52A0; 1 &#x7B49;&#x5F85;&#x5668;&#x3001;&#x5B58;&#x50A8;&#x539F;&#x8BED;&#x4FDD;&#x6301;&#x4E0D;&#x53D8;&#xFF0C;&#x5747;&#x4E3A; 0&#x3002;</p>
<p><code>wg.Done()</code> &#x548C; <code>wg.Wait()</code> &#x7684;&#x8C03;&#x7528;&#x987A;&#x5E8F;&#x53EF;&#x80FD;&#x6210;&#x4E24;&#x79CD;&#x60C5;&#x51B5;&#xFF1A;</p>
<p><strong>&#x60C5;&#x51B5; 1</strong>&#xFF1A;&#x5148;&#x8C03;&#x7528; <code>wg.Done()</code> &#x518D;&#x8C03;&#x7528; <code>wg.Wait()</code>&#x3002;</p>
<p>&#x8FD9;&#x65F6;&#x5019; <code>wg.Done()</code> &#x4F7F;&#x8BA1;&#x6570;&#x5668;&#x51CF; 1 &#xFF0C;&#x8FD9;&#x65F6;&#x8BA1;&#x6570;&#x5668;&#x3001;&#x7B49;&#x5F85;&#x5668;&#x3001;&#x5B58;&#x50A8;&#x539F;&#x8BED;&#x5747;&#x4E3A; 0&#xFF0C;&#x7531;&#x4E8E;&#x7B49;&#x5F85;&#x5668;&#x4E3A; 0 &#x5219; <code>runtime_Semrelease</code> &#x4E0D;&#x4F1A;&#x88AB;&#x8C03;&#x7528;&#x3002; &#x4E8E;&#x662F;&#x5F53; <code>wg.Wait()</code> &#x5F00;&#x59CB;&#x8C03;&#x7528;&#x65F6;&#xFF0C;&#x8BFB;&#x53D6;&#x5230;&#x8BA1;&#x6570;&#x5668;&#x5DF2;&#x7ECF;&#x4E3A; 0&#xFF0C;&#x5FAA;&#x73AF;&#x9000;&#x51FA;&#xFF0C;<code>wg.Wait()</code> &#x8C03;&#x7528;&#x5B8C;&#x6BD5;&#x3002;</p>
<p><strong>&#x60C5;&#x51B5; 2</strong>&#xFF1A;&#x5148;&#x8C03;&#x7528; <code>wg.Wait()</code> &#x518D;&#x8C03;&#x7528; <code>wg.Done()</code>&#x3002;</p>
<p>&#x8FD9;&#x65F6;&#x5019; <code>wg.Wait()</code> &#x5F00;&#x59CB;&#x8C03;&#x7528;&#x65F6;&#xFF0C;&#x8BFB;&#x53D6;&#x5230;&#x8BA1;&#x6570;&#x5668;&#x4E3A; 1&#xFF0C;&#x5219;&#x4E3A;&#x7B49;&#x5F85;&#x5668;&#x52A0; 1&#xFF0C;&#x5E76;&#x8C03;&#x7528; <code>runtime_Semacquire</code> &#x5F00;&#x59CB;&#x963B;&#x585E;&#x5728;&#x5B58;&#x50A8;&#x539F;&#x8BED;&#x4E3A; 0 &#x7684;&#x72B6;&#x6001;&#x3002;</p>
<p>&#x5728;&#x963B;&#x585E;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;Goroutine &#x88AB;&#x8C03;&#x5EA6;&#x5668;&#x8C03;&#x5EA6;&#xFF0C;&#x5F00;&#x59CB;&#x6267;&#x884C; <code>wg.Done()</code>&#xFF0C;&#x4E8E;&#x662F;&#x8BA1;&#x6570;&#x5668;&#x6E05;&#x96F6;&#xFF0C;&#x4F46;&#x7531;&#x4E8E;&#x7B49;&#x5F85;&#x5668;&#x4E3A; 1 &#x5927;&#x4E8E;&#x96F6;&#x3002; &#x8FD9;&#x65F6;&#x5C06;&#x7B49;&#x5F85;&#x5668;&#x4E5F;&#x6E05;&#x96F6;&#xFF0C;&#x5E76;&#x8C03;&#x7528;&#x4E0E;&#x7B49;&#x5F85;&#x5668;&#x6280;&#x672F;&#x76F8;&#x540C;&#x6B21;&#x6570;&#xFF08;&#x6B64;&#x5904;&#x4E3A; 1 &#x6B21;&#xFF09;&#x7684; <code>runtime_Semrelease</code>&#xFF0C;&#x8FD9;&#x5BFC;&#x81F4;&#x5B58;&#x50A8;&#x539F;&#x8BED;&#x7684;&#x503C;&#x53D8;&#x4E3A; 1&#xFF0C;&#x8BA1;&#x6570;&#x5668;&#x548C;&#x7B49;&#x5F85;&#x5668;&#x5747;&#x4E3A;&#x96F6;&#x3002; &#x8FD9;&#x65F6;&#xFF0C;<code>runtime_Semacquire</code> &#x5728;&#x5B58;&#x50A8;&#x539F;&#x8BED;&#x5927;&#x4E8E;&#x96F6;&#x540E;&#x88AB;&#x5524;&#x9192;&#xFF0C;&#x8FD9;&#x65F6;&#x68C0;&#x67E5;&#x8BA1;&#x6570;&#x5668;&#x548C;&#x7B49;&#x5F85;&#x5668;&#x662F;&#x5426;&#x4E3A;&#x96F6;&#xFF08;&#x5982;&#x679C;&#x4E0D;&#x4E3A;&#x96F6;&#x5219;&#x8BF4;&#x660E; Add &#x4E0E; Wait &#x4EA7;&#x751F;&#x5E76;&#x53D1;&#x8C03;&#x7528;&#xFF0C;&#x76F4;&#x63A5; panic&#xFF09;&#xFF0C;&#x8FD9;&#x65F6;&#x4ED6;&#x4EEC;&#x4E3A; 0&#xFF0C;&#x7ED3;&#x675F;&#x963B;&#x585E;&#x3002;</p>
<h2 id="5&#x3001;&#x7F13;&#x5B58;&#x6C60;">5&#x3001;&#x7F13;&#x5B58;&#x6C60;</h2>
<p>sync.Pool&#x662F;&#x4E00;&#x4E2A;&#x4E34;&#x65F6;&#x5BF9;&#x8C61;&#x6C60;&#xFF0C;&#x7BA1;&#x7406;&#x4E00;&#x7EC4;&#x4E34;&#x65F6;&#x5BF9;&#x8C61;&#xFF0C;&#x5F53;&#x9700;&#x8981;&#x4ECE;&#x6C60;&#x4E2D;&#x83B7;&#x53D6;&#xFF0C;&#x4F7F;&#x7528;&#x5B8C;&#x6BD5;&#x540E;&#x518D;&#x653E;&#x56DE;&#x6C60;&#x4E2D;&#xFF0C;&#x4EE5;&#x4F9B;&#x4ED6;&#x4EBA;&#x4F7F;&#x7528;&#x3002;</p>
<h3 id="&#x5E95;&#x5C42;&#x7ED3;&#x6784;">&#x5E95;&#x5C42;&#x7ED3;&#x6784;</h3>
<p>&#x5185;&#x90E8;&#x672C;&#x8D28;&#x4E0A;&#x4FDD;&#x5B58;&#x4E86;&#x4E00;&#x4E2A;pool Local&#x5143;&#x7D20;&#x7684;&#x6570;&#x7EC4;&#xFF0C;&#x6BCF;&#x4E2A;poolLocal&#x90FD;&#x53EA;&#x80FD;&#x88AB;&#x4E00;&#x4E2A;P&#x62E5;&#x6709;&#xFF0C;&#x800C;victim&#x5219;&#x7F13;&#x5B58;&#x4E0A;&#x4E00;&#x4E2A;&#x5783;&#x573E;&#x56DE;&#x6536;&#x5468;&#x671F;&#x7684;local&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// src/sync/pool.go</span>
<span class="hljs-comment">// A Pool is a set of temporary objects that may be individually saved and</span>
<span class="hljs-comment">// retrieved.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Any item stored in the Pool may be removed automatically at any time without</span>
<span class="hljs-comment">// notification. If the Pool holds the only reference when this happens, the</span>
<span class="hljs-comment">// item might be deallocated.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// A Pool is safe for use by multiple goroutines simultaneously.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Pool&apos;s purpose is to cache allocated but unused items for later reuse,</span>
<span class="hljs-comment">// relieving pressure on the garbage collector. That is, it makes it easy to</span>
<span class="hljs-comment">// build efficient, thread-safe free lists. However, it is not suitable for all</span>
<span class="hljs-comment">// free lists.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// An appropriate use of a Pool is to manage a group of temporary items</span>
<span class="hljs-comment">// silently shared among and potentially reused by concurrent independent</span>
<span class="hljs-comment">// clients of a package. Pool provides a way to amortize allocation overhead</span>
<span class="hljs-comment">// across many clients.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// An example of good use of a Pool is in the fmt package, which maintains a</span>
<span class="hljs-comment">// dynamically-sized store of temporary output buffers. The store scales under</span>
<span class="hljs-comment">// load (when many goroutines are actively printing) and shrinks when</span>
<span class="hljs-comment">// quiescent.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// On the other hand, a free list maintained as part of a short-lived object is</span>
<span class="hljs-comment">// not a suitable use for a Pool, since the overhead does not amortize well in</span>
<span class="hljs-comment">// that scenario. It is more efficient to have such objects implement their own</span>
<span class="hljs-comment">// free list.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// A Pool must not be copied after first use.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In the terminology of the Go memory model, a call to Put(x) &#x201C;synchronizes before&#x201D;</span>
<span class="hljs-comment">// a call to Get returning that same value x.</span>
<span class="hljs-comment">// Similarly, a call to New returning x &#x201C;synchronizes before&#x201D;</span>
<span class="hljs-comment">// a call to Get returning that same value x.</span>
<span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> {
    noCopy noCopy

    <span class="hljs-comment">// local &#x56FA;&#x5B9A;&#x5927;&#x5C0F; per-P &#x6570;&#x7EC4;, &#x5B9E;&#x9645;&#x7C7B;&#x578B;&#x4E3A; [P]poolLocal</span>
    local     unsafe.Pointer <span class="hljs-comment">// local fixed-size per-P pool, actual type is [P]poolLocal</span>
    localSize <span class="hljs-keyword">uintptr</span>        <span class="hljs-comment">// size of the local array local array &#x7684;&#x5927;&#x5C0F;</span>

    <span class="hljs-comment">// &#x6765;&#x81EA;&#x524D;&#x4E00;&#x4E2A;&#x5783;&#x573E;&#x56DE;&#x6536;&#x5468;&#x671F;&#x7684; local</span>
    victim     unsafe.Pointer <span class="hljs-comment">// local from previous cycle</span>
    victimSize <span class="hljs-keyword">uintptr</span>        <span class="hljs-comment">// size of victims array victim &#x6570;&#x7EC4;&#x7684;&#x5927;&#x5C0F;</span>

    <span class="hljs-comment">// New optionally specifies a function to generate</span>
    <span class="hljs-comment">// a value when Get would otherwise return nil.</span>
    <span class="hljs-comment">// It may not be changed concurrently with calls to Get.</span>
    New <span class="hljs-keyword">func</span>() any
}
</code></pre>
<p>&#x800C;poolLocal&#x5219;&#x7531;private&#x548C;shared&#x4E24;&#x4E2A;&#x5B57;&#x6BB5;&#x7EC4;&#x6210;&#xFF0C;private&#x662F;&#x4E0A;&#x6B21;&#x8BBF;&#x95EE;&#x653E;&#x5165;&#x7684;&#x5BF9;&#x8C61;&#xFF0C;shared&#x662F;&#x4E00;&#x4E2A;&#x94FE;&#x5F0F;&#x961F;&#x5217;&#x7ED3;&#x6784;&#xFF0C;&#x53EF;&#x4EE5;&#x5728;&#x591A;&#x4E2A;P&#x4E4B;&#x95F4;&#x8FDB;&#x884C;&#x5171;&#x4EAB;&#x8BFB;&#x5199;&#x3002;</p>
<pre><code class="lang-go">
<span class="hljs-comment">// Local per-P Pool appendix.</span>
<span class="hljs-keyword">type</span> poolLocalInternal <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// &#x53EA;&#x80FD;&#x88AB;&#x4E00;&#x4E2A;P&#x8BFB;&#x5199;</span>
    <span class="hljs-comment">// private&#x7528;&#x4E8E;&#x5FEB;&#x901F;&#x8BBF;&#x95EE;&#x4E0A;&#x6B21;&#x653E;&#x5165;&#x7684;&#x5BF9;&#x8C61;</span>
    private any <span class="hljs-comment">// Can be used only by the respective P.</span>
    <span class="hljs-comment">// &#x53EF;&#x4EE5;&#x5728;&#x591A;&#x4E2A;P&#x4E4B;&#x95F4;&#x5171;&#x4EAB;&#x8BFB;&#x5199;</span>
    shared poolChain <span class="hljs-comment">// Local P can pushHead/popHead; any P can popTail.</span>
}

<span class="hljs-comment">// &#x6BCF;&#x4E2A;poolLocal&#x90FD;&#x53EA;&#x88AB;&#x4E00;&#x4E2A;P&#x62E5;&#x6709;</span>
<span class="hljs-keyword">type</span> poolLocal <span class="hljs-keyword">struct</span> {
    poolLocalInternal

    <span class="hljs-comment">// Prevents false sharing on widespread platforms with</span>
    <span class="hljs-comment">// 128 mod (cache line size) = 0 .</span>
    pad [<span class="hljs-number">128</span> - unsafe.Sizeof(poolLocalInternal{})%<span class="hljs-number">128</span>]<span class="hljs-keyword">byte</span>
}
</code></pre>
<h3 id="get">Get</h3>
<p>&#x4ECE;&#x6C60;&#x4E2D;&#x83B7;&#x53D6;&#x5BF9;&#x8C61;&#x65F6;&#xFF0C;&#x4F1A;&#x5148;&#x4ECE;poolLocal&#x7684;&#x6570;&#x7EC4;&#x4E2D;&#x9009;&#x4E00;&#x4E2A;poolLocal</p>
<p>1&#x3001;&#x4F18;&#x5148;&#x4ECE;private&#x53D6;&#x51FA;&#x4E0A;&#x6B21;&#x56DE;&#x6536;&#x7684;&#x5BF9;&#x8C61;</p>
<p>2&#x3001;&#x5982;&#x679C;&#x53D6;&#x4E0D;&#x5230;&#xFF0C;&#x5219;&#x5C1D;&#x8BD5;&#x4ECE;shared&#x961F;&#x5217;&#x7684;&#x961F;&#x5934;&#x8FDB;&#x884C;&#x8BFB;&#x53D6;</p>
<p>3&#x3001;&#x8FD8;&#x662F;&#x53D6;&#x4E0D;&#x5230;&#x5219;&#x4ECE;&#x5176;&#x4ED6;P&#x7684;poolLocal&#x4E2D;&#x5077;&#x53D6;</p>
<p>4&#x3001;&#x6700;&#x540E;&#x8FD8;&#x6CA1;&#x6709;&#x53D6;&#x5230;&#xFF0C;&#x5219;&#x4F7F;&#x7528;New&#x65B9;&#x6CD5;&#x65B0;&#x5EFA;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Get selects an arbitrary item from the Pool, removes it from the</span>
<span class="hljs-comment">// Pool, and returns it to the caller.</span>
<span class="hljs-comment">// Get may choose to ignore the pool and treat it as empty.</span>
<span class="hljs-comment">// Callers should not assume any relation between values passed to Put and</span>
<span class="hljs-comment">// the values returned by Get.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// If Get would otherwise return nil and p.New is non-nil, Get returns</span>
<span class="hljs-comment">// the result of calling p.New.</span>
<span class="hljs-comment">// Get &#x4ECE; Pool &#x4E2D;&#x9009;&#x62E9;&#x4E00;&#x4E2A;&#x4EFB;&#x610F;&#x7684;&#x5BF9;&#x8C61;&#xFF0C;&#x5C06;&#x5176;&#x79FB;&#x51FA; Pool, &#x5E76;&#x8FD4;&#x56DE;&#x7ED9;&#x8C03;&#x7528;&#x65B9;&#x3002;</span>
<span class="hljs-comment">// Get &#x53EF;&#x80FD;&#x4F1A;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x975E;&#x96F6;&#x503C;&#x5BF9;&#x8C61;&#xFF08;&#x88AB;&#x5176;&#x4ED6;&#x4EBA;&#x4F7F;&#x7528;&#x8FC7;&#xFF09;&#xFF0C;&#x56E0;&#x6B64;&#x8C03;&#x7528;&#x65B9;&#x4E0D;&#x5E94;&#x5047;&#x8BBE;</span>
<span class="hljs-comment">// &#x8FD4;&#x56DE;&#x7684;&#x5BF9;&#x8C61;&#x5177;&#x6709;&#x4EFB;&#x4F55;&#x5F62;&#x5F0F;&#x7684;&#x72B6;&#x6001;&#x3002;</span>
<span class="hljs-keyword">func</span> (p *Pool) Get() any {
    <span class="hljs-keyword">if</span> race.Enabled {
        race.Disable()
    }
    <span class="hljs-comment">// &#x83B7;&#x53D6;&#x4E00;&#x4E2A;poolLocal</span>
    l, pid := p.pin()
    <span class="hljs-comment">// &#x5148;&#x4ECE;private&#x83B7;&#x53D6;&#x4E0A;&#x6B21;&#x8BBF;&#x95EE;&#x653E;&#x5165;&#x7684;&#x5BF9;&#x8C61;</span>
    x := l.private
    l.private = <span class="hljs-literal">nil</span>
    <span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// Try to pop the head of the local shard. We prefer</span>
        <span class="hljs-comment">// the head over the tail for temporal locality of</span>
        <span class="hljs-comment">// reuse.</span>
        <span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x4ECE;shared&#x961F;&#x5217;&#x83B7;&#x53D6;&#x5BF9;&#x8C61;</span>
        x, _ = l.shared.popHead()
        <span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> {
            <span class="hljs-comment">// shared&#x4E2D;&#x4E5F;&#x6CA1;&#x6709;&#xFF0C;&#x5219;&#x4ECE;&#x5176;&#x4ED6;poolLocal&#x6216;&#x8005;&#x5168;&#x5C40;&#x6C60;&#x4E2D;&#x83B7;&#x53D6;</span>
            x = p.getSlow(pid)
        }
    }
    runtime_procUnpin()
    <span class="hljs-keyword">if</span> race.Enabled {
        race.Enable()
        <span class="hljs-keyword">if</span> x != <span class="hljs-literal">nil</span> {
            race.Acquire(poolRaceAddr(x))
        }
    }
    <span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &amp;&amp; p.New != <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// &#x6C60;&#x4E2D;&#x6CA1;&#x6709;&#x5219;&#x76F4;&#x63A5;&#x521B;&#x5EFA;</span>
        x = p.New()
    }
    <span class="hljs-keyword">return</span> x
}
</code></pre>
<p>&#x6CE8;&#x610F;&#xFF1A;</p>
<ol>
<li>private&#x53EA;&#x4FDD;&#x5B58;&#x4E86;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61;&#xFF0C;&#x5C31;&#x662F;&#x6700;&#x8FD1;&#x56DE;&#x6536;&#x7684;&#x3002;</li>
<li>&#x7B2C;&#x4E00;&#x6B21;&#x4ECE;shared&#x4E2D;&#x53D6;&#x5BF9;&#x8C61;&#x65F6;&#xFF0C;&#x672A;&#x6D89;&#x53CA;&#x8DE8;P&#x8BFB;&#x5199;&#xFF0C;&#x56E0;&#x6B64;popHead&#x53EF;&#x7528;</li>
<li>&#x5F53;shared&#x8BFB;&#x53D6;&#x4E0D;&#x5230;&#x5BF9;&#x8C61;&#x65F6;&#xFF0C;&#x8BF4;&#x660E;&#x5F53;&#x524D;&#x5C40;&#x90E8;P&#x6240;&#x6301;&#x6709;&#x7684;poolLocal&#x4E0D;&#x5305;&#x542B;&#x4EFB;&#x4F55;&#x5BF9;&#x8C61;&#xFF0C;&#x9700;&#x8981;&#x4ECE;&#x5176;&#x4ED6;P&#x7684;poolLocal&#x4E2D;&#x5077;&#x53D6;&#x3002;</li>
<li>&#x5B9E;&#x5728;&#x5077;&#x4E0D;&#x5230;&#x4F1A;&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61;&#x3002;</li>
</ol>
<p>&#x5077;&#x53D6;&#x7EC6;&#x8282;</p>
<p>1&#x3001;&#x9996;&#x5148;&#x9700;&#x8981;&#x83B7;&#x53D6;&#x5F53;&#x524D;P&#x7684;poolLocal&#xFF0C;&#x5E76;&#x5C06;&#x5F53;&#x524D;&#x534F;&#x7A0B;&#x7ED1;&#x5B9A;&#x5230;&#x8BE5;P&#x4E0A;&#x3002;&#x8FD9;&#x4E3B;&#x8981;&#x901A;&#x8FC7;pin&#xFF08;&#xFF09;&#x51FD;&#x6570;&#x6765;&#x5B8C;&#x6210;&#x3002;</p>
<p>&#x5B83;&#x9996;&#x5148;&#x4F1A;&#x8C03;&#x7528;&#x8FD0;&#x884C;&#x65F6;&#x5B9E;&#x73B0;&#x83B7;&#x5F97;&#x5F53;&#x524D;P&#x7684;id&#xFF0C;&#x5C06;P&#x8BBE;&#x7F6E;&#x4E3A;&#x7981;&#x6B62;&#x62A2;&#x5360;&#xFF0C;&#x8FBE;&#x5230;&#x56FA;&#x5B9A;&#x5F53;&#x524D;&#x534F;&#x7A0B;&#x7684;&#x76EE;&#x7684;&#x3002;&#x7136;&#x540E;&#x68C0;&#x67E5;pid&#x548C;localSize&#x6765;&#x786E;&#x4FDD;&#x4ECE;local&#x53D6;&#x503C;&#x4E0D;&#x4F1A;&#x53D1;&#x751F;&#x8D8A;&#x754C;&#x3002;&#x4E0D;&#x53D1;&#x751F;&#x5219;&#x8C03;&#x7528;&#x76F8;&#x5E94;&#x51FD;&#x6570;&#x53D6;&#x503C;&#x3002;&#x5426;&#x5219;&#x8C03;&#x7528;&#x6162;&#x901F;&#x8DEF;&#x5F84;&#x83B7;&#x53D6;&#x3002;</p>
<p><code>pinSlow()</code> &#x4F1A;&#x9996;&#x5148;&#x53D6;&#x6D88; P &#x7684;&#x7981;&#x6B62;&#x62A2;&#x5360;&#xFF0C;&#x8FD9;&#x662F;&#x56E0;&#x4E3A;&#x4F7F;&#x7528; mutex &#x65F6; P &#x5FC5;&#x987B;&#x4E3A;&#x53EF;&#x62A2;&#x5360;&#x7684;&#x72B6;&#x6001;&#x3002; &#x7136;&#x540E;&#x4F7F;&#x7528; <code>allPoolsMu</code> &#x8FDB;&#x884C;&#x52A0;&#x9501;&#x3002; &#x5F53;&#x5B8C;&#x6210;&#x52A0;&#x9501;&#x540E;&#xFF0C;&#x518D;&#x91CD;&#x65B0;&#x56FA;&#x5B9A; P &#xFF0C;&#x53D6;&#x5176; pid&#x3002;&#x6CE8;&#x610F;&#xFF0C;&#x56E0;&#x4E3A;&#x4E2D;&#x9014;&#x53EF;&#x80FD;&#x5DF2;&#x7ECF;&#x88AB;&#x5176;&#x4ED6;&#x7684;&#x7EBF;&#x7A0B;&#x8C03;&#x7528;&#xFF0C;&#x56E0;&#x6B64;&#x8FD9;&#x65F6;&#x5019;&#x9700;&#x8981;&#x518D;&#x6B21;&#x5BF9; pid &#x8FDB;&#x884C;&#x68C0;&#x67E5;&#x3002; &#x5982;&#x679C; pid &#x5728; p.local &#x5927;&#x5C0F;&#x8303;&#x56F4;&#x5185;&#xFF0C;&#x5219;&#x4E0D;&#x518D;&#x6B64;&#x65F6;&#x521B;&#x5EFA;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x3002;</p>
<p>&#x5982;&#x679C; <code>p.local</code> &#x4E3A;&#x7A7A;&#xFF0C;&#x5219;&#x5C06; p &#x6254;&#x7ED9; <code>allPools</code> &#x5E76;&#x5728;&#x5783;&#x573E;&#x56DE;&#x6536;&#x9636;&#x6BB5;&#x56DE;&#x6536;&#x6240;&#x6709; Pool &#x5B9E;&#x4F8B;&#x3002; &#x6700;&#x540E;&#x518D;&#x5B8C;&#x6210;&#x5BF9; <code>p.local</code> &#x7684;&#x521B;&#x5EFA;&#xFF08;&#x5F7B;&#x5E95;&#x4E22;&#x5F03;&#x65E7;&#x6570;&#x7EC4;&#xFF09;</p>
<pre><code class="lang-go"><span class="hljs-comment">// pin pins the current goroutine to P, disables preemption and</span>
<span class="hljs-comment">// returns poolLocal pool for the P and the P&apos;s id.</span>
<span class="hljs-comment">// Caller must call runtime_procUnpin() when done with the pool.</span>
<span class="hljs-comment">// &#x5C06;&#x5F53;&#x524D;&#x7684; goroutine &#x56FA;&#x5B9A;&#x5728;&#x7279;&#x5B9A;&#x7684; P&#xFF08;&#x5904;&#x7406;&#x5668;&#xFF09;&#x4E0A;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;&#x4E0E;&#x8BE5; P &#x5173;&#x8054;&#x7684; poolLocal &#x5BF9;&#x8C61;&#x548C; P &#x7684; ID&#x3002;</span>
<span class="hljs-keyword">func</span> (p *Pool) pin() (*poolLocal, <span class="hljs-keyword">int</span>) {
    <span class="hljs-comment">// &#x7ED1;&#x5B9A;&#x5F53;&#x524D;P&#xFF0C;&#x4FDD;&#x8BC1;&#x540E;&#x7EED;&#x7684;&#x64CD;&#x4F5C;&#x90FD;&#x5728;&#x540C;&#x4E00;&#x4E2A;P&#x4E0A;&#x6267;&#x884C;</span>
    pid := runtime_procPin()
    <span class="hljs-comment">// In pinSlow we store to local and then to localSize, here we load in opposite order.</span>
    <span class="hljs-comment">// Since we&apos;ve disabled preemption, GC cannot happen in between.</span>
    <span class="hljs-comment">// Thus here we must observe local at least as large localSize.</span>
    <span class="hljs-comment">// We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).</span>
    <span class="hljs-comment">// &#x8BFB;&#x53D6;localSize&#xFF0C;&#x518D;&#x8BFB;&#x53D6;local</span>
    <span class="hljs-comment">// &#x8BFB;&#x53D6;&#x7684;&#x987A;&#x5E8F;&#x5F88;&#x91CD;&#x8981;&#xFF0C;&#x5148;&#x8BFB;&#x53D6;localSize&#xFF0C;&#x518D;&#x8BFB;&#x53D6;local&#xFF0C;local&#x81F3;&#x5C11;&#x662F;&#x88AB;&#x6B63;&#x786E;&#x521D;&#x59CB;&#x5316;&#x7684;</span>
    s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="hljs-comment">// load-acquire &#x786E;&#x4FDD;&#x8BFB;&#x53D6;&#x7684;&#x503C;&#x5728;&#x8BFB;&#x53D6;&#x4E4B;&#x524D;&#x6240;&#x6709;&#x7684;&#x5199;&#x64CD;&#x4F5C;&#x90FD;&#x5DF2;&#x7ECF;&#x5B8C;&#x6210;&#x4E86;</span>
    l := p.local                              <span class="hljs-comment">// load-consume</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(pid) &lt; s {
        <span class="hljs-comment">// &#x5982;&#x679C;pid&#x5728;local&#x6570;&#x7EC4;&#x4E2D;&#xFF0C;&#x76F4;&#x63A5;&#x627E;&#x5230;&#x5E76;&#x4F7F;&#x7528;</span>
        <span class="hljs-keyword">return</span> indexLocal(l, pid), pid
    }
    <span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x6269;&#x5C55;local&#x6570;&#x7EC4;</span>
    <span class="hljs-keyword">return</span> p.pinSlow()
}

<span class="hljs-keyword">func</span> (p *Pool) pinSlow() (*poolLocal, <span class="hljs-keyword">int</span>) {
    <span class="hljs-comment">// Retry under the mutex.</span>
    <span class="hljs-comment">// Can not lock the mutex while pinned.</span>
    <span class="hljs-comment">// &#x83B7;&#x53D6;&#x5168;&#x5C40;&#x9501;&#xFF0C;&#x9700;&#x8981;&#x89E3;&#x9664;&#x7ED1;&#x5B9A;&#x72B6;&#x6001;</span>
    runtime_procUnpin()
    allPoolsMu.Lock()
    <span class="hljs-keyword">defer</span> allPoolsMu.Unlock()
    <span class="hljs-comment">// &#x91CD;&#x65B0;&#x56FA;&#x5B9A;</span>
    pid := runtime_procPin()
    <span class="hljs-comment">// poolCleanup won&apos;t be called while we are pinned.</span>
    <span class="hljs-comment">// &#x68C0;&#x67E5;local&#x662F;&#x5426;&#x5DF2;&#x7ECF;&#x91CD;&#x65B0;&#x5206;&#x914D;</span>
    s := p.localSize
    l := p.local
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(pid) &lt; s {
        <span class="hljs-keyword">return</span> indexLocal(l, pid), pid
    }
    <span class="hljs-comment">// &#x5C06;&#x5176;&#x6DFB;&#x52A0;&#x5230; allPools&#xFF0C;&#x5783;&#x573E;&#x56DE;&#x6536;&#x5668;&#x4ECE;&#x8FD9;&#x91CC;&#x83B7;&#x53D6;&#x6240;&#x6709; Pool &#x5B9E;&#x4F8B;</span>
    <span class="hljs-keyword">if</span> p.local == <span class="hljs-literal">nil</span> {
        allPools = <span class="hljs-built_in">append</span>(allPools, p)
    }
    <span class="hljs-comment">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.</span>
    <span class="hljs-comment">// &#x6839;&#x636E; P &#x6570;&#x91CF;&#x521B;&#x5EFA; slice&#xFF0C;&#x5982;&#x679C; GOMAXPROCS &#x5728; GC &#x95F4;&#x53D1;&#x751F;&#x53D8;&#x5316;</span>
    <span class="hljs-comment">// &#x6211;&#x4EEC;&#x91CD;&#x65B0;&#x5206;&#x914D;&#x6B64;&#x6570;&#x7EC4;&#x5E76;&#x4E22;&#x5F03;&#x65E7;&#x7684;</span>
    size := runtime.GOMAXPROCS(<span class="hljs-number">0</span>)
    local := <span class="hljs-built_in">make</span>([]poolLocal, size)
    <span class="hljs-comment">// &#x5C06;&#x5E95;&#x5C42;&#x6570;&#x7EC4;&#x8D77;&#x59CB;&#x6307;&#x9488;&#x4FDD;&#x5B58;&#x5230; p.local&#xFF0C;&#x5E76;&#x8BBE;&#x7F6E; p.localSize</span>
    atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="hljs-number">0</span>])) <span class="hljs-comment">// store-release</span>
    runtime_StoreReluintptr(&amp;p.localSize, <span class="hljs-keyword">uintptr</span>(size))     <span class="hljs-comment">// store-release</span>
    <span class="hljs-keyword">return</span> &amp;local[pid], pid
}

<span class="hljs-keyword">func</span> indexLocal(l unsafe.Pointer, i <span class="hljs-keyword">int</span>) *poolLocal {
    lp := unsafe.Pointer(<span class="hljs-keyword">uintptr</span>(l) + <span class="hljs-keyword">uintptr</span>(i)*unsafe.Sizeof(poolLocal{}))
    <span class="hljs-keyword">return</span> (*poolLocal)(lp)
}
</code></pre>
<p>2&#x3001;getSlow</p>
<p>&#x83B7;&#x53D6;&#x5230;&#x4E86; <code>poolLocal</code>&#xFF0C;&#x73B0;&#x5728;&#x56DE;&#x5230;&#x6211;&#x4EEC; <code>Get</code> &#x7684;&#x53D6;&#x503C;&#x8FC7;&#x7A0B;&#x3002;&#x5728;&#x53D6;&#x5BF9;&#x8C61;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x4ECD;&#x7136;&#x4F1A;&#x9762;&#x4E34; &#x65E2;&#x4E0D;&#x80FD;&#x4ECE; <code>private</code> &#x53D6;&#x3001;&#x4E5F;&#x4E0D;&#x80FD;&#x4ECE; <code>shared</code> &#x4E2D;&#x53D6;&#x5F97;&#x5C34;&#x5C2C;&#x5883;&#x5730;&#x3002;&#x8FD9;&#x65F6;&#x5019;&#x5C31;&#x6765;&#x5230;&#x4E86; <code>getSlow()</code>&#x3002;</p>
<p>&#x518D;&#x6B21;&#x56FA;&#x5B9A; P&#xFF0C;&#x5E76;&#x53D6;&#x5F97;&#x5F53;&#x524D;&#x7684; P.id &#x6765;&#x4ECE;&#x5176;&#x4ED6; P &#x4E2D;&#x5077;&#x503C;&#xFF0C;&#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x5148;&#x83B7;&#x53D6;&#x5230;&#x5176;&#x4ED6; P &#x5BF9;&#x5E94;&#x7684; <code>poolLocal</code></p>
<pre><code class="lang-go"><span class="hljs-keyword">func</span> (p *Pool) getSlow(pid <span class="hljs-keyword">int</span>) any {
    <span class="hljs-comment">// See the comment in pin regarding ordering of the loads.</span>
    size := runtime_LoadAcquintptr(&amp;p.localSize) <span class="hljs-comment">// load-acquire</span>
    locals := p.local                            <span class="hljs-comment">// load-consume</span>
    <span class="hljs-comment">// Try to steal one element from other procs.</span>
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">int</span>(size); i++ {
        <span class="hljs-comment">// &#x83B7;&#x53D6;&#x76EE;&#x6807; poolLocal, &#x5F15;&#x5165; pid &#x4FDD;&#x8BC1;&#x4E0D;&#x662F;&#x81EA;&#x8EAB;</span>
        l := indexLocal(locals, (pid+i+<span class="hljs-number">1</span>)%<span class="hljs-keyword">int</span>(size))
        <span class="hljs-comment">// &#x4ECE;&#x5176;&#x4ED6;&#x7684; P &#x4E2D;&#x56FA;&#x5B9A;&#x7684; localPool &#x7684; share &#x961F;&#x5217;&#x7684;&#x961F;&#x5C3E;&#x5077;&#x4E00;&#x4E2A;&#x7F13;&#x5B58;&#x5BF9;&#x8C61;</span>
        <span class="hljs-keyword">if</span> x, _ := l.shared.popTail(); x != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> x
        }
    }

    <span class="hljs-comment">// Try the victim cache. We do this after attempting to steal</span>
    <span class="hljs-comment">// from all primary caches because we want objects in the</span>
    <span class="hljs-comment">// victim cache to age out if at all possible.</span>
    <span class="hljs-comment">// &#x5F53; local &#x5931;&#x8D25;&#x540E;&#xFF0C;&#x5C1D;&#x8BD5;&#x518D;&#x5C1D;&#x8BD5;&#x4ECE;&#x4E0A;&#x4E00;&#x4E2A;&#x5783;&#x573E;&#x56DE;&#x6536;&#x5468;&#x671F;&#x9057;&#x7559;&#x4E0B;&#x6765;&#x7684; victim&#x3002;</span>
    <span class="hljs-comment">// &#x5982;&#x679C; pid &#x6BD4; victim &#x9057;&#x7559;&#x7684; localPool &#x8FD8;&#x5927;&#xFF0C;&#x5219;&#x8BF4;&#x660E;&#x4ECE;&#x6839;&#x636E;&#x6B64; pid &#x4ECE;</span>
    <span class="hljs-comment">// victim &#x83B7;&#x53D6; localPool &#x4F1A;&#x53D1;&#x751F;&#x8D8A;&#x754C;&#xFF08;&#x540C;&#x65F6;&#x4E5F;&#x8868;&#x660E;&#x6B64;&#x65F6; P &#x7684;&#x6570;&#x91CF;&#x5DF2;&#x7ECF;&#x53D1;&#x751F;&#x53D8;&#x5316;&#xFF09;</span>
    <span class="hljs-comment">// &#x8FD9;&#x65F6;&#x65E0;&#x6CD5;&#x7EE7;&#x7EED;&#x8BFB;&#x53D6;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE; nil</span>
    size = atomic.LoadUintptr(&amp;p.victimSize)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(pid) &gt;= size {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
    <span class="hljs-comment">// &#x83B7;&#x53D6; localPool&#xFF0C;&#x5E76;&#x4F18;&#x5148;&#x8BFB;&#x53D6; private</span>
    locals = p.victim
    l := indexLocal(locals, pid)
    <span class="hljs-keyword">if</span> x := l.private; x != <span class="hljs-literal">nil</span> {
        l.private = <span class="hljs-literal">nil</span>
        <span class="hljs-keyword">return</span> x
    }
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">int</span>(size); i++ {
        <span class="hljs-comment">// &#x4ECE;&#x5176;&#x4ED6;&#x7684; P &#x4E2D;&#x56FA;&#x5B9A;&#x7684; localPool &#x7684; share &#x961F;&#x5217;&#x7684;&#x961F;&#x5C3E;&#x5077;&#x4E00;&#x4E2A;&#x7F13;&#x5B58;&#x5BF9;&#x8C61;</span>
        l := indexLocal(locals, (pid+i)%<span class="hljs-keyword">int</span>(size))
        <span class="hljs-keyword">if</span> x, _ := l.shared.popTail(); x != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> x
        }
    }

    <span class="hljs-comment">// Mark the victim cache as empty for future gets don&apos;t bother</span>
    <span class="hljs-comment">// with it.</span>
    <span class="hljs-comment">// &#x5C06; victim &#x7F13;&#x5B58;&#x7F6E;&#x7A7A;&#xFF0C;&#x4ECE;&#x800C;&#x786E;&#x4FDD;&#x4E4B;&#x540E;&#x7684; get &#x64CD;&#x4F5C;&#x4E0D;&#x518D;&#x8BFB;&#x53D6;&#x6B64;&#x5904;&#x7684;&#x503C;</span>
    atomic.StoreUintptr(&amp;p.victimSize, <span class="hljs-number">0</span>)

    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
</code></pre>
<h3 id="put">Put</h3>
<p>Put&#x53EA;&#x9700;&#x8981;&#x5C06;&#x5BF9;&#x8C61;&#x653E;&#x56DE;&#x5230;&#x6C60;&#x4E2D;</p>
<p>1&#x3001;&#x4F18;&#x5148;&#x653E;&#x5165;private</p>
<p>2&#x3001;private&#x6709;&#x503C;&#xFF0C;&#x5219;&#x653E;&#x5165;shared&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Put adds x to the pool.</span>
<span class="hljs-keyword">func</span> (p *Pool) Put(x any) {
    <span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">if</span> race.Enabled {
        <span class="hljs-keyword">if</span> fastrandn(<span class="hljs-number">4</span>) == <span class="hljs-number">0</span> {
            <span class="hljs-comment">// Randomly drop x on floor.</span>
            <span class="hljs-keyword">return</span>
        }
        race.ReleaseMerge(poolRaceAddr(x))
        race.Disable()
    }
    <span class="hljs-comment">// &#x83B7;&#x53D6;&#x4E00;&#x4E2A;poolLocal</span>
    l, _ := p.pin()
    <span class="hljs-comment">// &#x4F18;&#x5148;&#x653E;&#x5165;private</span>
    <span class="hljs-keyword">if</span> l.private == <span class="hljs-literal">nil</span> {
        l.private = x
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// &#x4E0D;&#x80FD;&#x5219;&#x653E;&#x5165;shared&#x5934;&#x90E8;</span>
        l.shared.pushHead(x)
    }
    runtime_procUnpin()
    <span class="hljs-keyword">if</span> race.Enabled {
        race.Enable()
    }
}
</code></pre>
<h3 id="&#x7F13;&#x5B58;&#x56DE;&#x6536;">&#x7F13;&#x5B58;&#x56DE;&#x6536;</h3>
<p><code>sync.Pool</code> &#x7684;&#x5783;&#x573E;&#x56DE;&#x6536;&#x53D1;&#x751F;&#x5728;&#x8FD0;&#x884C;&#x65F6; GC &#x5F00;&#x59CB;&#x4E4B;&#x524D;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-keyword">func</span> init() {
    <span class="hljs-comment">// pool&#x7684;&#x5783;&#x573E;&#x56DE;&#x6536;&#x53D1;&#x751F;&#x5728;&#x8FD0;&#x884C;&#x65F6;GC&#x5F00;&#x59CB;&#x4E4B;&#x524D;</span>
    <span class="hljs-comment">// &#x5C06;&#x7F13;&#x5B58;&#x6E05;&#x7406;&#x51FD;&#x6570;&#x6CE8;&#x518C;&#x5230;&#x8FD0;&#x884C;&#x65F6; GC &#x65F6;&#x95F4;&#x6BB5;</span>
    runtime_registerPoolCleanup(poolCleanup)
}
</code></pre>
<p>&#x5373;&#x4FBF;&#x662F;&#x6700;&#x540E; <code>p.local</code> &#x5DF2;&#x7ECF;&#x88AB;&#x7F6E;&#x6362;&#x5230; <code>oldPools</code> &#x7684; <code>p.victim</code>&#xFF0C;&#x5176;&#x4E2D;&#x7684;&#x7F13;&#x5B58;&#x5BF9;&#x8C61;&#x4ECD;&#x7136;&#x6709;&#x53EF;&#x80FD;&#x88AB;&#x5077;&#x53D6;&#x653E;&#x56DE;&#x5230; <code>allPools</code> &#x4E2D;&#xFF0C;&#x4ECE;&#x800C;&#x5EF6;&#x7F13;&#x4E86; <code>victim</code> &#x4E2D;&#x7F13;&#x5B58;&#x5BF9;&#x8C61;&#x88AB;&#x56DE;&#x6536;&#x7684;&#x901F;&#x5EA6;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// oldPools &#x662F;&#x4E00;&#x7EC4; pool &#x7684;&#x96C6;&#x5408;&#xFF0C;&#x5177;&#x6709;&#x975E;&#x7A7A; victim &#x7F13;&#x5B58;&#x3002;&#x7531; STW &#x4FDD;&#x62A4;</span>
<span class="hljs-keyword">var</span> oldPools []*Pool

<span class="hljs-keyword">func</span> poolCleanup() {
    <span class="hljs-comment">// This function is called with the world stopped, at the beginning of a garbage collection.</span>
    <span class="hljs-comment">// It must not allocate and probably should not call any runtime functions.</span>

    <span class="hljs-comment">// Because the world is stopped, no pool user can be in a</span>
    <span class="hljs-comment">// pinned section (in effect, this has all Ps pinned).</span>
    <span class="hljs-comment">// &#x7A0B;&#x5E8F;&#x6B64;&#x65F6;&#x5DF2;&#x7ECF;&#x6682;&#x505C;&#xFF0C;&#x65E0;&#x9700;&#x52A0;&#x9501;</span>

    <span class="hljs-comment">// Drop victim caches from all pools.</span>
    <span class="hljs-comment">// &#x4ECE;&#x6240;&#x6709;&#x7684;oldpools&#x4E2D;&#x5220;&#x9664;victim</span>
    <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> oldPools {
        p.victim = <span class="hljs-literal">nil</span>
        p.victimSize = <span class="hljs-number">0</span>
    }

    <span class="hljs-comment">// Move primary cache to victim cache.</span>
    <span class="hljs-comment">// &#x5C06;&#x4E3B;&#x7F13;&#x5B58;&#x79FB;&#x52A8;&#x5230; victim &#x7F13;&#x5B58;</span>
    <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> allPools {
        p.victim = p.local
        p.victimSize = p.localSize
        p.local = <span class="hljs-literal">nil</span>
        p.localSize = <span class="hljs-number">0</span>
    }

    <span class="hljs-comment">// The pools with non-empty primary caches now have non-empty</span>
    <span class="hljs-comment">// victim caches and no pools have primary caches.</span>
    <span class="hljs-comment">// &#x5177;&#x6709;&#x975E;&#x7A7A;&#x4E3B;&#x7F13;&#x5B58;&#x7684;&#x6C60;&#x73B0;&#x5728;&#x5177;&#x6709;&#x975E;&#x7A7A;&#x7684; victim &#x7F13;&#x5B58;&#xFF0C;&#x5E76;&#x4E14;&#x6CA1;&#x6709;&#x4EFB;&#x4F55; pool &#x5177;&#x6709;&#x4E3B;&#x7F13;&#x5B58;&#x3002;</span>
    oldPools, allPools = allPools, <span class="hljs-literal">nil</span>
}
</code></pre>
<h3 id="poolchain">poolChain</h3>
<p>&#x5185;&#x90E8;&#x7ED3;&#x6784;</p>
<pre><code class="lang-go"><span class="hljs-comment">// src/sync/poolDequeue.go</span>
<span class="hljs-comment">// poolChain is a dynamically-sized version of poolDequeue.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// This is implemented as a doubly-linked list queue of poolDequeues</span>
<span class="hljs-comment">// where each dequeue is double the size of the previous one. Once a</span>
<span class="hljs-comment">// dequeue fills up, this allocates a new one and only ever pushes to</span>
<span class="hljs-comment">// the latest dequeue. Pops happen from the other end of the list and</span>
<span class="hljs-comment">// once a dequeue is exhausted, it gets removed from the list.</span>
<span class="hljs-comment">// &#x4E00;&#x4E2A;&#x53CC;&#x5411;&#x94FE;&#x5F0F;&#x961F;&#x5217;&#xFF0C;&#x6BCF;&#x4E2A;&#x5143;&#x7D20;&#x90FD;&#x662F;&#x4E00;&#x4E2A;&#x73AF;&#x5F62;&#x961F;&#x5217;</span>
<span class="hljs-keyword">type</span> poolChain <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// head is the poolDequeue to push to. This is only accessed</span>
    <span class="hljs-comment">// by the producer, so doesn&apos;t need to be synchronized.</span>
    <span class="hljs-comment">// &#x4EC5;&#x7531;&#x751F;&#x4EA7;&#x8005;&#x8BBF;&#x95EE;&#xFF0C;&#x65E0;&#x9700;&#x5E76;&#x53D1;&#x5B89;&#x5168;</span>
    <span class="hljs-comment">// &#x6307;&#x5411;&#x6700;&#x8FD1;&#x63D2;&#x5165;&#x7684;&#x8282;&#x70B9;&#xFF0C;&#x5E76;&#x4E0D;&#x662F;&#x4F20;&#x7EDF;&#x610F;&#x4E49;&#x4E0A;&#x7684;&#x94FE;&#x8868;&#x5934;&#x90E8;</span>
    head *poolChainElt

    <span class="hljs-comment">// tail is the poolDequeue to popTail from. This is accessed</span>
    <span class="hljs-comment">// by consumers, so reads and writes must be atomic.</span>
    <span class="hljs-comment">// &#x7531;&#x591A;&#x4E2A;&#x6D88;&#x8D39;&#x8005;&#x8BBF;&#x95EE;&#xFF0C;&#x9700;&#x8981;&#x4FDD;&#x8BC1;&#x5E76;&#x53D1;&#x5B89;&#x5168;</span>
    tail *poolChainElt
}

<span class="hljs-keyword">type</span> poolChainElt <span class="hljs-keyword">struct</span> {
    poolDequeue

    <span class="hljs-comment">// next and prev link to the adjacent poolChainElts in this</span>
    <span class="hljs-comment">// poolChain.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// next is written atomically by the producer and read</span>
    <span class="hljs-comment">// atomically by the consumer. It only transitions from nil to</span>
    <span class="hljs-comment">// non-nil.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// prev is written atomically by the consumer and read</span>
    <span class="hljs-comment">// atomically by the producer. It only transitions from</span>
    <span class="hljs-comment">// non-nil to nil.</span>
    next, prev *poolChainElt
}
</code></pre>
<p><code>poolChain</code> &#x5B9E;&#x9645;&#x4E0A;&#x662F;&#x591A;&#x4E2A;&#x751F;&#x4EA7;&#x8005;&#x6D88;&#x8D39;&#x8005;&#x6A21;&#x578B;&#x7684;&#x94FE;&#x8868;&#x3002; &#x5BF9;&#x4E8E;&#x4E00;&#x4E2A;&#x5C40;&#x90E8; P &#x800C;&#x8A00;&#xFF0C;&#x5145;&#x5F53;&#x4E86;&#x591A;&#x4E2A;&#x961F;&#x5934;&#x7684;&#x5355;&#x4E00;&#x751F;&#x4EA7;&#x8005;&#xFF0C;&#x5B83;&#x53EF;&#x4EE5;&#x5B89;&#x5168;&#x7684; &#x5728;&#x6574;&#x4E2A;&#x94FE;&#x8868;&#x4E2D;&#x6240;&#x4E32;&#x8054;&#x7684;&#x961F;&#x5217;&#x7684;&#x961F;&#x5934;&#x8FDB;&#x884C;&#x64CD;&#x4F5C;&#x3002; &#x800C;&#x5176;&#x4ED6;&#x7684;&#x591A;&#x4E2A; P &#x800C;&#x8A00;&#xFF0C;&#x5219;&#x5145;&#x5F53;&#x4E86;&#x591A;&#x4E2A;&#x961F;&#x5C3E;&#x7684;&#x6D88;&#x8D39;&#x8005;&#xFF0C; &#x53EF;&#x4EE5;&#x5728;&#x6240;&#x4E32;&#x8054;&#x7684;&#x961F;&#x5217;&#x7684;&#x961F;&#x5C3E;&#x8FDB;&#x884C;&#x6D88;&#x8D39;&#xFF08;&#x5077;&#x53D6;&#xFF09;&#x3002;</p>
<p><code>popHead</code> &#x64CD;&#x4F5C;&#x53D1;&#x751F;&#x5728;&#x4ECE;&#x672C;&#x5730; shared &#x961F;&#x5217;&#x4E2D;&#x6D88;&#x8D39;&#x5E76;&#x83B7;&#x53D6;&#x5BF9;&#x8C61;&#xFF08;&#x6D88;&#x8D39;&#x8005;&#xFF09;&#x3002; <code>pushHead</code> &#x64CD;&#x4F5C;&#x53D1;&#x751F;&#x5728;&#x5411;&#x672C;&#x5730; shared &#x961F;&#x5217;&#x4E2D;&#x653E;&#x7F6E;&#x5BF9;&#x8C61;&#xFF08;&#x751F;&#x4EA7;&#x8005;&#xFF09;&#x3002; <code>popTail</code> &#x64CD;&#x4F5C;&#x5219;&#x53D1;&#x751F;&#x5728;&#x4ECE;&#x5176;&#x4ED6; P &#x7684; shared &#x961F;&#x5217;&#x4E2D;&#x5077;&#x53D6;&#x7684;&#x8FC7;&#x7A0B;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-keyword">func</span> (c *poolChain) pushHead(val any) {
    d := c.head
    <span class="hljs-comment">// &#x94FE;&#x8868;&#x4E3A;&#x7A7A;&#xFF0C;&#x521D;&#x59CB;&#x5316;&#x4E00;&#x4E2A;&#x94FE;&#x8868;</span>
    <span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// Initialize the chain.</span>
        <span class="hljs-keyword">const</span> initSize = <span class="hljs-number">8</span> <span class="hljs-comment">// Must be a power of 2</span>
        d = <span class="hljs-built_in">new</span>(poolChainElt)
        d.vals = <span class="hljs-built_in">make</span>([]eface, initSize)
        c.head = d
        storePoolChainElt(&amp;c.tail, d)
    }

    <span class="hljs-comment">// &#x5411;&#x961F;&#x5217;&#x4E2D;&#x5B58;&#x503C;&#x6210;&#x529F;&#xFF0C;&#x5219;&#x8FD4;&#x56DE;</span>
    <span class="hljs-keyword">if</span> d.pushHead(val) {
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-comment">// The current dequeue is full. Allocate a new one of twice</span>
    <span class="hljs-comment">// the size.</span>
    <span class="hljs-comment">// &#x961F;&#x5217;&#x5DF2;&#x6EE1;&#xFF0C;&#x5219;&#x5206;&#x914D;&#x4E00;&#x4E2A;&#x539F;&#x6765;&#x4E24;&#x500D;&#x5927;&#x5C0F;&#x7684;&#x961F;&#x5217;</span>
    newSize := <span class="hljs-built_in">len</span>(d.vals) * <span class="hljs-number">2</span>
    <span class="hljs-keyword">if</span> newSize &gt;= dequeueLimit {
        <span class="hljs-comment">// Can&apos;t make it any bigger.</span>
        <span class="hljs-comment">// &#x6700;&#x5927;&#x4E0A;&#x9650;&#x503C;</span>
        newSize = dequeueLimit
    }

    d2 := &amp;poolChainElt{prev: d}
    d2.vals = <span class="hljs-built_in">make</span>([]eface, newSize)
    c.head = d2
    storePoolChainElt(&amp;d.next, d2)
    d2.pushHead(val)
}

<span class="hljs-keyword">func</span> (c *poolChain) popHead() (any, <span class="hljs-keyword">bool</span>) {
    d := c.head
    <span class="hljs-comment">// &#x904D;&#x5386;&#x94FE;&#x8868;</span>
    <span class="hljs-keyword">for</span> d != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">if</span> val, ok := d.popHead(); ok {
            <span class="hljs-keyword">return</span> val, ok
        }
        <span class="hljs-comment">// There may still be unconsumed elements in the</span>
        <span class="hljs-comment">// previous dequeue, so try backing up.</span>
        <span class="hljs-comment">// &#x524D;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x53EF;&#x80FD;&#x4ECD;&#x7136;&#x6709;&#x672A;&#x6D88;&#x8017;&#x5B8C;&#x7684;&#x5143;&#x7D20;</span>
        d = loadPoolChainElt(&amp;d.prev)
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
}

<span class="hljs-keyword">func</span> (c *poolChain) popTail() (any, <span class="hljs-keyword">bool</span>) {
    d := loadPoolChainElt(&amp;c.tail)
    <span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
    }

    <span class="hljs-keyword">for</span> {
        <span class="hljs-comment">// It&apos;s important that we load the next pointer</span>
        <span class="hljs-comment">// *before* popping the tail. In general, d may be</span>
        <span class="hljs-comment">// transiently empty, but if next is non-nil before</span>
        <span class="hljs-comment">// the pop and the pop fails, then d is permanently</span>
        <span class="hljs-comment">// empty, which is the only condition under which it&apos;s</span>
        <span class="hljs-comment">// safe to drop d from the chain.</span>
        d2 := loadPoolChainElt(&amp;d.next)

        <span class="hljs-keyword">if</span> val, ok := d.popTail(); ok {
            <span class="hljs-keyword">return</span> val, ok
        }

        <span class="hljs-keyword">if</span> d2 == <span class="hljs-literal">nil</span> {
            <span class="hljs-comment">// This is the only dequeue. It&apos;s empty right</span>
            <span class="hljs-comment">// now, but could be pushed to in the future.</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
        }

        <span class="hljs-comment">// The tail of the chain has been drained, so move on</span>
        <span class="hljs-comment">// to the next dequeue. Try to drop it from the chain</span>
        <span class="hljs-comment">// so the next pop doesn&apos;t have to look at the empty</span>
        <span class="hljs-comment">// dequeue again.</span>
        <span class="hljs-comment">// CAS&#x64CD;&#x4F5C;&#xFF0C;&#x66F4;&#x65B0;tail&#x6307;&#x9488;</span>
        <span class="hljs-keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) {
            <span class="hljs-comment">// We won the race. Clear the prev pointer so</span>
            <span class="hljs-comment">// the garbage collector can collect the empty</span>
            <span class="hljs-comment">// dequeue and so popHead doesn&apos;t back up</span>
            <span class="hljs-comment">// further than necessary.</span>
            storePoolChainElt(&amp;d2.prev, <span class="hljs-literal">nil</span>)
        }
        d = d2
    }
}
</code></pre>
<h3 id="pooldequeue">poolDequeue</h3>
<p>&#x5185;&#x90E8;&#x7ED3;&#x6784;</p>
<pre><code class="lang-go"><span class="hljs-comment">// poolDequeue is a lock-free fixed-size single-producer,</span>
<span class="hljs-comment">// multi-consumer queue. The single producer can both push and pop</span>
<span class="hljs-comment">// from the head, and consumers can pop from the tail.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// It has the added feature that it nils out unused slots to avoid</span>
<span class="hljs-comment">// unnecessary retention of objects. This is important for sync.Pool,</span>
<span class="hljs-comment">// but not typically a property considered in the literature.</span>
<span class="hljs-comment">// &#x4E00;&#x4E2A;&#x5355;&#x751F;&#x4EA7;&#x8005;&#x3001;&#x591A;&#x6D88;&#x8D39;&#x8005;&#x7684;&#x56FA;&#x5B9A;&#x957F;&#x5EA6;&#x7684;&#x73AF;&#x5F62;&#x961F;&#x5217;</span>
<span class="hljs-keyword">type</span> poolDequeue <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// headTail packs together a 32-bit head index and a 32-bit</span>
    <span class="hljs-comment">// tail index. Both are indexes into vals modulo len(vals)-1.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// tail = index of oldest data in queue</span>
    <span class="hljs-comment">// head = index of next slot to fill</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Slots in the range [tail, head) are owned by consumers.</span>
    <span class="hljs-comment">// A consumer continues to own a slot outside this range until</span>
    <span class="hljs-comment">// it nils the slot, at which point ownership passes to the</span>
    <span class="hljs-comment">// producer.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// The head index is stored in the most-significant bits so</span>
    <span class="hljs-comment">// that we can atomically add to it and the overflow is</span>
    <span class="hljs-comment">// harmless.</span>
    <span class="hljs-comment">// &#x524D;32&#x4F4D;&#x8868;&#x793A;&#x4E0B;&#x4E00;&#x4E2A;&#x9700;&#x8981;&#x88AB;&#x586B;&#x5145;&#x7684;&#x5BF9;&#x8C61;&#x69FD;&#x7684;&#x7D22;&#x5F15;</span>
    <span class="hljs-comment">// &#x540E;32&#x4F4D;&#x8868;&#x793A;&#x4E86;&#x961F;&#x5217;&#x4E2D;&#x6700;&#x5148;&#x88AB;&#x63D2;&#x5165;&#x7684;&#x6570;&#x636E;&#x7684;&#x7D22;&#x5F15;</span>
    headTail <span class="hljs-keyword">uint64</span>

    <span class="hljs-comment">// vals is a ring buffer of interface{} values stored in this</span>
    <span class="hljs-comment">// dequeue. The size of this must be a power of 2.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// vals[i].typ is nil if the slot is empty and non-nil</span>
    <span class="hljs-comment">// otherwise. A slot is still in use until *both* the tail</span>
    <span class="hljs-comment">// index has moved beyond it and typ has been set to nil. This</span>
    <span class="hljs-comment">// is set to nil atomically by the consumer and read</span>
    <span class="hljs-comment">// atomically by the producer.</span>
    <span class="hljs-comment">// &#x5B58;&#x50A8;&#x5B9E;&#x9645;&#x7684;&#x5BF9;&#x8C61;</span>
    vals []eface
}

<span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> {
    typ, val unsafe.Pointer
}
</code></pre>
<p><code>poolDequeue</code> &#x662F;&#x4E00;&#x4E2A;&#x5355;&#x751F;&#x4EA7;&#x8005;&#x3001;&#x591A;&#x6D88;&#x8D39;&#x8005;&#x7684;&#x56FA;&#x5B9A;&#x957F;&#x5EA6;&#x7684;&#x73AF;&#x72B6;&#x961F;&#x5217;&#xFF0C; <code>popHead</code>&#x3001;<code>pushHead</code> &#x7531;&#x5C40;&#x90E8;&#x7684; P &#x64CD;&#x4F5C;&#x961F;&#x9996;&#xFF0C;&#x800C; <code>popTail</code> &#x7531;&#x5176;&#x4ED6;&#x5E76;&#x884C;&#x7684; P &#x64CD;&#x4F5C;&#x961F;&#x5C3E;&#x3002; &#x5176;&#x4E2D; <code>headTail</code> &#x5B57;&#x6BB5;&#x7684;&#x524D; 32 &#x4F4D;&#x8868;&#x793A;&#x4E86;&#x4E0B;&#x4E00;&#x4E2A;&#x9700;&#x8981;&#x88AB;&#x586B;&#x5145;&#x7684;&#x5BF9;&#x8C61;&#x69FD;&#x7684;&#x7D22;&#x5F15;&#xFF0C; &#x800C;&#x540E; 32 &#x4F4D;&#x5219;&#x8868;&#x793A;&#x4E86;&#x961F;&#x5217;&#x4E2D;&#x6700;&#x5148;&#x88AB;&#x63D2;&#x5165;&#x7684;&#x6570;&#x636E;&#x7684;&#x7D22;&#x5F15;&#x3002;</p>
<p>&#x901A;&#x8FC7; <code>pack</code>/<code>unpack</code>&#x65B9;&#x6CD5;&#x6765;&#x5B9E;&#x73B0;&#x5BF9;<code>head</code>&#x548C;<code>tail</code> &#x7684;&#x8BFB;&#x5199;</p>
<pre><code class="lang-go"><span class="hljs-comment">// &#x5C06; head &#x548C; tail &#x6307;&#x9488;&#x4ECE; d.headTail &#x4E2D;&#x5206;&#x79BB;&#x5F00;&#x6765;</span>
<span class="hljs-keyword">func</span> (d *poolDequeue) unpack(ptrs <span class="hljs-keyword">uint64</span>) (head, tail <span class="hljs-keyword">uint32</span>) {
    <span class="hljs-keyword">const</span> mask = <span class="hljs-number">1</span>&lt;&lt;dequeueBits - <span class="hljs-number">1</span>
    head = <span class="hljs-keyword">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)
    tail = <span class="hljs-keyword">uint32</span>(ptrs &amp; mask)
    <span class="hljs-keyword">return</span>
}

<span class="hljs-comment">// &#x5C06; head &#x548C; tail &#x6307;&#x9488;&#x6253;&#x5305;&#x5230; d.headTail &#x4E00;&#x4E2A; 64bit &#x7684;&#x53D8;&#x91CF;&#x4E2D;</span>
<span class="hljs-keyword">func</span> (d *poolDequeue) pack(head, tail <span class="hljs-keyword">uint32</span>) <span class="hljs-keyword">uint64</span> {
    <span class="hljs-keyword">const</span> mask = <span class="hljs-number">1</span>&lt;&lt;dequeueBits - <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">uint64</span>(head) &lt;&lt; dequeueBits) |
        <span class="hljs-keyword">uint64</span>(tail&amp;mask)
}
</code></pre>
<p>&#x4ECE; <code>poolChain</code> &#x7684;&#x5B9E;&#x73B0;&#x4E2D;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF0C;&#x6BCF;&#x4E2A; <code>poolDequeue</code> &#x7684; <code>vals</code> &#x957F;&#x5EA6;&#x4E3A; 8&#x3002; &#x4F46;&#x7531;&#x4E8E;&#x662F;&#x5FAA;&#x73AF;&#x961F;&#x5217;&#xFF0C;&#x5B9E;&#x73B0;&#x4E2D;&#x5E76;&#x4E0D;&#x5173;&#x5FC3;&#x961F;&#x5217;&#x7684;&#x957F;&#x5EA6;&#xFF0C;&#x53EA;&#x8981;&#x6536;&#x5C3E;&#x5143;&#x7D20;&#x7684;&#x7D22;&#x5F15;&#x76F8;&#x7B49;&#xFF0C;&#x5219;&#x8BF4;&#x660E;&#x961F;&#x5217;&#x5DF2;&#x6EE1;&#x3002; &#x56E0;&#x6B64;&#x901A;&#x8FC7; CAS &#x539F;&#x8BED;&#x5B9E;&#x73B0;&#x5355;&#x4E00;&#x751F;&#x4EA7;&#x8005;&#x7684;&#x5BF9;&#x961F;&#x5934;&#x7684;&#x8BFB; <code>popHead</code> &#x548C;&#x5199; <code>pushHead</code></p>
<p>&#x901A;&#x8FC7; <code>interface{}</code> &#x7684; typ &#x548C; val &#x4E24;&#x6BB5;&#x5F0F; &#x7ED3;&#x6784;&#x7684;&#x8BFB;&#x5199;&#x5148;&#x540E;&#x987A;&#x5E8F;&#xFF0C;&#x5728; <code>popTail</code> &#x548C; <code>pushHead</code> &#x4E4B;&#x95F4;&#x6D88;&#x9664;&#x4E86;&#x7ADE;&#x4E89;</p>
<pre><code class="lang-go"><span class="hljs-comment">// pushHead adds val at the head of the queue. It returns false if the</span>
<span class="hljs-comment">// queue is full. It must only be called by a single producer.</span>
<span class="hljs-keyword">func</span> (d *poolDequeue) pushHead(val any) <span class="hljs-keyword">bool</span> {
    ptrs := atomic.LoadUint64(&amp;d.headTail)
    head, tail := d.unpack(ptrs)
    <span class="hljs-keyword">if</span> (tail+<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(d.vals)))&amp;(<span class="hljs-number">1</span>&lt;&lt;dequeueBits<span class="hljs-number">-1</span>) == head {
        <span class="hljs-comment">// Queue is full.</span>
        <span class="hljs-comment">// &#x961F;&#x5217;&#x6EE1;&#x4E86;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
    slot := &amp;d.vals[head&amp;<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(d.vals)<span class="hljs-number">-1</span>)]

    <span class="hljs-comment">// Check if the head slot has been released by popTail.</span>
    <span class="hljs-comment">// &#x6B64;&#x5904;&#x53EF;&#x80FD;&#x548C;popTail&#x53D1;&#x751F;&#x7ADE;&#x4E89;</span>
    typ := atomic.LoadPointer(&amp;slot.typ)
    <span class="hljs-keyword">if</span> typ != <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// Another goroutine is still cleaning up the tail, so</span>
        <span class="hljs-comment">// the queue is actually still full.</span>
        <span class="hljs-comment">// &#x5176;&#x4ED6;&#x534F;&#x7A0B;&#x5728;&#x8C03;&#x7528;popTail&#x6E05;&#x7406;&#xFF0C;&#x6B64;&#x65F6;&#x961F;&#x5217;&#x4ECD;&#x7136;&#x662F;&#x6EE1;&#x7684;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }

    <span class="hljs-comment">// The head slot is free, so we own it.</span>
    <span class="hljs-keyword">if</span> val == <span class="hljs-literal">nil</span> {
        val = dequeueNil(<span class="hljs-literal">nil</span>)
    }
    *(*any)(unsafe.Pointer(slot)) = val

    <span class="hljs-comment">// Increment head. This passes ownership of slot to popTail</span>
    <span class="hljs-comment">// and acts as a store barrier for writing the slot.</span>
    atomic.AddUint64(&amp;d.headTail, <span class="hljs-number">1</span>&lt;&lt;dequeueBits)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}

<span class="hljs-comment">// popHead removes and returns the element at the head of the queue.</span>
<span class="hljs-comment">// It returns false if the queue is empty. It must only be called by a</span>
<span class="hljs-comment">// single producer.</span>
<span class="hljs-keyword">func</span> (d *poolDequeue) popHead() (any, <span class="hljs-keyword">bool</span>) {
    <span class="hljs-keyword">var</span> slot *eface
    <span class="hljs-keyword">for</span> {
        ptrs := atomic.LoadUint64(&amp;d.headTail)
        head, tail := d.unpack(ptrs)
        <span class="hljs-comment">// &#x961F;&#x5217;&#x6EE1;&#x4E86;</span>
        <span class="hljs-keyword">if</span> tail == head {
            <span class="hljs-comment">// Queue is empty.</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
        }

        <span class="hljs-comment">// Confirm tail and decrement head. We do this before</span>
        <span class="hljs-comment">// reading the value to take back ownership of this</span>
        <span class="hljs-comment">// slot.</span>
        head--
        ptrs2 := d.pack(head, tail)
        <span class="hljs-keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) {
            <span class="hljs-comment">// We successfully took back slot.</span>
            slot = &amp;d.vals[head&amp;<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(d.vals)<span class="hljs-number">-1</span>)]
            <span class="hljs-keyword">break</span>
        }
    }

    val := *(*any)(unsafe.Pointer(slot))
    <span class="hljs-keyword">if</span> val == dequeueNil(<span class="hljs-literal">nil</span>) {
        val = <span class="hljs-literal">nil</span>
    }
    <span class="hljs-comment">// Zero the slot. Unlike popTail, this isn&apos;t racing with</span>
    <span class="hljs-comment">// pushHead, so we don&apos;t need to be careful here.</span>
    *slot = eface{}
    <span class="hljs-keyword">return</span> val, <span class="hljs-literal">true</span>
}

<span class="hljs-comment">// popTail removes and returns the element at the tail of the queue.</span>
<span class="hljs-comment">// It returns false if the queue is empty. It may be called by any</span>
<span class="hljs-comment">// number of consumers.</span>
<span class="hljs-keyword">func</span> (d *poolDequeue) popTail() (any, <span class="hljs-keyword">bool</span>) {
    <span class="hljs-keyword">var</span> slot *eface
    <span class="hljs-keyword">for</span> {
        ptrs := atomic.LoadUint64(&amp;d.headTail)
        head, tail := d.unpack(ptrs)
        <span class="hljs-keyword">if</span> tail == head {
            <span class="hljs-comment">// Queue is empty.</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
        }

        <span class="hljs-comment">// Confirm head and tail (for our speculative check</span>
        <span class="hljs-comment">// above) and increment tail. If this succeeds, then</span>
        <span class="hljs-comment">// we own the slot at tail.</span>
        ptrs2 := d.pack(head, tail+<span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) {
            <span class="hljs-comment">// Success.</span>
            slot = &amp;d.vals[tail&amp;<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(d.vals)<span class="hljs-number">-1</span>)]
            <span class="hljs-keyword">break</span>
        }
    }

    <span class="hljs-comment">// We now own slot.</span>
    val := *(*any)(unsafe.Pointer(slot))
    <span class="hljs-keyword">if</span> val == dequeueNil(<span class="hljs-literal">nil</span>) {
        val = <span class="hljs-literal">nil</span>
    }

    <span class="hljs-comment">// Tell pushHead that we&apos;re done with this slot. Zeroing the</span>
    <span class="hljs-comment">// slot is also important so we don&apos;t leave behind references</span>
    <span class="hljs-comment">// that could keep this object live longer than necessary.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// We write to val first and then publish that we&apos;re done with</span>
    <span class="hljs-comment">// this slot by atomically writing to typ.</span>
    <span class="hljs-comment">// &#x6CE8;&#x610F;&#xFF1A;&#x6B64;&#x5904;&#x53EF;&#x80FD;&#x4E0E; pushHead &#x53D1;&#x751F;&#x7ADE;&#x4E89;&#xFF0C;&#x89E3;&#x51B3;&#x65B9;&#x6848;&#x662F;&#xFF1A;</span>
    <span class="hljs-comment">// 1. &#x8BA9; pushHead &#x5148;&#x8BFB;&#x53D6; typ &#x7684;&#x503C;&#xFF0C;&#x5982;&#x679C; typ &#x503C;&#x4E0D;&#x4E3A; nil&#xFF0C;&#x5219;&#x8BF4;&#x660E; popTail &#x5C1A;&#x672A;&#x6E05;&#x7406;&#x5B8C; slot</span>
    <span class="hljs-comment">// 2. &#x8BA9; popTail &#x5148;&#x6E05;&#x7406;&#x6389; val &#x4E2D;&#x7684;&#x5185;&#x5BB9;&#xFF0C;&#x5728;&#x6E05;&#x7406;&#x6389; typ&#xFF0C;&#x4ECE;&#x800C;&#x786E;&#x4FDD;&#x4E0D;&#x4F1A;&#x4E0E; pushHead &#x5BF9; slot &#x7684;&#x5199;&#x884C;&#x4E3A;&#x53D1;&#x751F;&#x7ADE;&#x4E89;</span>
    slot.val = <span class="hljs-literal">nil</span>
    atomic.StorePointer(&amp;slot.typ, <span class="hljs-literal">nil</span>)
    <span class="hljs-comment">// At this point pushHead owns the slot.</span>

    <span class="hljs-keyword">return</span> val, <span class="hljs-literal">true</span>
}
</code></pre>
<p>&#x4E00;&#x4E2A; goroutine &#x56FA;&#x5B9A;&#x5728; P &#x4E0A;&#xFF0C;&#x4ECE;&#x5F53;&#x524D; P &#x5BF9;&#x5E94;&#x7684; <code>private</code> &#x53D6;&#x503C;&#xFF0C; shared &#x5B57;&#x6BB5;&#x4F5C;&#x4E3A;&#x4E00;&#x4E2A;&#x4F18;&#x5316;&#x8FC7;&#x7684;&#x94FE;&#x5F0F;&#x65E0;&#x9501;&#x53D8;&#x957F;&#x961F;&#x5217;&#xFF0C;&#x5F53;&#x5728; <code>private</code> &#x53D6;&#x4E0D;&#x5230;&#x503C;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C; &#x4ECE;&#x5BF9;&#x5E94;&#x7684; <code>shared</code> &#x961F;&#x5217;&#x7684;&#x961F;&#x9996;&#x53D6;&#xFF0C;&#x82E5;&#x8FD8;&#x662F;&#x53D6;&#x4E0D;&#x5230;&#xFF0C;&#x5219;&#x5C1D;&#x8BD5;&#x4ECE;&#x5176;&#x4ED6; P &#x7684; <code>shared</code> &#x961F;&#x5217;&#x961F;&#x5C3E;&#x4E2D;&#x5077;&#x53D6;&#x3002; &#x82E5;&#x5077;&#x4E0D;&#x5230;&#xFF0C;&#x5219;&#x5C1D;&#x8BD5;&#x4ECE;&#x4E0A;&#x4E00;&#x4E2A; GC &#x5468;&#x671F;&#x9057;&#x7559;&#x5230; <code>victim</code> &#x7F13;&#x5B58;&#x4E2D;&#x53D6;&#xFF0C;&#x5426;&#x5219;&#x8C03;&#x7528; <code>New</code> &#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x5BF9;&#x8C61;&#x3002;</p>
<p>&#x5BF9;&#x4E8E;&#x56DE;&#x6536;&#x800C;&#x8A00;&#xFF0C;&#x6C60;&#x4E2D;&#x6240;&#x6709;&#x4E34;&#x65F6;&#x5BF9;&#x8C61;&#x5728;&#x4E00;&#x6B21; GC &#x540E;&#x4F1A;&#x88AB;&#x653E;&#x5165; <code>victim</code> &#x7F13;&#x5B58;&#x4E2D;&#xFF0C; &#x800C;&#x524D;&#x4E00;&#x4E2A;&#x5468;&#x671F;&#x88AB;&#x653E;&#x5165; <code>victim</code> &#x7684;&#x7F13;&#x5B58;&#x5219;&#x4F1A;&#x88AB;&#x6E05;&#x7406;&#x6389;&#x3002;</p>
<p>&#x5BF9;&#x4E8E;&#x8C03;&#x7528;&#x65B9;&#x800C;&#x8A00;&#xFF0C;&#x5F53; Get &#x5230;&#x4E34;&#x65F6;&#x5BF9;&#x8C61;&#x540E;&#xFF0C;&#x4FBF;&#x8131;&#x79BB;&#x4E86;&#x6C60;&#x672C;&#x8EAB;&#x4E0D;&#x53D7;&#x63A7;&#x5236;&#x3002; &#x7528;&#x65B9;&#x6709;&#x8D23;&#x4EFB;&#x5C06;&#x4F7F;&#x7528;&#x5B8C;&#x7684;&#x5BF9;&#x8C61;&#x653E;&#x56DE;&#x6C60;&#x4E2D;&#x3002;</p>
<p>&#x8FD9;&#x79CD;&#x4E24;&#x7EA7;&#x7F13;&#x5B58;&#x7684;&#x4F18;&#x5316;&#x7684;&#x4F18;&#x52BF;&#x5728;&#x4E8E;&#xFF1A;</p>
<ol>
<li>&#x663E;&#x8457;&#x964D;&#x4F4E;&#x4E86; GC &#x53D1;&#x751F;&#x524D;&#x6E05;&#x7406;&#x5F53;&#x524D;&#x5468;&#x671F;&#x4E2D;&#x4EA7;&#x751F;&#x7684;&#x5927;&#x91CF;&#x7F13;&#x5B58;&#x5BF9;&#x8C61;&#x7684;&#x5F71;&#x54CD;&#xFF1A;&#x56E0;&#x4E3A;&#x56DE;&#x6536;&#x88AB;&#x63A8;&#x8FDF;&#x5230;&#x4E86;&#x4E0B;&#x4E2A; GC &#x5468;&#x671F;&#xFF1B;</li>
<li>&#x663E;&#x8457;&#x964D;&#x4F4E;&#x4E86; GC &#x53D1;&#x751F;&#x540E; New &#x5BF9;&#x8C61;&#x7684;&#x6210;&#x672C;&#xFF1A;&#x56E0;&#x4E3A;&#x5BC6;&#x96C6;&#x7684;&#x7F13;&#x5B58;&#x5BF9;&#x8C61;&#x8BFB;&#x5199;&#x53EF;&#x80FD;&#x4ECE;&#x4E0A;&#x4E2A;&#x5468;&#x671F;&#x4E2D;&#x672A;&#x6E05;&#x7406;&#x7684;&#x5BF9;&#x8C61;&#x4E2D;&#x5077;&#x53D6;&#x3002;</li>
</ol>
<h2 id="6&#x3001;syncmap">6&#x3001;sync.Map</h2>
<p><span style="color:red">&#x8BED;&#x8A00;&#x5185;&#x5EFA;&#x7684;&#x6563;&#x5217;&#x8868;map&#x7ED3;&#x6784;&#x5E76;&#x4E0D;&#x662F;&#x5E76;&#x53D1;&#x5B89;&#x5168;&#x7684;&#xFF0C;&#x5728;&#x5E76;&#x53D1;&#x7684;&#x5BF9;&#x8BE5;&#x7ED3;&#x6784;&#x8FDB;&#x884C;&#x8BFB;&#x5199;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x751A;&#x81F3;&#x53EF;&#x80FD;&#x4EA7;&#x751F;&#x4E0D;&#x53EF;&#x6062;&#x590D;&#x7684;&#x8FD0;&#x884C;&#x65F6;&#x6050;&#x614C;&#xFF0C;&#x5BFC;&#x81F4;&#x7A0B;&#x5E8F;&#x5C06;&#x4E0D;&#x53D7;&#x63A7;&#x5236;&#x7684;&#x5D29;&#x6E83;&#x3002;&#x4E3A;&#x4E86;&#x89E3;&#x51B3;&#x5E76;&#x53D1;&#x95EE;&#x9898;&#xFF0C;sync&#x5305;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x79CD;&#x7279;&#x6B8A;&#x7684;&#x5E76;&#x53D1;&#x5B89;&#x5168;&#x7684;&#x6563;&#x5217;&#x8868;Map&#x7ED3;&#x6784;&#x3002;&#x8BE5;&#x7ED3;&#x6784;&#x7684;&#x5B9E;&#x73B0;&#x4E3B;&#x8981;&#x9488;&#x5BF9;&#x4E86;&#x8BFB;&#x591A;&#x5199;&#x5C11;&#x7684;&#x8FD9;&#x4E00;&#x7279;&#x6B8A;&#x573A;&#x666F;&#x8FDB;&#x884C;&#x7684;&#x4F18;&#x5316;&#x3002;</span></p>
<h3 id="&#x7ED3;&#x6784;">&#x7ED3;&#x6784;</h3>
<p>&#x5728;&#x8FD9;&#x4E2A;&#x7ED3;&#x6784;&#x4E2D;&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230;read&#x548C;dirty&#x5206;&#x522B;&#x5BF9;&#x5E94;&#x4E24;&#x4E2A;map&#xFF0C;&#x4F46;read&#x91C7;&#x7528;&#x539F;&#x5B50;&#x5316;&#x7684;&#x6307;&#x9488;&#x7C7B;&#x578B;&#x3002;</p>
<p><span style="color:red">sync.Map &#x7684;&#x601D;&#x8DEF;&#x662F;&#x53D1;&#x751F;&#x8DB3;&#x591F;&#x591A;&#x7684;&#x8BFB;&#x65F6;&#xFF0C;&#x5C31;&#x5C06; dirty map &#x590D;&#x5236;&#x4E00;&#x4EFD;&#x5230; read map &#x4E0A;&#x3002; &#x4ECE;&#x800C;&#x5B9E;&#x73B0;&#x5728; read map &#x4E0A;&#x7684;&#x8BFB;&#x64CD;&#x4F5C;&#x4E0D;&#x518D;&#x9700;&#x8981;&#x6602;&#x8D35;&#x7684; Mutex &#x64CD;&#x4F5C;&#x3002;</span></p>
<pre><code class="lang-go"><span class="hljs-comment">// src/sync/map.go</span>
<span class="hljs-comment">// Map is like a Go map[interface{}]interface{} but is safe for concurrent use</span>
<span class="hljs-comment">// by multiple goroutines without additional locking or coordination.</span>
<span class="hljs-comment">// Loads, stores, and deletes run in amortized constant time.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// The Map type is specialized. Most code should use a plain Go map instead,</span>
<span class="hljs-comment">// with separate locking or coordination, for better type safety and to make it</span>
<span class="hljs-comment">// easier to maintain other invariants along with the map content.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// The Map type is optimized for two common use cases: (1) when the entry for a given</span>
<span class="hljs-comment">// key is only ever written once but read many times, as in caches that only grow,</span>
<span class="hljs-comment">// or (2) when multiple goroutines read, write, and overwrite entries for disjoint</span>
<span class="hljs-comment">// sets of keys. In these two cases, use of a Map may significantly reduce lock</span>
<span class="hljs-comment">// contention compared to a Go map paired with a separate Mutex or RWMutex.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// The zero Map is empty and ready for use. A Map must not be copied after first use.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In the terminology of the Go memory model, Map arranges that a write operation</span>
<span class="hljs-comment">// &#x201C;synchronizes before&#x201D; any read operation that observes the effect of the write, where</span>
<span class="hljs-comment">// read and write operations are defined as follows.</span>
<span class="hljs-comment">// Load, LoadAndDelete, LoadOrStore, Swap, CompareAndSwap, and CompareAndDelete</span>
<span class="hljs-comment">// are read operations; Delete, LoadAndDelete, Store, and Swap are write operations;</span>
<span class="hljs-comment">// LoadOrStore is a write operation when it returns loaded set to false;</span>
<span class="hljs-comment">// CompareAndSwap is a write operation when it returns swapped set to true;</span>
<span class="hljs-comment">// and CompareAndDelete is a write operation when it returns deleted set to true.</span>
<span class="hljs-comment">// Map &#x662F;&#x4E00;&#x79CD;&#x5E76;&#x53D1;&#x5B89;&#x5168;&#x7684; map[interface{}]interface{}&#xFF0C;&#x5728;&#x591A;&#x4E2A; goroutine &#x4E2D;&#x6CA1;&#x6709;&#x989D;&#x5916;&#x7684;&#x9501;&#x6761;&#x4EF6;</span>
<span class="hljs-comment">// &#x8BFB;&#x53D6;&#x3001;&#x5B58;&#x50A8;&#x548C;&#x5220;&#x9664;&#x64CD;&#x4F5C;&#x7684;&#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6;&#x5E73;&#x5747;&#x4E3A;&#x5E38;&#x91CF;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Map &#x7C7B;&#x578B;&#x975E;&#x5E38;&#x7279;&#x6B8A;&#xFF0C;&#x5927;&#x90E8;&#x5206;&#x4EE3;&#x7801;&#x5E94;&#x8BE5;&#x4F7F;&#x7528;&#x539F;&#x59CB;&#x7684; Go map&#x3002;&#x5B83;&#x5177;&#x6709;&#x5355;&#x72EC;&#x7684;&#x9501;&#x6216;&#x534F;&#x8C03;&#x4EE5;&#x83B7;&#x5F97;&#x7C7B;&#x578B;&#x5B89;&#x5168;&#x4E14;&#x66F4;&#x6613;&#x7EF4;&#x62A4;&#x3002;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Map &#x7C7B;&#x578B;&#x9488;&#x5BF9;&#x4E24;&#x79CD;&#x5E38;&#x89C1;&#x7684;&#x7528;&#x4F8B;&#x8FDB;&#x884C;&#x4F18;&#x5316;&#xFF1A;</span>
<span class="hljs-comment">// 1. &#x7ED9;&#x5B9A; key &#x53EA;&#x4F1A;&#x4EA7;&#x751F;&#x5199;&#x4E00;&#x6B21;&#x4F46;&#x662F;&#x5374;&#x4F1A;&#x591A;&#x6B21;&#x8BFB;&#xFF0C;&#x7C7B;&#x4F3C;&#x4E4E;&#x53EA;&#x589E;&#x7684;&#x7F13;&#x5B58;</span>
<span class="hljs-comment">// 2. &#x591A;&#x4E2A; goroutine &#x8BFB;&#x3001;&#x5199;&#x4EE5;&#x53CA;&#x8986;&#x76D6;&#x4E0D;&#x540C;&#x7684; key</span>
<span class="hljs-comment">// &#x8FD9;&#x4E24;&#x79CD;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x4E0E;&#x5355;&#x72EC;&#x4F7F;&#x7528; Mutex &#x6216; RWMutex &#x7684; map &#x76F8;&#x6BD4;&#xFF0C;&#x4F1A;&#x663E;&#x8457;&#x964D;&#x4F4E;&#x7ADE;&#x4E89;&#x60C5;&#x51B5;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &#x96F6;&#x503C; Map &#x4E3A;&#x7A7A;&#x4E14;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x4F7F;&#x7528;&#xFF0C;Map &#x4F7F;&#x7528;&#x540E;&#x4E0D;&#x80FD;&#x590D;&#x5236;</span>
<span class="hljs-keyword">type</span> Map <span class="hljs-keyword">struct</span> {
    mu Mutex

    <span class="hljs-comment">// read contains the portion of the map&apos;s contents that are safe for</span>
    <span class="hljs-comment">// concurrent access (with or without mu held).</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// The read field itself is always safe to load, but must only be stored with</span>
    <span class="hljs-comment">// mu held.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Entries stored in read may be updated concurrently without mu, but updating</span>
    <span class="hljs-comment">// a previously-expunged entry requires that the entry be copied to the dirty</span>
    <span class="hljs-comment">// map and unexpunged with mu held.</span>
    <span class="hljs-comment">// read &#x5305;&#x542B; map &#x5185;&#x5BB9;&#x7684;&#x4E00;&#x90E8;&#x5206;&#xFF0C;&#x8FD9;&#x4E9B;&#x5185;&#x5BB9;&#x5BF9;&#x4E8E;&#x5E76;&#x53D1;&#x8BBF;&#x95EE;&#x662F;&#x5B89;&#x5168;&#x7684;&#xFF08;&#x6709;&#x6216;&#x4E0D;&#x4F7F;&#x7528; mu&#xFF09;&#x3002;</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// read &#x5B57;&#x6BB5; load &#x603B;&#x662F;&#x5B89;&#x5168;&#x7684;&#xFF0C;&#x4F46;&#x662F;&#x5FC5;&#x987B;&#x4F7F;&#x7528; mu &#x8FDB;&#x884C; store&#x3002;</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// &#x5B58;&#x50A8;&#x5728; read &#x4E2D;&#x7684; entry &#x53EF;&#x4EE5;&#x5728;&#x6CA1;&#x6709; mu &#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x5E76;&#x53D1;&#x66F4;&#x65B0;&#xFF0C;</span>
    <span class="hljs-comment">// &#x4F46;&#x662F;&#x66F4;&#x65B0;&#x5DF2;&#x7ECF;&#x5220;&#x9664;&#x7684; entry &#x9700;&#x8981;&#x5C06; entry &#x590D;&#x5236;&#x5230; dirty map &#x4E2D;&#xFF0C;&#x5E76;&#x4F7F;&#x7528; mu &#x8FDB;&#x884C;&#x5220;&#x9664;&#x3002;</span>
    read atomic.Pointer[readOnly]

    <span class="hljs-comment">// dirty contains the portion of the map&apos;s contents that require mu to be</span>
    <span class="hljs-comment">// held. To ensure that the dirty map can be promoted to the read map quickly,</span>
    <span class="hljs-comment">// it also includes all of the non-expunged entries in the read map.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Expunged entries are not stored in the dirty map. An expunged entry in the</span>
    <span class="hljs-comment">// clean map must be unexpunged and added to the dirty map before a new value</span>
    <span class="hljs-comment">// can be stored to it.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// If the dirty map is nil, the next write to the map will initialize it by</span>
    <span class="hljs-comment">// making a shallow copy of the clean map, omitting stale entries.</span>
    <span class="hljs-comment">// dirty &#x542B;&#x4E86;&#x9700;&#x8981; mu &#x7684; map &#x5185;&#x5BB9;&#x7684;&#x4E00;&#x90E8;&#x5206;&#x3002;&#x4E3A;&#x4E86;&#x786E;&#x4FDD;&#x5C06; dirty map &#x5FEB;&#x901F;&#x5730;&#x8F6C;&#x4E3A; read map&#xFF0C;</span>
    <span class="hljs-comment">// &#x5B83;&#x8FD8;&#x5305;&#x62EC;&#x4E86; read map &#x4E2D;&#x6240;&#x6709;&#x672A;&#x5220;&#x9664;&#x7684; entry&#x3002;</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// &#x5220;&#x9664;&#x7684; entry &#x4E0D;&#x4F1A;&#x5B58;&#x50A8;&#x5728; dirty map &#x4E2D;&#x3002;&#x5728; clean map &#x4E2D;&#xFF0C;&#x88AB;&#x5220;&#x9664;&#x7684; entry &#x5FC5;&#x987B;&#x88AB;&#x5220;&#x9664;&#x5E76;&#x6DFB;&#x52A0;&#x5230; dirty &#x4E2D;&#xFF0C;</span>
    <span class="hljs-comment">// &#x7136;&#x540E;&#x624D;&#x80FD;&#x5C06;&#x65B0;&#x7684;&#x503C;&#x5B58;&#x50A8;&#x4E3A;&#x5B83;</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// &#x5982;&#x679C; dirty map &#x4E3A; nil&#xFF0C;&#x5219;&#x4E0B;&#x4E00;&#x6B21;&#x7684;&#x5199;&#x884C;&#x4E3A;&#x4F1A;&#x901A;&#x8FC7; clean map &#x7684;&#x6D45;&#x62F7;&#x8D1D;&#x8FDB;&#x884C;&#x521D;&#x59CB;&#x5316;</span>
    dirty <span class="hljs-keyword">map</span>[any]*entry

    <span class="hljs-comment">// misses counts the number of loads since the read map was last updated that</span>
    <span class="hljs-comment">// needed to lock mu to determine whether the key was present.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Once enough misses have occurred to cover the cost of copying the dirty</span>
    <span class="hljs-comment">// map, the dirty map will be promoted to the read map (in the unamended</span>
    <span class="hljs-comment">// state) and the next store to the map will make a new dirty copy.</span>
    <span class="hljs-comment">// misses &#x8BA1;&#x7B97;&#x4E86;&#x4ECE; read map &#x4E0A;&#x4E00;&#x6B21;&#x66F4;&#x65B0;&#x5F00;&#x59CB;&#x7684; load &#x6570;&#xFF0C;&#x9700;&#x8981; lock &#x4EE5;&#x786E;&#x5B9A; key &#x662F;&#x5426;&#x5B58;&#x5728;&#x3002;</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// &#x4E00;&#x65E6;&#x53D1;&#x751F;&#x8DB3;&#x591F;&#x7684; misses &#x8DB3;&#x4EE5;&#x56CA;&#x62EC;&#x590D;&#x5236; dirty map &#x7684;&#x6210;&#x672C;&#xFF0C;dirty map &#x5C06;&#x88AB;&#x63D0;&#x5347;&#x4E3A; read map&#xFF08;&#x5904;&#x4E8E;&#x672A;&#x4FEE;&#x6539;&#x72B6;&#x6001;&#xFF09;</span>
    <span class="hljs-comment">// &#x5E76;&#x4E14; map &#x7684;&#x4E0B;&#x4E00;&#x6B21; store &#x5C06;&#x751F;&#x6210;&#x65B0;&#x7684; dirty &#x526F;&#x672C;&#x3002;</span>
    misses <span class="hljs-keyword">int</span>
}

<span class="hljs-comment">// readOnly is an immutable struct stored atomically in the Map.read field.</span>
<span class="hljs-keyword">type</span> readOnly <span class="hljs-keyword">struct</span> {
    m <span class="hljs-keyword">map</span>[any]*entry
    <span class="hljs-comment">// &#x5982;&#x679C;&#x810F;&#x6620;&#x5C04;&#x5305;&#x542B;&#x4E00;&#x4E9B;&#x4E0D;&#x5728; m &#x4E2D;&#x7684;&#x952E;&#xFF0C;&#x5219;&#x4E3A; true&#x3002;</span>
    amended <span class="hljs-keyword">bool</span> <span class="hljs-comment">// true if the dirty map contains some key not in m.</span>
}

<span class="hljs-comment">// expunged is an arbitrary pointer that marks entries which have been deleted</span>
<span class="hljs-comment">// from the dirty map.</span>
<span class="hljs-comment">// expunged &#x662F;&#x4E00;&#x4E2A;&#x4EFB;&#x610F;&#x6307;&#x9488;&#xFF0C;&#x7528;&#x4E8E;&#x6807;&#x8BB0;&#x5DF2;&#x4ECE;&#x810F;&#x6620;&#x5C04;&#x4E2D;&#x5220;&#x9664;&#x7684;&#x6761;&#x76EE;&#x3002;</span>
<span class="hljs-keyword">var</span> expunged = <span class="hljs-built_in">new</span>(any)

<span class="hljs-comment">// An entry is a slot in the map corresponding to a particular key.</span>
<span class="hljs-comment">// &#x53EA;&#x662F;&#x7B80;&#x5355;&#x7684;&#x521B;&#x5EFA;&#x4E00;&#x4E2A; entry</span>
<span class="hljs-comment">// entry &#x662F;&#x4E00;&#x4E2A;&#x5BF9;&#x5E94;&#x4E8E; map &#x4E2D;&#x7279;&#x6B8A; key &#x7684; slot</span>
<span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// p points to the interface{} value stored for the entry.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// If p == nil, the entry has been deleted, and either m.dirty == nil or</span>
    <span class="hljs-comment">// m.dirty[key] is e.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// If p == expunged, the entry has been deleted, m.dirty != nil, and the entry</span>
    <span class="hljs-comment">// is missing from m.dirty.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty</span>
    <span class="hljs-comment">// != nil, in m.dirty[key].</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// An entry can be deleted by atomic replacement with nil: when m.dirty is</span>
    <span class="hljs-comment">// next created, it will atomically replace nil with expunged and leave</span>
    <span class="hljs-comment">// m.dirty[key] unset.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// An entry&apos;s associated value can be updated by atomic replacement, provided</span>
    <span class="hljs-comment">// p != expunged. If p == expunged, an entry&apos;s associated value can be updated</span>
    <span class="hljs-comment">// only after first setting m.dirty[key] = e so that lookups using the dirty</span>
    <span class="hljs-comment">// map find the entry.</span>
    <span class="hljs-comment">// p &#x6307;&#x5411; interface{} &#x7C7B;&#x578B;&#x7684;&#x503C;&#xFF0C;&#x7528;&#x4E8E;&#x4FDD;&#x5B58; entry</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// &#x5982;&#x679C; p == nil&#xFF0C;&#x5219; entry &#x5DF2;&#x88AB;&#x5220;&#x9664;&#xFF0C;&#x4E14; m.dirty == nil</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// &#x5982;&#x679C; p == expunged, &#x5219; entry &#x5DF2;&#x7ECF;&#x88AB;&#x5220;&#x9664;&#xFF0C;m.dirty != nil &#xFF0C;&#x5219; entry &#x4E0D;&#x5728; m.dirty &#x4E2D;</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// &#x5426;&#x5219;&#xFF0C;entry &#x4ECD;&#x7136;&#x6709;&#x6548;&#xFF0C;&#x4E14;&#x88AB;&#x8BB0;&#x5F55;&#x5728; m.read.m[key] &#xFF0C;&#x4F46;&#x5982;&#x679C; m.dirty != nil&#xFF0C;&#x5219;&#x5728; m.dirty[key] &#x4E2D;</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// &#x4E00;&#x4E2A; entry &#x53EF;&#x4EE5;&#x88AB;&#x539F;&#x5B50;&#x66FF;&#x6362;&#x4E3A; nil &#x6765;&#x5220;&#x9664;&#xFF1A;&#x5F53; m.dirty &#x4E0B;&#x4E00;&#x6B21;&#x521B;&#x5EFA;&#x65F6;&#xFF0C;&#x5B83;&#x4F1A;&#x81EA;&#x52A8;&#x5C06; nil &#x66FF;&#x6362;&#x4E3A; expunged &#x4E14;</span>
    <span class="hljs-comment">// &#x8BA9; m.dirty[key] &#x6210;&#x4E3A;&#x672A;&#x8BBE;&#x7F6E;&#x7684;&#x72B6;&#x6001;&#x3002;</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// &#x4E0E;&#x4E00;&#x4E2A; entry &#x5173;&#x8054;&#x7684;&#x503C;&#x53EF;&#x4EE5;&#x88AB;&#x539F;&#x5B50;&#x66FF;&#x6362;&#x5F0F;&#x7684;&#x66F4;&#x65B0;&#xFF0C;&#x63D0;&#x4F9B;&#x7684; p != expunged&#x3002;&#x5982;&#x679C; p == expunged&#xFF0C;</span>
    <span class="hljs-comment">// &#x5219;&#x4E0E; entry &#x5173;&#x8054;&#x7684;&#x503C;&#x53EA;&#x80FD;&#x5728; m.dirty[key] = e &#x8BBE;&#x7F6E;&#x540E;&#x88AB;&#x66F4;&#x65B0;&#xFF0C;&#x56E0;&#x6B64;&#x4F1A;&#x4F7F;&#x7528; dirty map &#x6765;&#x67E5;&#x627E; entry&#x3002;</span>
    p atomic.Pointer[any]
}

<span class="hljs-keyword">func</span> newEntry(i any) *entry {
    e := &amp;entry{}
    e.p.Store(&amp;i)
    <span class="hljs-keyword">return</span> e
}

<span class="hljs-keyword">func</span> (m *Map) loadReadOnly() readOnly {
    <span class="hljs-keyword">if</span> p := m.read.Load(); p != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> *p
    }
    <span class="hljs-keyword">return</span> readOnly{}
}
</code></pre>
<h3 id="&#x5199;&#x64CD;&#x4F5C;store">&#x5199;&#x64CD;&#x4F5C;Store</h3>
<p>&#x9996;&#x5148;&#x53D1;&#x751F;&#x7684;&#x662F;&#x66F4;&#x65B0;&#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#x503C;&#x7684;&#x60C5;&#x51B5;&#xFF1A; &#x66F4;&#x65B0;&#x64CD;&#x4F5C;&#x76F4;&#x63A5;&#x66F4;&#x65B0; read map &#x4E2D;&#x7684;&#x503C;&#xFF0C;&#x5982;&#x679C;&#x6210;&#x529F;&#x5219;&#x4E0D;&#x9700;&#x8981;&#x8FDB;&#x884C;&#x4EFB;&#x4F55;&#x64CD;&#x4F5C;&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x6210;&#x529F;&#x624D;&#x7EE7;&#x7EED;&#x5904;&#x7406;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// trySwap swaps a value if the entry has not been expunged.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// If the entry is expunged, trySwap returns false and leaves the entry</span>
<span class="hljs-comment">// unchanged.</span>
<span class="hljs-comment">// &#x5982;&#x679C;&#x6761;&#x76EE;&#x5C1A;&#x672A;&#x5220;&#x9664;&#xFF0C;trySwap &#x4F1A;&#x4EA4;&#x6362;&#x4E00;&#x4E2A;&#x503C;&#x3002;&#x5982;&#x679C;&#x8BE5;&#x6761;&#x76EE;&#x88AB;&#x5220;&#x9664;&#xFF0C;trySwap &#x5C06;&#x8FD4;&#x56DE; false &#x5E76;&#x4FDD;&#x6301;&#x8BE5;&#x6761;&#x76EE;&#x4E0D;&#x53D8;&#x3002;</span>
<span class="hljs-keyword">func</span> (e *entry) trySwap(i *any) (*any, <span class="hljs-keyword">bool</span>) {
    <span class="hljs-keyword">for</span> {
        <span class="hljs-comment">// &#x8BFB;&#x53D6;entry</span>
        p := e.p.Load()
        <span class="hljs-comment">// &#x5982;&#x679C;entry&#x5DF2;&#x7ECF;&#x5220;&#x9664;&#x5219;&#x65E0;&#x6CD5;&#x5B58;&#x50A8;</span>
        <span class="hljs-keyword">if</span> p == expunged {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
        }
        <span class="hljs-comment">// &#x4EA4;&#x6362;p&#x548C;i&#x7684;&#x503C;&#xFF0C;&#x6210;&#x529F;&#x5219;&#x7ACB;&#x5373;&#x8FD4;&#x56DE;</span>
        <span class="hljs-keyword">if</span> e.p.CompareAndSwap(p, i) {
            <span class="hljs-keyword">return</span> p, <span class="hljs-literal">true</span>
        }
    }
}
</code></pre>
<p>Read map&#x53EF;&#x80FD;&#x5DF2;&#x7ECF;&#x66F4;&#x65B0;&#x5E76;&#x4E14;&#x5B58;&#x5728;key&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x672C;&#x8D28;&#x4E0A;&#x8FD8;&#x5206;&#x4E24;&#x79CD;&#x60C5;&#x51B5;&#xFF1A;</p>
<ol>
<li>&#x53EF;&#x80FD;&#x56E0;&#x4E3A;&#x662F;&#x4E00;&#x4E2A;&#x5DF2;&#x7ECF;&#x5220;&#x9664;&#x7684;&#x503C;&#xFF08;&#x4E4B;&#x524D;&#x7684; <code>tryStore</code> &#x5931;&#x8D25;&#xFF09;</li>
<li>&#x53EF;&#x80FD;&#x5148;&#x524D;&#x4EC5;&#x4FDD;&#x5B58;&#x5728; dirty map &#x7136;&#x540E;&#x540C;&#x6B65;&#x5230;&#x4E86; read map&#xFF08;&#x8FD9;&#x662F;&#x53EF;&#x80FD;&#x7684;&#xFF0C;&#x6211;&#x4EEC;&#x540E;&#x9762;&#x8BFB; Load &#x65F6;&#x518D;&#x6765;&#x5206;&#x6790; dirty map &#x662F;&#x5982;&#x4F55;&#x540C;&#x6B65;&#x5230; read map &#x7684;&#xFF09;</li>
</ol>
<p>&#x5BF9;&#x4E8E;&#x7B2C;&#x4E00;&#x79CD;&#x800C;&#x8A00;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x5C06;&#x8FD9;&#x4E2A;&#x5DF2;&#x7ECF;&#x5220;&#x9664;&#x7684;&#x503C;&#x6807;&#x8BB0;&#x4E3A;&#x6CA1;&#x6709;&#x5220;&#x9664;&#xFF0C;&#x7136;&#x540E;&#x5C06;&#x8FD9;&#x4E2A;&#x503C;&#x540C;&#x6B65;&#x56DE; dirty map&#xFF08;&#x5220;&#x9664;&#x64CD;&#x4F5C;&#x53EA;&#x5220;&#x9664; dirty map&#xFF0C;&#x4E4B;&#x540E;&#x518D;&#x8BF4;&#xFF09; &#x5BF9;&#x4E8E;&#x7B2C;&#x4E8C;&#x79CD;&#x72B6;&#x6001;&#xFF0C;&#x6211;&#x4EEC;&#x76F4;&#x63A5;&#x66F4;&#x65B0; read map&#xFF0C;&#x4E0D;&#x9700;&#x8981;&#x6253;&#x6270; dirty map&#x3002;</p>
<p>&#x770B;&#x4E00;&#x4E0B; dirty map &#x6709;&#x6CA1;&#x6709;&#xFF0C;&#x7ED3;&#x679C;&#x53D1;&#x73B0;&#x662F;&#x6709;&#x7684;&#xFF0C; &#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x76F4;&#x63A5;&#x4FEE;&#x6539; dirty map&#xFF0C;&#x4E0D;&#x53BB;&#x6253;&#x6270; read map&#x3002;</p>
<p>read map &#x548C; dirty map &#x90FD;&#x6CA1;&#x6709;&#xFF0C;&#x53EA;&#x80FD;&#x662F;&#x5B58;&#x50A8;&#x4E00;&#x4E2A;&#x65B0;&#x503C;&#x4E86;&#x3002;&#x5F53;&#x7136;&#xFF0C;&#x5728;&#x66F4;&#x65B0;&#x4E4B;&#x524D; &#x6211;&#x4EEC;&#x8FD8;&#x8981;&#x518D;&#x68C0;&#x67E5;&#x4E00;&#x4E0B; read map &#x548C; dirty map &#x7684;&#x72B6;&#x6001;&#x3002; &#x5982;&#x679C; read map &#x548C; dirty map &#x4E2D;&#x5B58;&#x50A8;&#x7684;&#x5185;&#x5BB9;&#x662F;&#x76F8;&#x540C;&#x7684;&#xFF0C;&#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x8FD9;&#x6B21;&#x5B58;&#x50A8;&#x65B0;&#x7684;&#x6570;&#x636E; &#x53EA;&#x4F1A;&#x5B58;&#x50A8;&#x5728; dirty map &#x4E2D;&#xFF0C;&#x56E0;&#x6B64;&#x4F1A;&#x9020;&#x6210; read map &#x548C; dirty map &#x7684;&#x4E0D;&#x4E00;&#x81F4;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-keyword">func</span> (m *Map) dirtyLocked() {
    <span class="hljs-keyword">if</span> m.dirty != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span>
    }

    read := m.loadReadOnly()
    m.dirty = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[any]*entry, <span class="hljs-built_in">len</span>(read.m))
    <span class="hljs-keyword">for</span> k, e := <span class="hljs-keyword">range</span> read.m {
        <span class="hljs-comment">// &#x68C0;&#x67E5;&#x5F53;&#x524D;&#x6761;&#x76EE;&#x662F;&#x5426;&#x8FC7;&#x671F;&#x6216;&#x5931;&#x6548;</span>
        <span class="hljs-keyword">if</span> !e.tryExpungeLocked() {
            m.dirty[k] = e
        }
    }
}

<span class="hljs-keyword">func</span> (e *entry) tryExpungeLocked() (isExpunged <span class="hljs-keyword">bool</span>) {
    <span class="hljs-comment">// &#x83B7;&#x53D6;entry&#x7684;&#x503C;</span>
    p := e.p.Load()
    <span class="hljs-comment">// &#x5982;&#x679C;entry&#x7684;&#x503C;&#x4E3A;nil</span>
    <span class="hljs-keyword">for</span> p == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// &#x68C0;&#x67E5;&#x662F;&#x5426;&#x88AB;&#x6807;&#x8BB0;&#x4E3A;&#x5DF2;&#x7ECF;&#x5220;&#x9664;</span>
        <span class="hljs-keyword">if</span> e.p.CompareAndSwap(<span class="hljs-literal">nil</span>, expunged) {
            <span class="hljs-comment">// &#x6210;&#x529F;&#x4EA4;&#x6362;&#xFF0C;&#x8BF4;&#x660E;&#x5DF2;&#x7ECF;&#x88AB;&#x5220;&#x9664;</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
        <span class="hljs-comment">// &#x5220;&#x9664;&#x64CD;&#x4F5C;&#x5931;&#x8D25;&#xFF0C;&#x8BF4;&#x660E;expunged&#x7B49;&#x4E8E;nil&#xFF0C;&#x5219;&#x91CD;&#x65B0;&#x8BFB;&#x53D6;</span>
        p = e.p.Load()
    }
    <span class="hljs-keyword">return</span> p == expunged
}
</code></pre>
<pre><code class="lang-go"><span class="hljs-comment">// Store sets the value for a key.</span>
<span class="hljs-keyword">func</span> (m *Map) Store(key, value any) {
    _, _ = m.Swap(key, value)
}

<span class="hljs-comment">// Swap swaps the value for a key and returns the previous value if any.</span>
<span class="hljs-comment">// The loaded result reports whether the key was present.</span>
<span class="hljs-keyword">func</span> (m *Map) Swap(key, value any) (previous any, loaded <span class="hljs-keyword">bool</span>) {
    read := m.loadReadOnly()
    <span class="hljs-keyword">if</span> e, ok := read.m[key]; ok {
        <span class="hljs-keyword">if</span> v, ok := e.trySwap(&amp;value); ok {
            <span class="hljs-keyword">if</span> v == <span class="hljs-literal">nil</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
            }
            <span class="hljs-keyword">return</span> *v, <span class="hljs-literal">true</span>
        }
    }

    m.mu.Lock()
    <span class="hljs-comment">// read map&#x53EF;&#x80FD;&#x5DF2;&#x7ECF;&#x66F4;&#x65B0;&#xFF0C;&#x6240;&#x4EE5;&#x91CD;&#x65B0;&#x52A0;&#x8F7D;&#x4E00;&#x4E0B;</span>
    read = m.loadReadOnly()
    <span class="hljs-keyword">if</span> e, ok := read.m[key]; ok {
        <span class="hljs-comment">// &#x4FEE;&#x6539;&#x4E00;&#x4E2A;&#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#x7684;&#x503C;</span>
        <span class="hljs-keyword">if</span> e.unexpungeLocked() {
            <span class="hljs-comment">// The entry was previously expunged, which implies that there is a</span>
            <span class="hljs-comment">// non-nil dirty map and this entry is not in it.</span>
            <span class="hljs-comment">// // &#x8BF4;&#x660E; entry &#x5148;&#x524D;&#x662F;&#x88AB;&#x6807;&#x8BB0;&#x4E3A;&#x5220;&#x9664;&#x4E86;&#x7684;&#xFF0C;&#x73B0;&#x5728;&#x6211;&#x4EEC;&#x53C8;&#x8981;&#x5B58;&#x50A8;&#x5B83;&#xFF0C;&#x53EA;&#x80FD;&#x5411; dirty map &#x8FDB;&#x884C;&#x66F4;&#x65B0;&#x4E86;</span>
            m.dirty[key] = e
        }
        <span class="hljs-comment">// &#x65E0;&#x8BBA;&#x5148;&#x524D;&#x5220;&#x9664;&#x4E0E;&#x5426;&#xFF0C;&#x5747;&#x8981;&#x66F4;&#x65B0;read map</span>
        <span class="hljs-keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="hljs-literal">nil</span> {
            loaded = <span class="hljs-literal">true</span>
            previous = *v
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> e, ok := m.dirty[key]; ok {
        <span class="hljs-comment">// &#x66F4;&#x65B0;dirty map&#x7684;&#x503C;</span>
        <span class="hljs-keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="hljs-literal">nil</span> {
            loaded = <span class="hljs-literal">true</span>
            previous = *v
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// &#x5982;&#x679C;dirty map&#x91CC;&#x6CA1;&#x6709;read map&#x6CA1;&#x6709;&#x7684;&#x503C;</span>
        <span class="hljs-keyword">if</span> !read.amended {
            <span class="hljs-comment">// We&apos;re adding the first new key to the dirty map.</span>
            <span class="hljs-comment">// Make sure it is allocated and mark the read-only map as incomplete.</span>
            <span class="hljs-comment">// &#x9996;&#x6B21;&#x6DFB;&#x52A0;&#x4E00;&#x4E2A;&#x65B0;&#x503C;&#x5230;dirty map&#x4E2D;</span>
            <span class="hljs-comment">// &#x786E;&#x4FDD;&#x5DF2;&#x88AB;&#x5206;&#x914D;&#x5E76;&#x6807;&#x8BB0;&#x4E3A;read map&#x662F;&#x4E0D;&#x5B8C;&#x5907;&#x7684;&#xFF0C;&#x5373;dirty map&#x6709;&#xFF0C;read map&#x6CA1;&#x6709;</span>
            m.dirtyLocked()
            <span class="hljs-comment">// &#x66F4;&#x65B0;amended&#xFF0C; &#x6807;&#x8BB0; read map &#x4E2D;&#x7F3A;&#x5C11;&#x4E86;&#x503C;&#xFF08;&#x6807;&#x8BB0;&#x4E3A;&#x4E24;&#x8005;&#x4E0D;&#x540C;&#xFF09;</span>
            m.read.Store(&amp;readOnly{m: read.m, amended: <span class="hljs-literal">true</span>})
        }
        <span class="hljs-comment">// &#x4E0D;&#x7BA1; read map &#x548C; dirty map &#x76F8;&#x540C;&#x4E0E;&#x5426;&#xFF0C;&#x6B63;&#x5F0F;&#x4FDD;&#x5B58;&#x65B0;&#x7684;&#x503C;</span>
        m.dirty[key] = newEntry(value)
    }
    m.mu.Unlock()
    <span class="hljs-keyword">return</span> previous, loaded
}
</code></pre>
<h3 id="&#x8BFB;&#x64CD;&#x4F5C;load">&#x8BFB;&#x64CD;&#x4F5C;Load</h3>
<p>Load &#x7684;&#x64CD;&#x4F5C;&#x5C31;&#x662F;&#x4ECE; dirty map &#x6216;&#x8005; read map &#x4E2D;&#x67E5;&#x627E;&#x6240;&#x5B58;&#x50A8;&#x7684;&#x503C;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Load returns the value stored in the map for a key, or nil if no</span>
<span class="hljs-comment">// value is present.</span>
<span class="hljs-comment">// The ok result indicates whether value was found in the map.</span>
<span class="hljs-comment">// Load &#x8FD4;&#x56DE;&#x4E86;&#x5B58;&#x50A8;&#x5728; map &#x4E2D;&#x5BF9;&#x5E94;&#x4E8E; key &#x7684;&#x503C; value&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x5B58;&#x5728;&#x5219;&#x8FD4;&#x56DE; nil</span>
<span class="hljs-comment">// ok &#x8868;&#x793A;&#x4E86;&#x503C;&#x80FD;&#x5426;&#x5728; map &#x4E2D;&#x627E;&#x5230;</span>
<span class="hljs-keyword">func</span> (m *Map) Load(key any) (value any, ok <span class="hljs-keyword">bool</span>) {
    <span class="hljs-comment">// &#x83B7;&#x53D6;read map</span>
    read := m.loadReadOnly()
    <span class="hljs-comment">// &#x8BFB;&#x53D6;&#x5BF9;&#x5E94;&#x7684;&#x503C;</span>
    e, ok := read.m[key]
    <span class="hljs-comment">// &#x5982;&#x679C;&#x5728; read map &#x4E2D;&#x627E;&#x4E0D;&#x5230;&#xFF0C;&#x4E14; dirty map &#x5305;&#x542B; read map &#x4E2D;&#x4E0D;&#x5B58;&#x5728;&#x7684; key&#xFF0C;&#x5219;&#x8FDB;&#x4E00;&#x6B65;&#x67E5;&#x627E;</span>
    <span class="hljs-keyword">if</span> !ok &amp;&amp; read.amended {
        m.mu.Lock()
        <span class="hljs-comment">// Avoid reporting a spurious miss if m.dirty got promoted while we were</span>
        <span class="hljs-comment">// blocked on m.mu. (If further loads of the same key will not miss, it&apos;s</span>
        <span class="hljs-comment">// not worth copying the dirty map for this key.)</span>
        <span class="hljs-comment">// &#x518D;&#x4E00;&#x6B21;&#x83B7;&#x53D6;&#xFF0C;&#x53CC;&#x91CD;&#x68C0;&#x67E5;</span>
        read = m.loadReadOnly()
        e, ok = read.m[key]
        <span class="hljs-comment">// &#x5982;&#x679C;&#x8FD9;&#x65F6; read map &#x786E;&#x5B9E;&#x8BFB;&#x4E0D;&#x5230;&#xFF0C;&#x4E14; dirty map &#x4E0E; read map &#x4E0D;&#x4E00;&#x81F4;</span>
        <span class="hljs-keyword">if</span> !ok &amp;&amp; read.amended {
            <span class="hljs-comment">// &#x4ECE;dirty map&#x4E2D;&#x8BFB;&#x53D6;</span>
            e, ok = m.dirty[key]
            <span class="hljs-comment">// Regardless of whether the entry was present, record a miss: this key</span>
            <span class="hljs-comment">// will take the slow path until the dirty map is promoted to the read</span>
            <span class="hljs-comment">// map.</span>
            <span class="hljs-comment">// &#x65E0;&#x8BBA; entry &#x662F;&#x5426;&#x627E;&#x5230;&#xFF0C;&#x8BB0;&#x5F55;&#x4E00;&#x6B21; miss&#xFF1A;&#x8BE5; key &#x4F1A;&#x91C7;&#x53D6; slow path &#x8FDB;&#x884C;&#x8BFB;&#x53D6;&#xFF0C;&#x76F4;&#x5230;</span>
            <span class="hljs-comment">// dirty map &#x88AB;&#x63D0;&#x5347;&#x4E3A; read map&#x3002;</span>
            m.missLocked()
        }
        m.mu.Unlock()
    }
    <span class="hljs-comment">// &#x5982;&#x679C; read map &#x6216;&#x8005; dirty map &#x4E2D;&#x627E;&#x4E0D;&#x5230; key&#xFF0C;&#x5219;&#x786E;&#x5B9E;&#x6CA1;&#x627E;&#x5230;&#xFF0C;&#x8FD4;&#x56DE; nil &#x548C; false</span>
    <span class="hljs-keyword">if</span> !ok {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
    }
    <span class="hljs-comment">// &#x627E;&#x5230;&#x4E86;&#xFF0C;&#x8FD4;&#x56DE;&#x8BFB;&#x5230;&#x7684;&#x503C;</span>
    <span class="hljs-keyword">return</span> e.load()
}

<span class="hljs-keyword">func</span> (e *entry) load() (value any, ok <span class="hljs-keyword">bool</span>) {
    <span class="hljs-comment">// &#x8BFB;entry&#x7684;&#x503C;</span>
    p := e.p.Load()
    <span class="hljs-comment">// &#x5224;&#x65AD;&#x662F;&#x5426;&#x88AB;&#x5220;&#x9664;</span>
    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> || p == expunged {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
    }
    <span class="hljs-comment">// &#x8BFB;&#x53D6;&#x503C;</span>
    <span class="hljs-keyword">return</span> *p, <span class="hljs-literal">true</span>
}
</code></pre>
<p>&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF1A;</p>
<ol>
<li>&#x5982;&#x679C; read map &#x4E2D;&#x5DF2;&#x7ECF;&#x627E;&#x5230;&#x4E86;&#x8BE5;&#x503C;&#xFF0C;&#x5219;&#x4E0D;&#x9700;&#x8981;&#x53BB;&#x8BBF;&#x95EE; dirty map&#xFF08;&#x6162;&#xFF09;&#x3002;</li>
<li>&#x4F46;&#x5982;&#x679C;&#x6CA1;&#x627E;&#x5230;&#xFF0C;&#x4E14; dirty map &#x4E0E; read map &#x6CA1;&#x6709;&#x5DEE;&#x5F02;&#xFF0C;&#x5219;&#x4E5F;&#x4E0D;&#x9700;&#x8981;&#x53BB;&#x8BBF;&#x95EE; dirty map&#x3002;</li>
<li>&#x5982;&#x679C; dirty map &#x548C; read map &#x6709;&#x5DEE;&#x5F02;&#xFF0C;&#x5219;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x9501;&#x4F4F;&#x6574;&#x4E2A; Map&#xFF0C;&#x7136;&#x540E;&#x518D;&#x8BFB;&#x53D6;&#x4E00;&#x6B21; read map &#x6765;&#x9632;&#x6B62;&#x5E76;&#x53D1;&#x5BFC;&#x81F4;&#x7684;&#x4E0A;&#x4E00;&#x6B21;&#x8BFB;&#x53D6;&#x5931;&#x8BEF;</li>
<li>&#x5982;&#x679C;&#x9501;&#x4F4F;&#x540E;&#xFF0C;&#x786E;&#x5B9E; read map &#x8BFB;&#x53D6;&#x4E0D;&#x5230;&#x4E14; dirty map &#x548C; read map &#x4E00;&#x81F4;&#xFF0C;&#x5219;&#x4E0D;&#x9700;&#x8981;&#x53BB;&#x8BFB; dirty map &#x4E86;&#xFF0C;&#x76F4;&#x63A5;&#x89E3;&#x9501;&#x8FD4;&#x56DE;&#x3002;</li>
<li>&#x5982;&#x679C;&#x9501;&#x4F4F;&#x540E;&#xFF0C;read map &#x8BFB;&#x4E0D;&#x5230;&#xFF0C;&#x4E14; dirty map &#x4E0E; read map &#x4E0D;&#x4E00;&#x81F4;&#xFF0C;&#x5219;&#x8BE5; key &#x53EF;&#x80FD;&#x5728; dirty map &#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x4ECE; dirty map &#x4E2D;&#x8BFB;&#x53D6;&#xFF0C;&#x5E76;&#x8BB0;&#x5F55;&#x4E00;&#x6B21; miss&#xFF08;&#x5728; read map &#x4E2D; miss&#xFF09;&#x3002;</li>
</ol>
<p>&#x8BB0;&#x5F55;miss&#x64CD;&#x4F5C;</p>
<p>miss &#x5982;&#x679C;&#x5927;&#x4E8E;&#x4E86; dirty &#x6240;&#x5B58;&#x50A8;&#x7684; key &#x6570;&#x65F6;&#xFF0C;&#x4F1A;&#x5C06; dirty map &#x540C;&#x6B65;&#x5230; read map&#xFF0C;&#x5E76;&#x5C06;&#x81EA;&#x8EAB;&#x6E05;&#x7A7A;&#xFF0C;miss &#x8BA1;&#x6570;&#x5F52;&#x96F6;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// &#x6B64;&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x65F6;&#xFF0C;&#x6574;&#x4E2A; map &#x662F;&#x9501;&#x4F4F;&#x7684;</span>
<span class="hljs-keyword">func</span> (m *Map) missLocked() {
    <span class="hljs-comment">// &#x589E;&#x52A0;miss&#x6570;&#x91CF;</span>
    m.misses++
    <span class="hljs-comment">// &#x5982;&#x679C; miss &#x7684;&#x6B21;&#x6570;&#x5C0F;&#x4E8E; dirty map &#x7684; key &#x6570;</span>
    <span class="hljs-comment">// &#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;</span>
    <span class="hljs-keyword">if</span> m.misses &lt; <span class="hljs-built_in">len</span>(m.dirty) {
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-comment">// &#x5426;&#x5219;&#x5C06; dirty map &#x540C;&#x6B65;&#x5230; read map &#x53BB;</span>
    m.read.Store(&amp;readOnly{m: m.dirty})
    <span class="hljs-comment">// &#x6E05;&#x7A7A; dirty map</span>
    m.dirty = <span class="hljs-literal">nil</span>
    <span class="hljs-comment">// miss &#x8BA1;&#x6570;&#x5F52;&#x96F6;</span>
    m.misses = <span class="hljs-number">0</span>
}
</code></pre>
<h3 id="&#x5220;&#x9664;&#x64CD;&#x4F5C;delete">&#x5220;&#x9664;&#x64CD;&#x4F5C;Delete</h3>
<p>&#x5220;&#x9664;&#x64CD;&#x4F5C;&#x76F8;&#x5BF9;&#x7B80;&#x5355;&#xFF0C;&#x5F53;&#x9700;&#x8981;&#x5220;&#x9664;&#x4E00;&#x4E2A;&#x503C;&#x65F6;&#xFF0C;&#x79FB;&#x9664; read map &#x4E2D;&#x7684;&#x503C;&#xFF0C;&#x672C;&#x8D28;&#x4E0A;&#x4EC5;&#x4EC5;&#x53EA;&#x662F;&#x89E3;&#x9664;&#x5BF9;&#x53D8;&#x91CF;&#x7684;&#x5F15;&#x7528;&#x3002; &#x5B9E;&#x9645;&#x7684;&#x56DE;&#x6536;&#x662F;&#x7531; GC &#x8FDB;&#x884C;&#x5904;&#x7406;&#x3002; &#x5982;&#x679C; read map &#x4E2D;&#x5E76;&#x672A;&#x627E;&#x5230;&#x8981;&#x5220;&#x9664;&#x7684;&#x503C;&#xFF0C;&#x624D;&#x4F1A;&#x53BB;&#x5C1D;&#x8BD5;&#x5220;&#x9664; dirty map &#x4E2D;&#x7684;&#x503C;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Delete deletes the value for a key.</span>
<span class="hljs-comment">// Delete &#x5220;&#x9664; key &#x5BF9;&#x5E94;&#x7684; value</span>
<span class="hljs-keyword">func</span> (m *Map) Delete(key any) {
    m.LoadAndDelete(key)
}

<span class="hljs-comment">// LoadAndDelete deletes the value for a key, returning the previous value if any.</span>
<span class="hljs-comment">// The loaded result reports whether the key was present.</span>
<span class="hljs-keyword">func</span> (m *Map) LoadAndDelete(key any) (value any, loaded <span class="hljs-keyword">bool</span>) {
    <span class="hljs-comment">// &#x83B7;&#x5F97; read map</span>
    read := m.loadReadOnly()
    <span class="hljs-comment">// &#x4ECE; read map &#x4E2D;&#x8BFB;&#x53D6;&#x9700;&#x8981;&#x5220;&#x9664;&#x7684; key</span>
    e, ok := read.m[key]
    <span class="hljs-comment">// &#x5982;&#x679C; read map &#x4E2D;&#x6CA1;&#x627E;&#x5230;&#xFF0C;&#x4E14; read map &#x4E0E; dirty map &#x4E0D;&#x4E00;&#x81F4;</span>
    <span class="hljs-comment">// &#x8BF4;&#x660E;&#x8981;&#x5220;&#x9664;&#x7684;&#x503C;&#x5728; dirty map &#x4E2D;</span>
    <span class="hljs-keyword">if</span> !ok &amp;&amp; read.amended {
        m.mu.Lock()
        <span class="hljs-comment">// &#x518D;&#x6B21;&#x8BFB; read map</span>
        read = m.loadReadOnly()
        <span class="hljs-comment">// &#x4ECE; read map &#x4E2D;&#x53D6;&#x503C;</span>
        e, ok = read.m[key]
        <span class="hljs-comment">// &#x6CA1;&#x53D6;&#x5230;&#xFF0C;read map &#x548C; dirty map &#x4E0D;&#x4E00;&#x81F4;</span>
        <span class="hljs-keyword">if</span> !ok &amp;&amp; read.amended {
            e, ok = m.dirty[key]
            <span class="hljs-comment">// &#x5220;&#x9664; dierty map &#x7684;&#x503C;</span>
            <span class="hljs-built_in">delete</span>(m.dirty, key)
            <span class="hljs-comment">// Regardless of whether the entry was present, record a miss: this key</span>
            <span class="hljs-comment">// will take the slow path until the dirty map is promoted to the read</span>
            <span class="hljs-comment">// map.</span>
            <span class="hljs-comment">// &#x8BB0;&#x5F55;&#x4E00;&#x6B21;miss</span>
            m.missLocked()
        }
        m.mu.Unlock()
    }
    <span class="hljs-keyword">if</span> ok {
        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">delete</span>()
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
}

<span class="hljs-keyword">func</span> (e *entry) <span class="hljs-built_in">delete</span>() (value any, ok <span class="hljs-keyword">bool</span>) {
    <span class="hljs-keyword">for</span> {
        <span class="hljs-comment">// &#x8BFB;&#x53D6; entry &#x7684;&#x503C;</span>
        p := e.p.Load()
        <span class="hljs-comment">// &#x5982;&#x679C; p &#x7B49;&#x4E8E; nil&#xFF0C;&#x6216;&#x8005; p &#x5DF2;&#x7ECF;&#x6807;&#x8BB0;&#x5220;&#x9664;</span>
        <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> || p == expunged {
            <span class="hljs-comment">// &#x5219;&#x4E0D;&#x9700;&#x8981;&#x5220;&#x9664;</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
        }
        <span class="hljs-comment">// &#x5426;&#x5219;&#xFF0C;&#x5C06; p &#x7684;&#x503C;&#x4E0E; nil &#x8FDB;&#x884C;&#x539F;&#x5B50;&#x6362;</span>
        <span class="hljs-keyword">if</span> e.p.CompareAndSwap(p, <span class="hljs-literal">nil</span>) {
            <span class="hljs-comment">// &#x5220;&#x9664;&#x6210;&#x529F;&#xFF08;&#x672C;&#x8D28;&#x53EA;&#x662F;&#x89E3;&#x9664;&#x5F15;&#x7528;&#xFF0C;&#x5B9E;&#x9645;&#x4E0A;&#x662F;&#x7559;&#x7ED9; GC &#x6E05;&#x7406;&#xFF09;</span>
            <span class="hljs-keyword">return</span> *p, <span class="hljs-literal">true</span>
        }
    }
}
</code></pre>
<h3 id="&#x8FED;&#x4EE3;&#x64CD;&#x4F5C;range">&#x8FED;&#x4EE3;&#x64CD;&#x4F5C;Range</h3>
<p>&#x65E2;&#x7136;&#x8981; Range &#x6574;&#x4E2A; map&#xFF0C;&#x5219;&#x9700;&#x8981;&#x8003;&#x8651; dirty map &#x4E0E; read map &#x4E0D;&#x4E00;&#x81F4;&#x7684;&#x95EE;&#x9898;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x4E00;&#x81F4;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x5C06; dirty map &#x540C;&#x6B65;&#x5230; read map &#x4E2D;&#x3002;</p>
<pre><code class="lang-go"><span class="hljs-comment">// Range calls f sequentially for each key and value present in the map.</span>
<span class="hljs-comment">// If f returns false, range stops the iteration.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Range does not necessarily correspond to any consistent snapshot of the Map&apos;s</span>
<span class="hljs-comment">// contents: no key will be visited more than once, but if the value for any key</span>
<span class="hljs-comment">// is stored or deleted concurrently (including by f), Range may reflect any</span>
<span class="hljs-comment">// mapping for that key from any point during the Range call. Range does not</span>
<span class="hljs-comment">// block other methods on the receiver; even f itself may call any method on m.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Range may be O(N) with the number of elements in the map even if f returns</span>
<span class="hljs-comment">// false after a constant number of calls.</span>
<span class="hljs-comment">// Range &#x4E3A;&#x6BCF;&#x4E2A; key &#x987A;&#x5E8F;&#x7684;&#x8C03;&#x7528; f&#x3002;&#x5982;&#x679C; f &#x8FD4;&#x56DE; false&#xFF0C;&#x5219; range &#x4F1A;&#x505C;&#x6B62;&#x8FED;&#x4EE3;&#x3002;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Range &#x7684;&#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6;&#x53EF;&#x80FD;&#x4F1A;&#x662F; O(N) &#x5373;&#x4FBF;&#x662F; f &#x8FD4;&#x56DE; false&#x3002;</span>
<span class="hljs-keyword">func</span> (m *Map) Range(f <span class="hljs-keyword">func</span>(key, value any) <span class="hljs-keyword">bool</span>) {
    <span class="hljs-comment">// We need to be able to iterate over all of the keys that were already</span>
    <span class="hljs-comment">// present at the start of the call to Range.</span>
    <span class="hljs-comment">// If read.amended is false, then read.m satisfies that property without</span>
    <span class="hljs-comment">// requiring us to hold m.mu for a long time.</span>
    <span class="hljs-comment">// &#x8BFB;&#x53D6; read map</span>
    read := m.loadReadOnly()
    <span class="hljs-comment">// &#x5982;&#x679C; read map &#x548C; dirty map &#x4E0D;&#x4E00;&#x81F4;&#xFF0C;&#x5219;&#x9700;&#x8981;&#x8FDB;&#x4E00;&#x6B65;&#x64CD;&#x4F5C;</span>
    <span class="hljs-keyword">if</span> read.amended {
        <span class="hljs-comment">// m.dirty contains keys not in read.m. Fortunately, Range is already O(N)</span>
        <span class="hljs-comment">// (assuming the caller does not break out early), so a call to Range</span>
        <span class="hljs-comment">// amortizes an entire copy of the map: we can promote the dirty copy</span>
        <span class="hljs-comment">// immediately!</span>
        m.mu.Lock()
        <span class="hljs-comment">// &#x518D;&#x8BFB;&#x4E00;&#x6B21;&#xFF0C;&#x5982;&#x679C;&#x8FD8;&#x662F;&#x4E0D;&#x4E00;&#x81F4;&#xFF0C;&#x5219;&#x5C06; dirty map &#x63D0;&#x5347;&#x4E3A; read map</span>
        read = m.loadReadOnly()
        <span class="hljs-keyword">if</span> read.amended {
            read = readOnly{m: m.dirty}
            m.read.Store(&amp;read)
            m.dirty = <span class="hljs-literal">nil</span>
            m.misses = <span class="hljs-number">0</span>
        }
        m.mu.Unlock()
    }

    <span class="hljs-comment">// &#x5728; read &#x53D8;&#x91CF;&#x4E2D;&#x8BFB;&#xFF08;&#x53EF;&#x80FD;&#x662F; read map &#xFF0C;&#x4E5F;&#x53EF;&#x80FD;&#x662F; dirty map &#x540C;&#x6B65;&#x8FC7;&#x6765;&#x7684; map&#xFF09;</span>
    <span class="hljs-keyword">for</span> k, e := <span class="hljs-keyword">range</span> read.m {
        <span class="hljs-comment">// &#x8BFB; readOnly&#xFF0C;load &#x4F1A;&#x68C0;&#x67E5;&#x8BE5;&#x503C;&#x662F;&#x5426;&#x88AB;&#x6807;&#x8BB0;&#x4E3A;&#x5220;&#x9664;</span>
        v, ok := e.load()
        <span class="hljs-comment">// &#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x5220;&#x9664;&#xFF0C;&#x5219;&#x8DF3;&#x8FC7;</span>
        <span class="hljs-keyword">if</span> !ok {
            <span class="hljs-keyword">continue</span>
        }
        <span class="hljs-comment">// &#x5982;&#x679C; f &#x8FD4;&#x56DE; false&#xFF0C;&#x5219;&#x505C;&#x6B62;&#x8FED;&#x4EE3;</span>
        <span class="hljs-keyword">if</span> !f(k, v) {
            <span class="hljs-keyword">break</span>
        }
    }
}
</code></pre>
<h3 id="&#x8BFB;&#x5199;&#x64CD;&#x4F5C;loadorstore">&#x8BFB;&#x5199;&#x64CD;&#x4F5C;LoadOrStore</h3>
<p><code>LoadOrStore</code> &#x65B9;&#x6CD5;&#x65E0;&#x975E;&#x662F;&#x4E24;&#x5219;&#x7684;&#x7ED3;&#x5408;</p>
<pre><code class="lang-go"><span class="hljs-comment">// LoadOrStore returns the existing value for the key if present.</span>
<span class="hljs-comment">// Otherwise, it stores and returns the given value.</span>
<span class="hljs-comment">// The loaded result is true if the value was loaded, false if stored.</span>
<span class="hljs-comment">// LoadOrStore &#x5728; key &#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#x65F6;&#xFF0C;&#x8FD4;&#x56DE;&#x5B58;&#x5728;&#x7684;&#x503C;&#xFF0C;&#x5426;&#x5219;&#x5B58;&#x50A8;&#x5F53;&#x524D;&#x7ED9;&#x5B9A;&#x7684;&#x503C;</span>
<span class="hljs-comment">// loaded &#x4E3A; true &#x8868;&#x793A; actual &#x8BFB;&#x53D6;&#x6210;&#x529F;&#xFF0C;&#x5426;&#x5219;&#x4E3A; false &#x8868;&#x793A; value &#x5B58;&#x50A8;&#x6210;&#x529F;</span>
<span class="hljs-keyword">func</span> (m *Map) LoadOrStore(key, value any) (actual any, loaded <span class="hljs-keyword">bool</span>) {
    <span class="hljs-comment">// Avoid locking if it&apos;s a clean hit.</span>
    read := m.loadReadOnly()
    <span class="hljs-comment">// &#x5982;&#x679C; read map &#x4E2D;&#x5DF2;&#x7ECF;&#x8BFB;&#x5230;</span>
    <span class="hljs-keyword">if</span> e, ok := read.m[key]; ok {
        <span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x5B58;&#x50A8;&#xFF08;&#x53EF;&#x80FD; key &#x662F;&#x4E00;&#x4E2A;&#x5DF2;&#x5220;&#x9664;&#x7684; key&#xFF09;</span>
        actual, loaded, ok := e.tryLoadOrStore(value)
        <span class="hljs-comment">// &#x5982;&#x679C;&#x5B58;&#x50A8;&#x6210;&#x529F;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;</span>
        <span class="hljs-keyword">if</span> ok {
            <span class="hljs-keyword">return</span> actual, loaded
        }
    }

    <span class="hljs-comment">// &#x5426;&#x5219;&#xFF0C;&#x6D89;&#x53CA; dirty map&#xFF0C;&#x52A0;&#x9501;</span>
    m.mu.Lock()
    <span class="hljs-comment">// &#x518D;&#x8BFB;&#x4E00;&#x6B21; read map</span>
    read = m.loadReadOnly()
    <span class="hljs-keyword">if</span> e, ok := read.m[key]; ok {
        <span class="hljs-comment">// &#x5982;&#x679C; read map &#x4E2D;&#x5DF2;&#x7ECF;&#x8BFB;&#x5230;&#xFF0C;&#x5219;&#x770B;&#x8BE5;&#x503C;&#x662F;&#x5426;&#x88AB;&#x5220;&#x9664;</span>
        <span class="hljs-keyword">if</span> e.unexpungeLocked() {
            <span class="hljs-comment">// &#x6CA1;&#x6709;&#x88AB;&#x5220;&#x9664;&#xFF0C;&#x5219;&#x901A;&#x8FC7; dirty map &#x5B58;</span>
            m.dirty[key] = e
        }
        actual, loaded, _ = e.tryLoadOrStore(value)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> e, ok := m.dirty[key]; ok {
        <span class="hljs-comment">// &#x5982;&#x679C; read map &#x6CA1;&#x627E;&#x5230;, dirty map &#x627E;&#x5230;&#x4E86;</span>
        <span class="hljs-comment">// &#x5C1D;&#x8BD5; laod or store&#xFF0C;&#x5E76;&#x8BB0;&#x5F55; miss</span>
        actual, loaded, _ = e.tryLoadOrStore(value)
        m.missLocked()
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// &#x5426;&#x5219;&#x5C31;&#x662F;&#x5B58;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x503C;</span>
        <span class="hljs-comment">// &#x5982;&#x679C; read map &#x548C; dirty map &#x76F8;&#x540C;&#xFF0C;&#x5219;&#x5F00;&#x59CB;&#x6807;&#x8BB0;&#x4E0D;&#x540C;</span>
        <span class="hljs-keyword">if</span> !read.amended {
            <span class="hljs-comment">// We&apos;re adding the first new key to the dirty map.</span>
            <span class="hljs-comment">// Make sure it is allocated and mark the read-only map as incomplete.</span>
            m.dirtyLocked()
            m.read.Store(&amp;readOnly{m: read.m, amended: <span class="hljs-literal">true</span>})
        }
        <span class="hljs-comment">// &#x5B58;&#x5230; dirty map &#x4E2D;&#x53BB;</span>
        m.dirty[key] = newEntry(value)
        actual, loaded = value, <span class="hljs-literal">false</span>
    }
    m.mu.Unlock()

    <span class="hljs-keyword">return</span> actual, loaded
}
</code></pre>
<p>sync.Map &#x4E2D; read map &#x548C; dirty map &#x7684;&#x540C;&#x6B65;&#x8FC7;&#x7A0B;&#xFF1A;</p>
<ol>
<li>&#x5F53; Store &#x4E00;&#x4E2A;&#x65B0;&#x503C;&#x4F1A;&#x53D1;&#x751F;&#xFF1A;read map &#x2013;&gt; dirty map</li>
<li>dirty map &#x2013;&gt; read map&#xFF1A;&#x5F53; read map &#x8FDB;&#x884C; Load &#x5931;&#x8D25; len(dirty map) &#x6B21;&#x4E4B;&#x540E;&#x53D1;&#x751F;</li>
</ol>
<p>&#x56E0;&#x6B64;&#xFF0C;&#x65E0;&#x8BBA;&#x662F;&#x5B58;&#x50A8;&#x8FD8;&#x662F;&#x8BFB;&#x53D6;&#xFF0C;read map &#x4E2D;&#x7684;&#x503C;&#x4E00;&#x5B9A;&#x80FD;&#x5728; dirty map &#x4E2D;&#x627E;&#x5230;&#x3002;&#x65E0;&#x8BBA;&#x4E24;&#x8005;&#x5982;&#x4F55;&#x540C;&#x6B65;&#xFF0C;sync.Map &#x901A;&#x8FC7; entry &#x6307;&#x9488;&#x64CD;&#x4F5C;&#xFF0C; &#x4FDD;&#x8BC1;&#x6570;&#x636E;&#x6C38;&#x8FDC;&#x53EA;&#x6709;&#x4E00;&#x4EFD;&#xFF0C;&#x4E00;&#x65E6; read map &#x4E2D;&#x7684;&#x503C;&#x4FEE;&#x6539;&#xFF0C;dirty map &#x4E2D;&#x4FDD;&#x5B58;&#x7684;&#x6307;&#x9488;&#x5C31;&#x80FD;&#x76F4;&#x63A5;&#x8BFB;&#x5230;&#x4FEE;&#x6539;&#x540E;&#x7684;&#x503C;&#x3002;</p>
<p>&#x5F53;&#x5B58;&#x50A8;&#x65B0;&#x503C;&#x65F6;&#xFF0C;&#x4E00;&#x5B9A;&#x53D1;&#x751F;&#x5728; dirty map &#x4E2D;&#x3002;&#x5F53;&#x8BFB;&#x53D6;&#x65E7;&#x503C;&#x65F6;&#xFF0C;&#x5982;&#x679C; read map &#x8BFB;&#x5230;&#x5219;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x8BFB;&#x5230;&#xFF0C;&#x5219;&#x5C1D;&#x8BD5;&#x52A0;&#x9501;&#x53BB; dirty map &#x4E2D;&#x53D6;&#x3002; &#x8FD9;&#x4E5F;&#x5C31;&#x662F;&#x5B98;&#x65B9;&#x5BA3;&#x79F0;&#x7684; sync.Map &#x9002;&#x7528;&#x4E8E;&#x4E00;&#x6B21;&#x5199;&#x5165;&#x591A;&#x6B21;&#x8BFB;&#x53D6;&#x7684;&#x60C5;&#x666F;&#x3002;</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="类型.html" class="navigation navigation-prev " aria-label="Previous page: 类型">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="内存一致模型.html" class="navigation navigation-next " aria-label="Next page: 内存一致模型">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"内部包","level":"1.2.16","depth":2,"next":{"title":"内存一致模型","level":"1.2.17","depth":2,"path":"go/内存一致模型.md","ref":"go/内存一致模型.md","articles":[]},"previous":{"title":"类型","level":"1.2.15","depth":2,"path":"go/类型.md","ref":"go/类型.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"go/内部包.md","mtime":"2024-10-12T03:32:08.762Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2024-11-15T10:00:56.746Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

