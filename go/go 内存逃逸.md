# 内存逃逸

### 一、概念

go中，堆内存是通过垃圾回收机制自动管理的。编译器决定内存分配位置的方式称为逃逸分析。

逃逸分析由编译器完成，作用于编译阶段。

### 二、逃逸类型

#### 1、指针逃逸

在函数中创建了一个对象，返回了这个对象的指针，这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数结束而回收，因此只能分配在堆上。

#### 2、interface{}动态类型逃逸

在go语言中，空接口可以表示任何类型，如果函数参数为interface{}，编译期很难确定参数的具体类型，也会发生逃逸。

#### 3、栈空间不足

操作系统对内核线程使用的栈空间大小是有限制的，64位操作系统通常是8MB。

栈空间通常比较小，因此递归函数实现不当时，容易导致栈溢出。

对于go来说，运行时尝试在goroutine需要的时候动态的分配栈空间，goroutine的初始栈大小为2KB，当goroutine被调度时，会绑定内核线程执行，栈空间大小也不会超过操作系统限制。

对于go编译器来说，超过一定大小的局部变量将逃逸到堆上，不同的go版本的大小限制可能不一样。

经验：指针指向的数据都是在堆上分配的

### 三、查看变量逃逸情况

编译时可以借助选项-gcflags=-m，查看变量的逃逸情况

$ go build -gcflags=-m main_pointer.go 
./main_pointer.go:10:6: can inline createDemo
./main_pointer.go:17:20: inlining call to createDemo
./main_pointer.go:18:13: inlining call to fmt.Println
./main_pointer.go:10:17: leaking param: name
./main_pointer.go:11:10: new(Demo) escapes to heap
./main_pointer.go:17:20: new(Demo) escapes to heap
./main_pointer.go:18:13: demo escapes to heap
./main_pointer.go:18:13: main []interface {} literal does not escape
./main_pointer.go:18:13: io.Writer(os.Stdout) escapes to heap
<autogenerated>:1: (*File).close .this does not escape

escape to heap 表示逃逸到堆上

### 四、go 逃逸FAQ

How do I know whether a variable is allocated on the heap or the stack?

From a correctness standpoint, you don't need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.

The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function's stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.

In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.

中文：

我如何知道变量是分配在堆上还是栈上？

从正确性的角度来看，您不需要知道。只要有对它的引用，Go 中的每个变量就存在。实现选择的存储位置与语言的语义无关。

存储位置确实对编写高效程序有影响。如果可能，Go 编译器将在该函数的堆栈帧中分配该函数的本地变量。但是，如果编译器在函数返回后无法证明该变量未被引用，那么编译器必须在垃圾回收堆上分配该变量以避免悬空指针错误。此外，如果局部变量非常大，将其存储在堆上而不是栈上可能更有意义。

在当前的编译器中，如果一个变量的地址被占用，那么该变量就是在堆上分配的候选者。但是，基本的逃逸分析会识别某些情况，即此类变量不会超过函数的返回值并且可以驻留在栈中。
