# ç±»å‹

## 1ã€channel

æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªé”åŠ ä¸Šä¸€ä¸ªç¯çŠ¶ç¼“å­˜ã€ä¸€ä¸ªå‘é€æ–¹é˜Ÿåˆ—å’Œä¸€ä¸ªæ¥æ”¶æ–¹é˜Ÿåˆ—ã€‚

```go
// src/runtime/chan.go
type hchan struct {
    qcount   uint           // total data in the queue é˜Ÿåˆ—ä¸­æ‰€æœ‰æ•°æ®æ•°
    dataqsiz uint           // size of the circular queue ç¯å½¢é˜Ÿåˆ—çš„å¤§å°
    buf      unsafe.Pointer // points to an array of dataqsiz elements æŒ‡å‘ç¯å½¢é˜Ÿåˆ—æ•°ç»„çš„æŒ‡é’ˆ
    elemsize uint16         // å…ƒç´ å¤§å°
    closed   uint32         // æ˜¯å¦å…³é—­
    elemtype *_type         // element type å…ƒç´ ç±»å‹
    sendx    uint           // send index å‘é€ç´¢å¼•
    recvx    uint           // receive index æ¥æ”¶ç´¢å¼•
    recvq    waitq          // list of recv waiters æ¥æ”¶ç­‰å¾…åˆ—è¡¨
    sendq    waitq          // list of send waiters å‘é€ç­‰å¾…åˆ—è¡¨

    // lock protects all fields in hchan, as well as several
    // fields in sudogs blocked on this channel.
    //
    // Do not change another G's status while holding this lock
    // (in particular, do not ready a G), as this can deadlock
    // with stack shrinking.
    lock mutex
}

type waitq struct {
    first *sudog
    last  *sudog
}
```

![oauth2](../image/channel.jpg)

### channelçš„åˆ›å»º

å°†ä¸€ä¸ªmakeè¯­å¥è½¬æ¢ä¸ºmakechanè°ƒç”¨ã€‚makechanå®ç°çš„æœ¬è´¨æ˜¯æ ¹æ®éœ€è¦åˆ›å»ºçš„å…ƒç´ å¤§å°ï¼Œå¯¹mallocgcè¿›è¡Œå°è£…ã€‚<span style='color:red'>channelæ€»æ˜¯åœ¨å †ä¸Šè¿›è¡Œåˆ†é…ï¼Œå®ƒä»¬ä¼šè¢«åƒåœ¾å›æ”¶å™¨è¿›è¡Œå›æ”¶ï¼Œæ‰€ä»¥è¯´channelä¸ä¸€å®šæ€»æ˜¯éœ€è¦è°ƒç”¨closeè¿›è¡Œæ˜¾ç¤ºå…³é—­ã€‚	</span>

```go
// src/runtime/chan.go
func makechan(t *chantype, size int) *hchan {
    elem := t.elem

    // compiler checks this but be safe.
    // é€šé“å…ƒç´ çš„å¤§å°ä¸èƒ½è¶…è¿‡64KB
    // è™½ç„¶ç¼–è¯‘å™¨ä¼šè¿›è¡Œç±»å‹æ£€æŸ¥ï¼Œä½†è¿™é‡Œä»åŠ ä¸€å±‚æ£€æŸ¥ï¼Œç¡®ä¿å®‰å…¨æ€§
    if elem.size >= 1<<16 {
        throw("makechan: invalid channel element type")
    }
    // æ£€æŸ¥é€šé“çš„å¯¹é½æƒ…å†µ
    // æ£€æŸ¥é€šé“çš„å¤§å°æ˜¯å¦å¯ä»¥è¢«æœ€å¤§å¯¹é½å€¼æ•´é™¤æˆ–è€…æ£€æŸ¥é€šé“å…ƒç´ çš„å¯¹é½å€¼æ˜¯å¦è¶…è¿‡äº†æœ€å¤§å¯¹é½å€¼
    if hchanSize%maxAlign != 0 || elem.align > maxAlign {
        throw("makechan: bad alignment")
    }

    // è®¡ç®—å…ƒç´ å¤§å°ä¸ä¸ªæ•°çš„ä¹˜ç§¯ï¼Œè¿”å›ç»“æœå’Œæº¢å‡ºæ ‡å¿—
    mem, overflow := math.MulUintptr(elem.size, uintptr(size))
    // æº¢å‡ºæ ‡å¿—ï¼šä¹˜ç§¯è¶…å‡ºäº†uintptrç±»å‹çš„èŒƒå›´
    // å¦‚æœä¹˜ç§¯memå¤§äºäº†maxAlloc-hchanSizeï¼Œè¯´æ˜éœ€è¦åˆ†é…çš„å†…å­˜è¶…å‡ºäº†æœ€å¤§å…è®¸åˆ†é…çš„å†…å­˜é‡ã€‚
    // sizeå°äº0ï¼Œè¯´æ˜æ˜¯ä¸€ä¸ªæ— æ•ˆé€šé“
    if overflow || mem > maxAlloc-hchanSize || size < 0 {
        panic(plainError("makechan: size out of range"))
    }

    // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
    // buf points into the same allocation, elemtype is persistent.
    // SudoG's are referenced from their owning thread so they can't be collected.
    // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
    var c *hchan
    switch {
    case mem == 0:
        // Queue or element size is zero.
        // é˜Ÿåˆ—æˆ–å…ƒç´ å¤§å°ä¸º0ï¼Œä»…éœ€åˆ†é…ä¸€ä¸ªhchanç»“æ„ä½“çš„å†…å­˜
        c = (*hchan)(mallocgc(hchanSize, nil, true))
        // Race detector uses this location for synchronization.
        // ç«Ÿæ€æ£€æµ‹
        c.buf = c.raceaddr()
    case elem.ptrdata == 0:
        // Elements do not contain pointers.
        // Allocate hchan and buf in one call.
        // å…ƒç´ ä¸åŒ…å«æŒ‡é’ˆ
        // ä¸€æ¬¡æ€§åˆ†é…hchanå’Œç¼“å†²åŒºbufçš„å†…å­˜
        c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
        // å°†bufæŒ‡é’ˆè®¾ç½®ä¸ºcæŒ‡é’ˆåé¢çš„å†…å­˜ä½ç½®
        c.buf = add(unsafe.Pointer(c), hchanSize)
    default:
        // Elements contain pointers.
        // åŒ…å«æŒ‡é’ˆï¼Œåˆ†åˆ«åˆ†é…hchanå’Œç¼“å†²åŒºbufçš„å†…å­˜
        c = new(hchan)
        c.buf = mallocgc(mem, elem, true)
    }

    // åˆå§‹åŒ–é€šé“ç»“æ„ä½“
    c.elemsize = uint16(elem.size)
    c.elemtype = elem
    c.dataqsiz = uint(size)
    // åˆå§‹åŒ–é€šé“çš„é”
    lockInit(&c.lock, lockRankHchan)

    if debugChan {
        print("makechan: chan=", c, "; elemsize=", elem.size, "; dataqsiz=", size, "\n")
    }
    return c
}
```

<span style='color:red'>åœ¨GOè¯­è¨€ä¸­ï¼Œé€šé“å…ƒç´ çš„å¤§å°é™åˆ¶åœ¨å°äº64KBï¼Œä¸»è¦æ˜¯å‡ºäºæ€§èƒ½å’Œå®ç°çš„è€ƒè™‘ï¼Œç¡®ä¿é€šé“çš„é«˜æ•ˆå®ç°å’Œé¿å…æ½œåœ¨çš„é—®é¢˜ã€‚</span>

æ€§èƒ½è€ƒè™‘ï¼š

- å†…å­˜åˆ†é…ï¼šå½“é€šé“çš„å…ƒç´ å¤§å°è¾ƒå¤§æ—¶ï¼Œæ¯æ¬¡ä¼ è¾“ä¸€ä¸ªå…ƒç´ æ‰€éœ€çš„å†…å­˜åˆ†é…å’Œæ‹·è´æˆæœ¬ä¹Ÿä¼šå¢åŠ ï¼Œå¯¼è‡´æ€§èƒ½æ˜¾è‘—ä¸‹é™ã€‚
- ç¼“å­˜å±€éƒ¨æ€§ï¼šè¾ƒå¤§çš„å…ƒç´ ä¼šå½±å“CPUç¼“å­˜çš„ä½¿ç”¨æ•ˆç‡ã€‚è¾ƒå°çš„å…ƒç´ å¯ä»¥æ›´å¥½çš„åˆ©ç”¨ç¼“å­˜ï¼Œæé«˜ç¨‹åºçš„è¿è¡Œæ•ˆç‡ã€‚

å†…å­˜ç®¡ç†ï¼š

- å†…å­˜ç¢ç‰‡ï¼šè¾ƒå¤§çš„å†…å­˜å—å¯èƒ½ä¼šå¯¼è‡´å†…å­˜ç¢ç‰‡é—®é¢˜ï¼Œå½±å“å†…å­˜çš„åˆ†é…å’Œç®¡ç†ã€‚
- GCå‹åŠ›ï¼šå¢åŠ åƒåœ¾å›æ”¶å™¨çš„è´Ÿæ‹…ã€‚

å®ç°ç®€åŒ–ï¼š

- é€šé“å®ç°ï¼šé€šé“çš„åº•å±‚å®ç°éœ€è¦å¤„ç†å…ƒç´ çš„å­˜å‚¨å’Œä¼ è¾“ã€‚é™åˆ¶å…ƒç´ çš„å¤§å°å¯ä»¥ç®€åŒ–é€šé“çš„å®ç°ï¼Œä½¿ä»£ç æ˜“äºç»´æŠ¤ã€‚
- ç¼“å†²åŒºç®¡ç†ï¼šé€šé“çš„ç¼“å†²åŒºç®¡ç†ä¼šå˜çš„æ›´åŠ å¤æ‚ï¼Œå¦‚æœå…ƒç´ çš„å¤§å°ä¸å—é™åˆ¶ï¼Œå¯èƒ½éœ€è¦å¤„ç†ä¸åŒå¤§å°çš„å†…å­˜å—ã€‚

channelå¹¶ä¸ä¸¥æ ¼æ”¯æŒint64å¤§å°çš„ç¼“å†²ï¼Œå½“makeæ—¶çš„å¤§å°ä¸ºint64ç±»å‹æ—¶ï¼Œè¿è¡Œæ—¶ä¼šå°†å…¶å¼ºè½¬ä¸ºintï¼Œæä¾›äº†å¯¹intè½¬å‹æ˜¯å¦æˆåŠŸçš„æ£€æŸ¥ï¼š

```go
func makechan64(t *chantype, size int64) *hchan {
    // ç¡®ä¿äº†sizeåœ¨è½¬æ¢ä¸ºintç±»å‹æ—¶ä¸ä¼šå‘ç”Ÿæº¢å‡ºï¼Œç”±äºmakechanå¯èƒ½ä¾èµ–äºintç±»å‹æ¥å¤„ç†é€šé“çš„å®¹é‡ï¼Œ
    // è¿™ä¸ªæ£€æŸ¥æ˜¯å¿…è¦çš„ï¼Œä»¥é¿å…æ½œåœ¨çš„å†…å­˜åˆ†é…é”™è¯¯æˆ–å…¶ä»–é€»è¾‘é”™è¯¯ï¼Œ
    // å¦‚æœsizeè¶…å‡ºintç±»å‹çš„è¡¨ç¤ºèŒƒå›´ï¼Œåˆ™ä¼šå¼•å‘panicï¼Œé¿å…ä¸åˆæ³•çš„é€šé“åˆ›å»º
    if int64(int(size)) != size {
        panic(plainError("makechan: size out of range"))
    }

    return makechan(t, int(size))
}
```

### å‘channelå‘é€æ•°æ®ï¼š

1. <span style='color:red'>å¦‚æœä¸€ä¸ªchannelä¸ºé›¶å€¼ï¼ˆæ¯”å¦‚æ²¡æœ‰åˆå§‹åŒ–ï¼‰ï¼Œè¿™ä¸ªæ—¶å€™å‘é€æ“ä½œä¼šé˜»å¡å½“å‰çš„åç¨‹ï¼Œå‘ç”Ÿæ­»é”ã€‚</span>
2. å½“channelä¸Šæœ‰æ¥æ”¶æ–¹ç­‰å¾…ï¼Œå¯ä»¥ç›´æ¥å°†æ•°æ®å‘é€èµ°ï¼Œå¹¶è¿”å›ã€‚
3. æ²¡æœ‰æ¥æ”¶æ–¹ï¼Œä½†ç¼“å­˜ä¸­è¿˜æœ‰ç©ºé—´æ¥å­˜æ”¾æ²¡æœ‰è¯»å–çš„æ•°æ®ï¼Œåˆ™å­˜å‚¨åœ¨ç¼“å†²åŒºã€‚
4. æ²¡æœ‰æ¥æ”¶æ–¹ï¼Œç¼“å­˜ä¹Ÿæ»¡äº†ï¼Œåˆ™é˜»å¡å½“å‰çš„åç¨‹

```go
// å‘channelå‘é€æ•°æ®çš„å®ç°
// entry point for c <- x from compiled code.
//
//go:nosplit
func chansend1(c *hchan, elem unsafe.Pointer) {
    chansend(c, elem, true, getcallerpc())
}

/*
 * generic single channel send/recv
 * If block is not nil,
 * then the protocol will not
 * sleep but return if it could
 * not complete.
 *
 * sleep can wake up with g.param == nil
 * when a channel involved in the sleep has
 * been closed.  it is easiest to loop and re-run
 * the operation; we'll see that it's now closed.
 */
// c æŒ‡å‘ç›®æ ‡channelçš„æŒ‡é’ˆ
// ep æŒ‡å‘å¾…å‘é€æ•°æ®çš„æŒ‡é’ˆ
// block æ˜¯å¦ä¸ºé˜»å¡æ“ä½œ
// callerpc è°ƒç”¨æ–¹çš„ç¨‹åºè®¡æ•°å™¨
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
    // å‘nilçš„channelå‘é€æ•°æ®ï¼Œä¼šè°ƒç”¨gopark
    if c == nil {
        if !block {
            return false
        }
        // goparkä¼šå°†å½“å‰çš„åç¨‹ä¼‘çœ ï¼Œå‘ç”Ÿæ­»é”å´©æºƒ
        gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)
        throw("unreachable")
    }

    if debugChan {
        print("chansend: chan=", c, "\n")
    }

    // å¦‚æœå¯ç”¨äº†ç«Ÿæ€æ£€æµ‹ï¼Œä¼šè®°å½•ç›¸åº”çš„è¯»æ“ä½œ
    if raceenabled {
        racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend))
    }

    // Fast path: check for failed non-blocking operation without acquiring the lock.
    //
    // After observing that the channel is not closed, we observe that the channel is
    // not ready for sending. Each of these observations is a single word-sized read
    // (first c.closed and second full()).
    // Because a closed channel cannot transition from 'ready for sending' to
    // 'not ready for sending', even if the channel is closed between the two observations,
    // they imply a moment between the two when the channel was both not yet closed
    // and not ready for sending. We behave as if we observed the channel at that moment,
    // and report that the send cannot proceed.
    //
    // It is okay if the reads are reordered here: if we observe that the channel is not
    // ready for sending and then observe that it is not closed, that implies that the
    // channel wasn't closed during the first observation. However, nothing here
    // guarantees forward progress. We rely on the side effects of lock release in
    // chanrecv() and closechan() to update this thread's view of c.closed and full().
    // éé˜»å¡æ“ä½œå¹¶ä¸”æ²¡æœ‰å…³é—­å¹¶ä¸”æ»¡äº†
    if !block && c.closed == 0 && full(c) {
        return false
    }

    // å¯ç”¨æ€§èƒ½åˆ†æï¼Œè®°å½•å½“å‰æ—¶é—´æˆ³
    var t0 int64
    if blockprofilerate > 0 {
        t0 = cputicks()
    }

    // åŠ é”ï¼Œç¡®ä¿å¹¶å‘å®‰å…¨
    lock(&c.lock)

    // åŒé‡æ£€éªŒ
    // channelå…³é—­äº†ï¼Œè§£é”å¹¶ä¸”panic
    if c.closed != 0 {
        unlock(&c.lock)
        panic(plainError("send on closed channel"))
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰ç­‰å¾…çš„æ¥æ”¶è€…
    if sg := c.recvq.dequeue(); sg != nil {
        // Found a waiting receiver. We pass the value we want to send
        // directly to the receiver, bypassing the channel buffer (if any).
        // æœ‰ï¼Œç›´æ¥å°†æ•°æ®å‘é€ç»™æ¥æ”¶è€…ï¼Œç»•è¿‡ç¼“å†²åŒºï¼Œå¹¶è§£é”
        send(c, sg, ep, func() { unlock(&c.lock) }, 3)
        return true
    }

    if c.qcount < c.dataqsiz {
        // æœ‰ç¼“å†²åŒºç©ºé—´
        // Space is available in the channel buffer. Enqueue the element to send.
        // è·å–è¦æ‹·è´åˆ°çš„ç¼“å†²åŒºåœ°å€ç©ºé—´
        qp := chanbuf(c, c.sendx)
        if raceenabled {
            racenotify(c, c.sendx, nil)
        }
        // å°†æ•°æ®å¤åˆ¶åˆ°ç¼“å†²åŒº
        typedmemmove(c.elemtype, qp, ep)
        // æ›´æ–°ç¼“å†²åŒºè®¡æ•°å’Œç´¢å¼•ï¼Œè§£é”å¹¶è¿”å›
        c.sendx++
        if c.sendx == c.dataqsiz {
            c.sendx = 0
        }
        c.qcount++
        unlock(&c.lock)
        return true
    }

    // éé˜»å¡æ“ä½œï¼Œæ²¡æœ‰ç©ºé—´ï¼Œè§£é”è¿”å›
    if !block {
        unlock(&c.lock)
        return false
    }

    // æ²¡æœ‰ç­‰å¾…çš„å¹¶ä¸”ä¹Ÿæ²¡æœ‰ç¼“å†²ç©ºé—´äº†åˆ™ä¼šé˜»å¡åç¨‹
    // Block on the channel. Some receiver will complete our operation for us.
    gp := getg()

    // åˆ›å»ºsudog
    mysg := acquireSudog()
    mysg.releasetime = 0
    if t0 != 0 {
        mysg.releasetime = -1
    }
    // No stack splits between assigning elem and enqueuing mysg
    // on gp.waiting where copystack can find it.
    mysg.elem = ep
    mysg.waitlink = nil
    mysg.g = gp
    mysg.isSelect = false
    mysg.c = c
    gp.waiting = mysg
    gp.param = nil
    // åŠ å…¥å‘é€ç­‰å¾…é˜Ÿåˆ—
    c.sendq.enqueue(mysg)
    // Signal to anyone trying to shrink our stack that we're about
    // to park on a channel. The window between when this G's status
    // changes and when we set gp.activeStackChans is not safe for
    // stack shrinking.
    // å°†å½“å‰åç¨‹çŠ¶æ€è®¾ç½®ä¸ºç­‰å¾…ï¼Œå¹¶å°†å…¶æŒ‚èµ·ï¼Œç­‰å¾…è¢«å”¤é†’
    gp.parkingOnChan.Store(true)
    gopark(chanparkcommit, unsafe.Pointer(&c.lock), waitReasonChanSend, traceEvGoBlockSend, 2)
    // Ensure the value being sent is kept alive until the
    // receiver copies it out. The sudog has a pointer to the
    // stack object, but sudogs aren't considered as roots of the
    // stack tracer.
    // ç¡®ä¿å¾…å‘é€çš„æ•°æ®åœ¨æ¥æ”¶è€…å¤åˆ¶ä¹‹å‰ä¸ä¼šè¢«å›æ”¶
    KeepAlive(ep)

    // someone woke us up.
    // è¢«å”¤é†’åï¼Œæ£€æŸ¥ç­‰å¾…é˜Ÿåˆ—æ˜¯å¦è¢«ç ´å
    if mysg != gp.waiting {
        throw("G waiting list is corrupted")
    }
    // æ›´æ–°ç›¸åº”çŠ¶æ€
    gp.waiting = nil
    gp.activeStackChans = false
    closed := !mysg.success
    gp.param = nil
    if mysg.releasetime > 0 {
        blockevent(mysg.releasetime-t0, 2)
    }
    mysg.c = nil
    // é‡Šæ”¾
    releaseSudog(mysg)
    // channel å·²ç»å…³é—­ è§¦å‘panic
    if closed {
        if c.closed == 0 {
            throw("chansend: spurious wakeup")
        }
        panic(plainError("send on closed channel"))
    }
    return true
}
```

```go
// send processes a send operation on an empty channel c.
// The value ep sent by the sender is copied to the receiver sg.
// The receiver is then woken up to go on its merry way.
// Channel c must be empty and locked.  send unlocks c with unlockf.
// sg must already be dequeued from c.
// ep must be non-nil and point to the heap or the caller's stack.
func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
    // todo å¯ç”¨ç«Ÿæ€æ£€æµ‹ç›¸å…³ï¼Œå¾…ç ”ç©¶
    if raceenabled {
        if c.dataqsiz == 0 {
            racesync(c, sg)
        } else {
            // Pretend we go through the buffer, even though
            // we copy directly. Note that we need to increment
            // the head/tail locations only when raceenabled.
            racenotify(c, c.recvx, nil)
            racenotify(c, c.recvx, sg)
            c.recvx++
            if c.recvx == c.dataqsiz {
                c.recvx = 0
            }
            c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
        }
    }
    // ç›´æ¥å‘é€æ•°æ®
    if sg.elem != nil {
        sendDirect(c.elemtype, sg, ep)
        sg.elem = nil
    }
    // å”¤é†’æ¥æ”¶è€…
    gp := sg.g
    // è§£é”channel
    unlockf()
    gp.param = unsafe.Pointer(sg)
    // æ ‡å¿—æ”¹ä¸ºtrueï¼Œè¡¨ç¤ºå‘é€æˆåŠŸ
    sg.success = true
    // æ›´æ–°é‡Šæ”¾æ—¶é—´
    if sg.releasetime != 0 {
        sg.releasetime = cputicks()
    }
    // å”¤é†’æ¥æ”¶è€…gp
    goready(gp, skip+1)
}

// Sends and receives on unbuffered or empty-buffered channels are the
// only operations where one running goroutine writes to the stack of
// another running goroutine. The GC assumes that stack writes only
// happen when the goroutine is running and are only done by that
// goroutine. Using a write barrier is sufficient to make up for
// violating that assumption, but the write barrier has to work.
// typedmemmove will call bulkBarrierPreWrite, but the target bytes
// are not in the heap, so that will not help. We arrange to call
// memmove and typeBitsBulkBarrier instead.

func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {
    // src is on our stack, dst is a slot on another stack.
    // srcåœ¨å½“å‰goroutineçš„æ ˆä¸Šï¼Œdstæ˜¯å¦ä¸€ä¸ªgoroutineæ ˆä¸Šçš„æ§½ä½ã€‚

    // Once we read sg.elem out of sg, it will no longer
    // be updated if the destination's stack gets copied (shrunk).
    // So make sure that no preemption points can happen between read & use.
    // è¯»å–ç›®æ ‡æ§½ä½çš„åœ°å€åˆ°dstã€‚ä¸€æ—¦è¯»å–å‡ºæ¥ï¼Œå¦‚æœç›®æ ‡goroutineçš„æ ˆè¢«å¤åˆ¶ï¼Œä¾‹å¦‚æ ˆç¼©å°
    // sg.elemå°†ä¸ä¼šè¢«æ›´æ–°ã€‚å› æ­¤ï¼Œåœ¨è¯»å–å’Œä½¿ç”¨ä¹‹é—´ç¡®ä¿æ²¡æœ‰æŠ¢å ç‚¹ï¼ˆå³ä¸å…è®¸å½“å‰goroutineè¢«æŒ‚èµ·ï¼‰
    dst := sg.elem
    // todo ä¸€ç§å†…å­˜å±éšœï¼Œç”¨äºç¡®ä¿åœ¨å†…å­˜å¤åˆ¶æ“ä½œä¹‹å‰æ­£ç¡®å¤„ç†å†™å±éšœ
    typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)
    // No need for cgo write barrier checks because dst is always
    // Go memory.
    // å°†æ•°æ®ä»srcå¤åˆ¶åˆ°dstã€‚è¿™æ˜¯ä¸€ç§ä½çº§åˆ«çš„å†…å­˜å¤åˆ¶æ“ä½œï¼Œä¸éœ€è¦é¢å¤–çš„cgoå†™å±éšœæ£€æŸ¥
    // dstå§‹ç»ˆæ˜¯goå†…å­˜
    memmove(dst, src, t.size)
}
```

sendæ“ä½œä¸­éšå«äº†æœ‰æ¥æ”¶æ–¹é˜»å¡åœ¨channelä¸Šï¼Œå½“æˆ‘ä»¬å‘é€å®Œæ•°æ®åï¼Œå”¤é†’æ¥æ”¶æ–¹ã€‚

è¿™ä¸ªsendæ“ä½œå…¶å®æ˜¯ä¸€ç§ä¼˜åŒ–ï¼ŒåŸå› åœ¨äºï¼Œå·²ç»å¤„äºç­‰å¾…çŠ¶æ€çš„åç¨‹æ˜¯æ²¡æœ‰è¢«æ‰§è¡Œçš„ã€‚å› æ­¤ç”¨æˆ·æ€ä»£ç ä¸ä¼šä¸å½“å‰æ‰€å‘ç”Ÿçš„æ•°æ®å‘ç”Ÿä»»ä½•ç«äº‰ã€‚æ‰€ä»¥æ²¡æœ‰å¿…è¦å°†å†—ä½™çš„æ•°æ®å†™åˆ°ç¼“å­˜ä¸­ï¼Œå†è®©æ¥æ”¶æ–¹è¯»å–ï¼Œæ‰€ä»¥sendDirectçš„è°ƒç”¨ï¼Œæœ¬è´¨ä¸Šæ˜¯å°†æ•°æ®ç›´æ¥å†™å…¥æ¥æ”¶æ–¹çš„æ‰§è¡Œæ ˆã€‚

### ä»channelä¸­æ¥æ”¶æ•°æ®

1. <span style='color:red'>å¦‚æœä¸€ä¸ªchannelä¸ºé›¶å€¼ï¼ˆæ¯”å¦‚æ²¡æœ‰åˆå§‹åŒ–ï¼‰ï¼Œè¿™ä¸ªæ—¶å€™æ¥æ”¶æ“ä½œä¼šé˜»å¡å½“å‰çš„åç¨‹ï¼Œå‘ç”Ÿæ­»é”ã€‚</span>
2. channelå·²ç»è¢«å…³é—­ï¼Œä¸”channelä¸­æ²¡æœ‰æ•°æ®ï¼Œç«‹å³è¿”å›ã€‚
3. å¦‚æœå­˜åœ¨æ­£åœ¨é˜»å¡çš„å‘é€æ–¹ï¼Œè¯´æ˜ç¼“å­˜å·²æ»¡ï¼Œä»ç¼“å­˜é˜Ÿå¤´å–ä¸€ä¸ªæ•°æ®ï¼Œå†å”¤é†’ä¸€ä¸ªå‘é€æ–¹ã€‚
4. å¦åˆ™ï¼Œæ£€æŸ¥ç¼“å­˜ï¼Œå¦‚æœç¼“å­˜ä¸­ä»æœ‰æ•°æ®ï¼Œåˆ™ä»ç¼“å­˜ä¸­è¯»å–ï¼Œè¯»å–è¿‡ç¨‹ä¼šå°†é˜Ÿåˆ—ä¸­çš„æ•°æ®æ‹·è´ä¸€ä»½åˆ°æ¥æ”¶æ–¹çš„æ‰§è¡Œæ ˆä¸­
5. æ²¡æœ‰èƒ½æ¥æ”¶çš„æ•°æ®ï¼Œå°±é˜»å¡å½“å‰æ¥æ”¶æ–¹çš„åç¨‹ã€‚

```go
// ä»channelæ¥æ”¶æ•°æ®çš„å®ç°
// entry points for <- c from compiled code.
//
//go:nosplit
func chanrecv1(c *hchan, elem unsafe.Pointer) {
    chanrecv(c, elem, true)
}

//go:nosplit
func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {
    _, received = chanrecv(c, elem, true)
    return
}

// chanrecv receives on channel c and writes the received data to ep.
// ep may be nil, in which case received data is ignored.
// If block == false and no elements are available, returns (false, false).
// Otherwise, if c is closed, zeros *ep and returns (true, false).
// Otherwise, fills in *ep with an element and returns (true, true).
// A non-nil ep must point to the heap or the caller's stack.
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
    // raceenabled: don't need to check ep, as it is always on the stack
    // or is new memory allocated by reflect.

    if debugChan {
        print("chanrecv: chan=", c, "\n")
    }

    // nilçš„channel
    if c == nil {
        // éé˜»å¡æ¨¡å¼ï¼Œç›´æ¥è¿”å›
        if !block {
            return
        }
        // é˜»å¡ï¼Œç›´æ¥ä¼‘çœ å½“å‰goroutineï¼Œå¯¼è‡´æ­»é”å´©æºƒ
        gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)
        throw("unreachable")
    }

    // Fast path: check for failed non-blocking operation without acquiring the lock.
    // éé˜»å¡å¹¶ä¸”åç¨‹ä¸ºç©º
    if !block && empty(c) {
        // After observing that the channel is not ready for receiving, we observe whether the
        // channel is closed.
        //
        // Reordering of these checks could lead to incorrect behavior when racing with a close.
        // For example, if the channel was open and not empty, was closed, and then drained,
        // reordered reads could incorrectly indicate "open and empty". To prevent reordering,
        // we use atomic loads for both checks, and rely on emptying and closing to happen in
        // separate critical sections under the same lock.  This assumption fails when closing
        // an unbuffered channel with a blocked send, but that is an error condition anyway.
        // æ£€æŸ¥channelæ˜¯å¦å…³é—­
        if atomic.Load(&c.closed) == 0 {
            // æœªå…³é—­ï¼Œåˆ™è¿”å›
            // Because a channel cannot be reopened, the later observation of the channel
            // being not closed implies that it was also not closed at the moment of the
            // first observation. We behave as if we observed the channel at that moment
            // and report that the receive cannot proceed.
            return
        }
        // The channel is irreversibly closed. Re-check whether the channel has any pending data
        // to receive, which could have arrived between the empty and closed checks above.
        // Sequential consistency is also required here, when racing with such a send.
        // æœªå…³é—­ä½†ä¸ºç©ºï¼Œæ¸…ç©ºæ¥æ”¶çš„æŒ‡é’ˆepå¹¶è¿”å›
        if empty(c) {
            // The channel is irreversibly closed and empty.
            if raceenabled {
                raceacquire(c.raceaddr())
            }
            if ep != nil {
                typedmemclr(c.elemtype, ep)
            }
            return true, false
        }
    }

    var t0 int64
    if blockprofilerate > 0 {
        t0 = cputicks()
    }

    lock(&c.lock)

    if c.closed != 0 {
        // channel å…³é—­ä¸”ä¸ºç©ºï¼Œåˆ™æ¸…ç©ºepå¹¶è¿”å›
        if c.qcount == 0 {
            if raceenabled {
                raceacquire(c.raceaddr())
            }
            unlock(&c.lock)
            if ep != nil {
                typedmemclr(c.elemtype, ep)
            }
            return true, false
        }
        // The channel has been closed, but the channel's buffer have data.
    } else {
        // Just found waiting sender with not closed.
        // æœ‰é˜»å¡çš„å‘é€æ–¹ï¼Œåˆ™ç›´æ¥æ¥æ”¶æ•°æ®
        if sg := c.sendq.dequeue(); sg != nil {
            // Found a waiting sender. If buffer is size 0, receive value
            // directly from sender. Otherwise, receive from head of queue
            // and add sender's value to the tail of the queue (both map to
            // the same buffer slot because the queue is full).
            recv(c, sg, ep, func() { unlock(&c.lock) }, 3)
            return true, true
        }
    }

    // ç¼“å†²åŒºæœ‰æ•°æ®ï¼Œä¸ç®¡channelæ˜¯å¦å…³é—­
    if c.qcount > 0 {
        // Receive directly from queue
        // æ¥æ”¶æ•°æ®ï¼Œè§£é”å¹¶è¿”å›
        qp := chanbuf(c, c.recvx)
        if raceenabled {
            racenotify(c, c.recvx, nil)
        }
        if ep != nil {
            typedmemmove(c.elemtype, ep, qp)
        }
        typedmemclr(c.elemtype, qp)
        c.recvx++
        if c.recvx == c.dataqsiz {
            c.recvx = 0
        }
        c.qcount--
        unlock(&c.lock)
        return true, true
    }

    // éé˜»å¡ï¼Œè§£é”cå¹¶è¿”å›
    if !block {
        unlock(&c.lock)
        return false, false
    }

    // no sender available: block on this channel.
    // æ²¡æœ‰æ•°æ®å¯ä»¥æ¥æ”¶ï¼Œåˆ™é˜»å¡åç¨‹
    gp := getg()
    // è·å–å¹¶åˆå§‹åŒ–sudog
    mysg := acquireSudog()
    mysg.releasetime = 0
    if t0 != 0 {
        mysg.releasetime = -1
    }
    // No stack splits between assigning elem and enqueuing mysg
    // on gp.waiting where copystack can find it.
    mysg.elem = ep
    mysg.waitlink = nil
    gp.waiting = mysg
    mysg.g = gp
    mysg.isSelect = false
    mysg.c = c
    gp.param = nil
    // åŠ å…¥åˆ°æ¥æ”¶ç­‰å¾…é˜Ÿåˆ—
    c.recvq.enqueue(mysg)
    // Signal to anyone trying to shrink our stack that we're about
    // to park on a channel. The window between when this G's status
    // changes and when we set gp.activeStackChans is not safe for
    // stack shrinking.
    // é˜»å¡å½“å‰åç¨‹
    gp.parkingOnChan.Store(true)
    gopark(chanparkcommit, unsafe.Pointer(&c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2)

    // someone woke us up
    // è¢«å”¤é†’åï¼Œæ£€æŸ¥sudogçš„çŠ¶æ€
    if mysg != gp.waiting {
        throw("G waiting list is corrupted")
    }
    gp.waiting = nil
    gp.activeStackChans = false
    if mysg.releasetime > 0 {
        blockevent(mysg.releasetime-t0, 2)
    }
    success := mysg.success
    gp.param = nil
    mysg.c = nil
    // é‡Šæ”¾sudog
    releaseSudog(mysg)
    return true, success
}
```

æ¥æ”¶æ•°æ®åŒæ ·åŒ…å«ç›´æ¥å¾€æ¥æ”¶æ–¹çš„æ‰§è¡Œæ ˆä¸­æ‹·è´è¦å‘é€çš„æ•°æ®ï¼Œä½†è¿™ç§æƒ…å†µå½“ä¸”ä»…å½“ç¼“å­˜å¤§å°ä¸º0æ—¶ï¼Œå³é‡‡ç”¨æ— ç¼“å†²çš„channelã€‚

```go
// recv processes a receive operation on a full channel c.
// There are 2 parts:
//  1. The value sent by the sender sg is put into the channel
//     and the sender is woken up to go on its merry way.
//  2. The value received by the receiver (the current G) is
//     written to ep.
//
// For synchronous channels, both values are the same.
// For asynchronous channels, the receiver gets its data from
// the channel buffer and the sender's data is put in the
// channel buffer.
// Channel c must be full and locked. recv unlocks c with unlockf.
// sg must already be dequeued from c.
// A non-nil ep must point to the heap or the caller's stack.
func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
    if c.dataqsiz == 0 {
        // æ— ç¼“å†²channelçš„å¤„ç†
        if raceenabled {
            racesync(c, sg)
        }
        if ep != nil {
            // copy data from sender
            // æ¥æ”¶æ•°æ®æŒ‡é’ˆä¸æ˜¯nilï¼Œåˆ™ç›´æ¥ä»å‘é€ç€å¤„å¤åˆ¶æ•°æ®åˆ°epã€‚
            recvDirect(c.elemtype, sg, ep)
        }
    } else {
        // Queue is full. Take the item at the
        // head of the queue. Make the sender enqueue
        // its item at the tail of the queue. Since the
        // queue is full, those are both the same slot.
        // æœ‰ç¼“å†²çš„channelï¼Œè¿›å…¥è¿™ä¸ªå‡½æ•°è¡¨ç¤ºé˜Ÿåˆ—å·²æ»¡
        // è·å–é˜Ÿåˆ—å¤´éƒ¨å…ƒç´ çš„ä½ç½®
        qp := chanbuf(c, c.recvx)
        if raceenabled {
            racenotify(c, c.recvx, nil)
            racenotify(c, c.recvx, sg)
        }
        // copy data from queue to receiver
        if ep != nil {
            // å°†æ•°æ®ä»ç¼“å†²åŒºå¤åˆ¶åˆ°æ¥æ”¶è€…
            // ç¯å½¢é˜Ÿåˆ—ï¼Œå–å‡ºå¤´éƒ¨å’Œå¡å…¥çš„å°¾éƒ¨åœ¨åŒä¸€ä¸ªä½ç½®
            typedmemmove(c.elemtype, ep, qp)
        }
        // copy data from sender to queue
        // ä»å‘é€æ–¹æ‹·è´åˆ°ç¼“å†²é˜Ÿåˆ—ä¸­
        typedmemmove(c.elemtype, qp, sg.elem)
        // æ›´æ–°ç´¢å¼•
        c.recvx++
        if c.recvx == c.dataqsiz {
            c.recvx = 0
        }
        c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
    }
    // å”¤é†’å‘é€ç€
    sg.elem = nil
    gp := sg.g
    unlockf()
    gp.param = unsafe.Pointer(sg)
    // å‘é€æˆåŠŸ
    sg.success = true
    if sg.releasetime != 0 {
        sg.releasetime = cputicks()
    }
    goready(gp, skip+1)
}
```

<span style='color:red'>å¯¹äºæ— ç¼“å†²çš„channelï¼Œæ¥æ”¶æ“ä½œå‘ç”Ÿåœ¨å‘é€æ“ä½œä¹‹å‰ï¼Œæ— ç¼“å†²channelçš„æ¥æ”¶æ–¹ä¼šå…ˆä»å‘é€æ–¹æ ˆæ‹·è´æ•°æ®åï¼Œå‘é€æ–¹æ‰ä¼šè¢«æ”¾å›è°ƒåº¦é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…é‡æ–°è°ƒåº¦ã€‚</span>

åœ¨æ— ç¼“å†²çš„channelä¸­ï¼Œå‘é€å’Œæ¥æ”¶æ“ä½œæ˜¯åŒæ­¥çš„ã€‚å‘é€æ–¹æ‰§è¡Œå‘é€æ“ä½œæ—¶ä¼šé˜»å¡ï¼Œç›´åˆ°æ¥æ”¶æ–¹æ¥æ”¶æ•°æ®ã€‚æ¥æ”¶æ–¹åœ¨æ‰§è¡Œæ¥æ”¶æ“ä½œæ—¶ä¹Ÿä¼šé˜»å¡ï¼Œç›´åˆ°å‘é€æ–¹è°ƒç”¨å‘é€æ•°æ®ã€‚

æ•°æ®æ‹·è´å®Œæˆä¹‹å‰ï¼Œå‘é€æ–¹ä¸€ç›´å¤„äºé˜»å¡çŠ¶æ€ï¼Œæ— æ³•ç»§ç»­æ‰§è¡Œã€‚åªæœ‰åœ¨æ¥æ”¶æ–¹æˆåŠŸæ¥æ”¶åˆ°æ•°æ®å¹¶è§£é™¤é˜»å¡åï¼Œå‘é€æ–¹æ‰ä¼šè§£é™¤é˜»å¡ã€‚

```go
package main

import (
	"fmt"
	"time"
)
// å…·ä½“å“ªä¸ªæ‰“å°å…ˆæ‰§è¡Œï¼Œç”±è°ƒåº¦å™¨å†³å®š
func main() {
	ch := make(chan int)

	go func() {
		// å‘æ— ç¼“å†² channel å‘é€æ•°æ®
		ch <- 42
		fmt.Println("Sent value")
	}()

	time.Sleep(time.Second) // æ¨¡æ‹Ÿä¸€äº›å»¶è¿Ÿ

	// ä»æ— ç¼“å†² channel æ¥æ”¶æ•°æ®
	value := <-ch
	fmt.Println("Received value:", value)
}
```

### channelçš„å…³é—­

å…·ä½“çš„å®ç°ä¸­ï¼Œé¦–å…ˆå¯¹channelä¸Šé”ï¼Œè€Œåä¾æ¬¡å°†é˜»å¡åœ¨channelçš„gæ·»åŠ åˆ°ä¸€ä¸ªgListä¸­ï¼Œå½“æ‰€æœ‰çš„gå‡ä»channelä¸Šç§»é™¤æ—¶ï¼Œå¯é‡Šæ”¾é”ï¼Œå¹¶å”¤é†’gListä¸­çš„æ‰€æœ‰æ¥æ”¶æ–¹å’Œå‘é€æ–¹ã€‚

```go
func closechan(c *hchan) {
    if c == nil {
        // closeä¸€ä¸ªç©ºçš„channelä¼šäº§ç”Ÿpanic
        panic(plainError("close of nil channel"))
    }

    lock(&c.lock)
    if c.closed != 0 {
        unlock(&c.lock)
        // é‡å¤å…³é—­channelä¹Ÿä¼šäº§ç”Ÿpanic
        panic(plainError("close of closed channel"))
    }

    // æ•°æ®ç«äº‰æ£€æµ‹ï¼Œè®°å½•ç›¸å…³ä¿¡æ¯
    if raceenabled {
        callerpc := getcallerpc()
        racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan))
        racerelease(c.raceaddr())
    }

    // è®¾ç½®å…³é—­çŠ¶æ€
    c.closed = 1

    // å®šä¹‰ä¸€ä¸ªgoroutineåˆ—è¡¨
    var glist gList

    // release all readers
    // é‡Šæ”¾æ‰€æœ‰ç­‰å¾…æ¥æ”¶çš„goroutine
    for {
        sg := c.recvq.dequeue()
        if sg == nil {
            break
        }
        if sg.elem != nil {
            // æ¸…ç†
            typedmemclr(c.elemtype, sg.elem)
            sg.elem = nil
        }
        // æ›´æ–°é‡Šæ”¾æ—¶é—´
        if sg.releasetime != 0 {
            sg.releasetime = cputicks()
        }
        gp := sg.g
        gp.param = unsafe.Pointer(sg)
        sg.success = false
        if raceenabled {
            raceacquireg(gp, c.raceaddr())
        }
        glist.push(gp)
    }

    // release all writers (they will panic)
    // é‡Šæ”¾æ‰€æœ‰å‘é€æ–¹
    for {
        sg := c.sendq.dequeue()
        if sg == nil {
            break
        }
        sg.elem = nil
        if sg.releasetime != 0 {
            sg.releasetime = cputicks()
        }
        gp := sg.g
        gp.param = unsafe.Pointer(sg)
        sg.success = false
        if raceenabled {
            raceacquireg(gp, c.raceaddr())
        }
        glist.push(gp)
    }
    unlock(&c.lock)

    // Ready all Gs now that we've dropped the channel lock.
    // å°±ç»ªæ‰€æœ‰çš„åç¨‹
    for !glist.empty() {
        gp := glist.pop()
        gp.schedlink = 0
        goready(gp, 3)
    }
}
```

å½“channelå…³é—­æ—¶ï¼Œå¿…é¡»è®©æ‰€æœ‰é˜»å¡çš„æ¥æ”¶æ–¹é‡æ–°è¢«è°ƒåº¦ï¼Œè®©æ‰€æœ‰çš„å‘é€æ–¹ä¹Ÿé‡æ–°è¢«è°ƒåº¦ï¼Œè¿™ä¸ªæ—¶å€™çš„å®ç°å°†åç¨‹ç»Ÿä¸€æ·»åŠ åˆ°ä¸€ä¸ªåˆ—è¡¨ä¸­ï¼Œç„¶åé€ä¸ªé‡æ–°å¯åŠ¨ã€‚

## 2ã€error

é”™è¯¯erroråœ¨Goä¸­è¡¨ç°ä¸ºä¸€ä¸ªå†…å»ºçš„æ¥å£ç±»å‹ï¼Œä»»ä½•å®ç°è¿™ä¸ªæ–¹æ³•çš„ç±»å‹éƒ½èƒ½ä½œä¸ºerrorç±»å‹è¿›è¡Œä¼ é€’ï¼Œæˆä¸ºé”™è¯¯å€¼ã€‚

```go
// src/builtin/builtin.go
// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
// å†…ç½®é”™è¯¯æ¥å£ç±»å‹
type error interface {
    Error() string
}
```

ä½œä¸ºå†…å»ºæ¥å£ç±»å‹ï¼Œç¼–è¯‘å™¨è´Ÿè´£åœ¨å‚æ•°ä¼ é€’æ£€æŸ¥æ—¶ï¼Œå¯¹å€¼ç±»å‹æ‰€å®ç°çš„æ–¹æ³•è¿›è¡Œæ£€æŸ¥ï¼Œå½“ç±»å‹å®ç°äº†è¿™ä¸ªæ–¹æ³•åï¼Œæ‰å…è®¸å…¶ä½œä¸ºerrorè¿›è¡Œä¼ é€’

```go
// src/cmd/compile/internal/types/universe.go
func makeErrorInterface() *Type {
    sig := NewSignature(NoPkg, FakeRecv(), nil, nil, []*Field{
        NewField(src.NoXPos, nil, Types[TSTRING]),
    })
    // æŸ¥æ‰¾æ˜¯å¦å®ç°äº†Error
    method := NewField(src.NoXPos, LocalPkg.Lookup("Error"), sig)
    return NewInterface(NoPkg, []*Field{method}, false)
}
```

### å¸¸è§çš„é”™è¯¯å¤„ç†ç­–ç•¥

å“¨å…µé”™è¯¯ï¼šé€šè¿‡ç‰¹å®šå€¼è¡¨ç¤ºæˆåŠŸå’Œä¸åŒé”™è¯¯ï¼Œä¾é è°ƒç”¨æ–¹å¯¹é”™è¯¯è¿›è¡Œæ£€æŸ¥ã€‚

```go
func readf(path string) error {
	err := file.Open(path)
	if err != nil {
		return fmt.Errorf("cannot open file: %v", err)
	}
}

func main() {
	err := readf("~/.ssh/id_rsa.pub")
	if strings.Contains(err.Error(), "not found") {
		...
	}
}
```

â€‹	è¿™ç±»é”™è¯¯å¤„ç†çš„æ–¹å¼æ˜¯éå¸¸å±é™©çš„ï¼Œå› ä¸ºå®ƒåœ¨è°ƒç”¨æ–¹å’Œè¢«è°ƒç”¨æ–¹ä¹‹é—´å»ºç«‹äº†ç‰¢ä¸å¯ç ´çš„ä¾èµ–å…³ç³»ã€‚

â€‹	é™¤æ­¤ä¹‹å¤–ï¼Œå“¨å…µé”™è¯¯è¿˜æœ‰ä¸€ä¸ªç›¸å½“è‡´å‘½çš„å±é™©ï¼Œé‚£å°±æ˜¯è¿™ç§æ–¹å¼æ‰€å®šä¹‰çš„é”™è¯¯å¹¶éå¸¸é‡ã€‚

```go
package io
var EOF = errors.New("EOF")
```

å¾ˆéš¾é¿å…è¢«å¯¼å‡ºåè¿›è¡Œé‡æ–°èµ‹å€¼ã€‚

```go
package main
import "io"
func init() {
	io.EOF = nil
}
```

â€‹	å¦‚æœåœ¨å¼•å…¥çš„ä¾èµ–ä¸­ï¼Œæœ‰äººæ¶æ„å°†è¿™æ ·éªŒè¯é”™è¯¯çš„å€¼è¿›è¡Œä¿®æ”¹çš„ä»£ç åŒ…å«è¿›å»ï¼Œå°†å¯¼è‡´é‡å¤§çš„å®‰å…¨é—®é¢˜ã€‚

```go
import "cropto/rsa"
func init() {
	rsa.ErrVerification = nil
}
```

â€‹	å½“æˆ‘ä»¬åœ¨é¡¹ç›®ä¸­æ— æ³•ä¿è¯è¿™ç§æ¶æ„ä»£ç ä¸ä¼šå‡ºç°åœ¨æŸä¸ªä¾èµ–åŒ…ä¸­ï¼Œä¸ºäº†å®‰å…¨èµ·è§ï¼Œå˜é‡çš„é”™è¯¯ç±»å‹å¯ä»¥ä¿®æ”¹ä¸ºå¸¸é‡é”™è¯¯ã€‚

è‡ªå®šä¹‰é”™è¯¯

```go
if err, ok := err.(SomeErrorType); ok { ... }
```

â€‹	é€šè¿‡è‡ªå®šä¹‰çš„é”™è¯¯ç±»å‹æ¥è¡¨ç¤ºç‰¹å®šçš„é”™è¯¯ï¼ŒåŒæ ·ä¾èµ–ä¸Šå±‚ä»£ç å¯¹é”™è¯¯å€¼è¿›è¡Œæ£€æŸ¥ï¼Œä¸åŒçš„æ˜¯éœ€è¦ä½¿ç”¨ç±»å‹æ–­è¨€è¿›è¡Œæ£€æŸ¥ã€‚

```go
type CustomizedError struct {
	Line int
	Msg  string
	File string
}
func (e CustomizedError) Error() string {
	return fmt.Sprintf("%s:%d: %s", e.File, e.Line, e.Msg)
}
```

â€‹	è¿™ç§é”™è¯¯å¤„ç†çš„å¥½å¤„åœ¨äºå¯ä»¥å°†é”™è¯¯åŒ…è£…èµ·æ¥ï¼Œæä¾›æ›´å¤šçš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œä½†é”™è¯¯çš„å®ç°æ–¹å¿…é¡»å‘ä¸Šå…¬å¼€å®ç°çš„é”™è¯¯ç±»å‹ï¼Œä¸å¯é¿å…çš„åŒæ ·äº§ç”Ÿä¾èµ–å…³ç³»ã€‚

éšå¼é”™è¯¯

```go
if err != nil { return err }
```

â€‹	è¿™ç§é”™è¯¯å¤„ç†çš„æ–¹å¼ç›´æ¥è¿”å›é”™è¯¯çš„ä»»ä½•ç»†èŠ‚ï¼Œç›´æ¥å°†é”™è¯¯è¿›ä¸€æ­¥æŠ¥å‘Šç»™ä¸Šå±‚ã€‚è¿™ç§æƒ…å†µä¸‹é”™è¯¯åœ¨å½“å‰è°ƒç”¨æ–¹å®Œå…¨æ²¡æœ‰ä»»ä½•åŠ å·¥ï¼Œä¸æ²¡æœ‰è¿›è¡Œå¤„ç†å‡ ä¹æ˜¯ç­‰ä»·çš„ï¼Œè¿™ä¼šäº§ç”Ÿä¸€ä¸ªè‡´å‘½çš„é—®é¢˜ï¼Œä¸¢å¤±è°ƒç”¨çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå¦‚æœæŸä¸ªé”™è¯¯è¿ç»­å‘ä¸Šå±‚ä¼ æ’­äº†å¤šæ¬¡ï¼Œé‚£ä¹ˆä¸Šå±‚ä»£ç å¯èƒ½è¾“å‡ºæŸä¸ªé”™è¯¯æ—¶ï¼Œæ ¹æœ¬æ— æ³•åˆ¤æ–­è¯¥é”™è¯¯çš„é”™è¯¯ä¿¡æ¯ç©¶ç«Ÿä»å“ªé‡Œæ¥ã€‚

### å¤„ç†é”™è¯¯çš„æœ¬è´¨

1. é”™è¯¯å€¼æ£€æŸ¥ï¼šå¦‚ä½•å¯¹ä¸€ä¸ªä¼ æ’­é“¾æ¡ä¸­çš„é”™è¯¯ç±»å‹è¿›è¡Œæ–­è¨€
2. é”™è¯¯æ ¼å¼ä¸ä¸Šä¸‹æ–‡ï¼šå‡ºç°é”™è¯¯æ—¶ï¼Œæ²¡æœ‰è¶³å¤Ÿçš„å †æ ˆä¿¡æ¯ï¼Œå¦‚ä½•å¢å¼ºé”™è¯¯å‘ç”Ÿæ—¶çš„ä¸Šä¸‹æ–‡ä¿¡æ¯å¹¶åˆç†æ ¼å¼åŒ–ä¸€ä¸ªé”™è¯¯ï¼Ÿ
3. é”™è¯¯å¤„ç†è¯­ä¹‰ï¼šæ¯ä¸ªè¿”å›é”™è¯¯çš„å‡½æ•°éƒ½è¦æ±‚è°ƒç”¨æ–¹è¿›è¡Œæ˜¾å¼å¤„ç†ï¼Œå¤„ç†æ–¹å¼å•°å—¦è€Œå†—é•¿ï¼Œå¦‚ä½•å‡å°‘è¿™ç§ä»£ç å‡ºç°çš„å¯†é›†ç¨‹åº¦ï¼Ÿ

#### é”™è¯¯å€¼æ£€æŸ¥

1ã€é”™è¯¯ä¼ æ’­é“¾

ä¸ºäº†å»ºç«‹é”™è¯¯ä¼ æ’­é“¾ï¼Œfmt.Errorfå‡½æ•°å…è®¸ä½¿ç”¨%wåŠ¨è¯å¯¹ä¸€ä¸ªé”™è¯¯è¿›è¡ŒåŒ…è£…ï¼Œå®ƒä¼šå°†éœ€è¦åŒ…è£…çš„erråŒ…è£…ä¸ºä¸€ä¸ªæ–°ç»“æ„ï¼Œå…¶åŒ…å«éœ€è¦å°è£…çš„æ–°é”™è¯¯æ¶ˆæ¯ä»¥åŠåŸå§‹é”™è¯¯ï¼š

```go
type wrapError struct {
    msg string
    err error
}

func (e *wrapError) Error() string {
    return e.msg
}

func (e *wrapError) Unwrap() error {
    return e.err
}
```

fmtåŒ…æœ¬èº«å¯¹æ ¼å¼åŒ–çš„æ”¯æŒå®šä¹‰äº†ppç»“æ„ï¼Œä¼šå°†æ ¼å¼åŒ–åçš„å†…å®¹å­˜å‚¨åˆ°bufä¸­ã€‚ä½†åœ¨é”™è¯¯ä¼ æ’­é“¾æ¡çš„åŒ…è£…ä¸Šï¼Œä¸ºäº†ä¸ç ´ååŸå§‹é”™è¯¯å€¼ï¼Œé¢å¤–ä½¿ç”¨äº†ä¸¤ä¸ªå­—æ®µ

```go
// pp is used to store a printer's state and is reused with sync.Pool to avoid allocations.
type pp struct {
    buf buffer // æ ¼å¼åŒ–çš„å†…å®¹å­˜å‚¨åˆ°buffer

    // arg holds the current item, as an interface{}.
    arg any

    // value is used instead of arg for reflect values.
    value reflect.Value

    // fmt is used to format basic items such as integers or strings.
    fmt fmt

    // reordered records whether the format string used argument reordering.
    reordered bool
    // goodArgNum records whether the most recent reordering directive was valid.
    goodArgNum bool
    // panicking is set by catchPanic to avoid infinite panic, recover, panic, ... recursion.
    panicking bool
    // erroring is set when printing an error string to guard against calling handleMethods.
    erroring bool
    // wrapErrs is set when the format string may contain a %w verb.
    // ç”¨äºæ ¼å¼åŒ–è¿‡ç¨‹ä¸­åˆ¤æ–­æ˜¯å¦å¯¹é”™è¯¯è¿›è¡Œäº†åŒ…è£…
    wrapErrs bool
    // wrappedErrs records the targets of the %w verb.
    // è®°å½•w%åœ¨ç¬¬å‡ ä¸ªå‚æ•°ä¸Š
    wrappedErrs []int
}
```

Errorfæ–¹æ³•ä¼šé¦–å…ˆè¿›è¡Œå¯¹æ ¼å¼çš„å¤„ç†ï¼Œå°†å¸¦æœ‰åŠ¨è¯çš„å­—ç¬¦ä¸²å’Œå‚æ•°è¿›è¡Œæ‹¼æ¥

```go
// src/fmt/errors.go
// Errorf formats according to a format specifier and returns the string as a
// value that satisfies error.
//
// If the format specifier includes a %w verb with an error operand,
// the returned error will implement an Unwrap method returning the operand.
// If there is more than one %w verb, the returned error will implement an
// Unwrap method returning a []error containing all the %w operands in the
// order they appear in the arguments.
// It is invalid to supply the %w verb with an operand that does not implement
// the error interface. The %w verb is otherwise a synonym for %v.
func Errorf(format string, a ...any) error {
    p := newPrinter()
    p.wrapErrs = true     // å‡è®¾æ ¼å¼åŒ–è¿‡ç¨‹ä¸­å¯èƒ½åŒ…å«%wï¼Œæ‰€ä»¥è®¾ç½®ä¸ºtrue
    p.doPrintf(format, a) // æ‹¼æ¥æ ¼å¼åŒ–çš„ç»“æœï¼Œæ–¹ä¾¿æ‰“å°
    s := string(p.buf)    // æ‹¼æ¥å¥½çš„å†…å®¹å–å‡ºæ¥
    // åŒ…è£…åŸå§‹é”™è¯¯
    var err error
    switch len(p.wrappedErrs) {
    case 0:
        err = errors.New(s)
    case 1:
        w := &wrapError{msg: s}
        w.err, _ = a[p.wrappedErrs[0]].(error)
        err = w
    default:
        if p.reordered {
            sort.Ints(p.wrappedErrs)
        }
        var errs []error
        for i, argNum := range p.wrappedErrs {
            if i > 0 && p.wrappedErrs[i-1] == argNum {
                continue
            }
            if e, ok := a[argNum].(error); ok {
                errs = append(errs, e)
            }
        }
        err = &wrapErrors{s, errs}
    }
    p.free()
    return err
}
```

```go
// è°ƒç”¨é“¾ doPrintf -> printArg -> handleMethods
func (p *pp) handleMethods(verb rune) (handled bool) {
	...
	if verb == 'w' {
		err, ok := p.arg.(error)
		// åˆ¤æ–­ä¸ %w å¯¹åº”çš„å€¼æ˜¯å¦ä¸º error ç±»å‹ï¼Œå¦åˆ™å¤„ç†ä¸ºé”™è¯¯çš„åŠ¨è¯ç»„åˆ
		if !ok || !p.wrapErrs || p.wrappedErr != nil {
			...
			return true
		}
		// ä¿å­˜ errï¼Œå¹¶å°†å…¶é€€åŒ–ä¸º %v åŠ¨è¯
		p.wrappedErr = err
		verb = 'v'
	}
	...
}
```

%wè¿™ä¸ªåŠ¨è¯çš„ä¸»è¦ç›®çš„æ˜¯å°†errè®°å½•åˆ°wrappedErrä¸­ï¼Œä»è€Œå®‰å…¨çš„å°†verbè½¬åŒ–ä¸º%vå¯¹å‚æ•°è¿›è¡Œåç»­çš„æ ¼å¼åŒ–æ‹¼æ¥ã€‚

#### é”™è¯¯å€¼æ‹†åŒ…

é‡‡ç”¨ç±»å‹æ–­è¨€è¿›è¡Œæ‹†åŒ…

```go
// src/errors/wrap.go
func Unwrap(err error) error {
	u, ok := err.(interface {
		Unwrap() error
	})
	if !ok {
		return nil
	}
	return u.Unwrap()
}
```

#### é”™è¯¯æ–­è¨€

Is ç”¨äºæ£€æŸ¥å½“å‰çš„ä¸¤ä¸ªé”™è¯¯æ˜¯å¦ç›¸ç­‰ã€‚ä¹‹æ‰€ä»¥éœ€è¦è¿™ä¸ªå‡½æ•°æ˜¯å› ä¸ºä¸€ä¸ªé”™è¯¯å¯èƒ½è¢«åŒ…è£…äº†å¤šå±‚ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦æ”¯æŒè¿™ä¸ªé”™è¯¯åœ¨åŒ…è£…å¤šå±‚åçš„åˆ¤æ–­ã€‚

```go
// src/errors/wrap.go
// Is reports whether any error in err's tree matches target.
//
// The tree consists of err itself, followed by the errors obtained by repeatedly
// calling Unwrap. When err wraps multiple errors, Is examines err followed by a
// depth-first traversal of its children.
//
// An error is considered to match a target if it is equal to that target or if
// it implements a method Is(error) bool such that Is(target) returns true.
//
// An error type might provide an Is method so it can be treated as equivalent
// to an existing error. For example, if MyError defines
//
//	func (m MyError) Is(target error) bool { return target == fs.ErrExist }
//
// then Is(MyError{}, fs.ErrExist) returns true. See syscall.Errno.Is for
// an example in the standard library. An Is method should only shallowly
// compare err and the target and not call Unwrap on either.
func Is(err, target error) bool {
    if target == nil {
        return err == target
    }

    isComparable := reflectlite.TypeOf(target).Comparable()
    for {
        // å¦‚æœtargeté”™è¯¯æ˜¯å¯æ¯”è¾ƒçš„ï¼Œåˆ™ç›´æ¥è¿›è¡Œæ¯”è¾ƒ
        if isComparable && err == target {
            return true
        }
        // åˆ¤æ–­æ˜¯å¦å®ç°äº†Isæ–¹æ³•ï¼Œå®ç°äº†åˆ™è°ƒç”¨Isæ–¹æ³•è¿›è¡Œåˆ¤æ–­
        if x, ok := err.(interface{ Is(error) bool }); ok && x.Is(target) {
            return true
        }
        // å¦åˆ™è§£é™¤åŒ…è£…
        switch x := err.(type) {
        case interface{ Unwrap() error }:
            err = x.Unwrap()
            if err == nil {
                return false
            }
        case interface{ Unwrap() []error }:
            for _, err := range x.Unwrap() {
                if Is(err, target) {
                    return true
                }
            }
            return false
        default:
            return false
        }
    }
}
```

Isæ–¹æ³•çš„ç›®çš„æ˜¯æ›¿æ¢ä½¿ç”¨==å½¢å¼çš„é”™è¯¯æ–­è¨€

```go
if err == io.ErrUnexpectedEOF {
	// ... å¤„ç†é”™è¯¯
}

=>

if errors.Is(err, io.ErrUnexpectedEOF) {
	// ... å¤„ç†é”™è¯¯
}
```

<span style='color:red'>Isæ–¹æ³•è¦æ±‚è‡ªå®šä¹‰çš„é”™è¯¯å€¼å®ç°Is(error) boolæ–¹æ³•æ¥è¿›è¡Œè‡ªå®šä¹‰çš„é”™è¯¯æ–­è¨€ï¼Œå¦åˆ™é”™è¯¯çš„æ¯”è¾ƒä»ç„¶åªä½¿ç”¨==ç®—ç¬¦ã€‚</span>

æ–¹æ³•Asçš„å®ç°ä¸IsåŸºæœ¬ç±»ä¼¼ï¼Œä½†ä¸åŒä¹‹å¤„åœ¨äºAsçš„ç›®çš„æ˜¯å°†æŸä¸ªé”™è¯¯ç»™æ‹†å°åˆ°å…·ä½“çš„å˜é‡ä¸­ï¼Œå› æ­¤å¯¹äºä¸€ä¸ªé”™è¯¯é“¾è€Œè¨€ï¼Œéœ€è¦ä¸€ä¸ªå¾ªç¯ä¸æ–­å¯¹é”™è¯¯è¿›è¡ŒUnwrapï¼Œå½“é”™è¯¯å€¼å®ç°äº†As(interface{}) boolæ–¹æ³•æ—¶ï¼Œåˆ™å¯å®Œæˆæ‹†å°ã€‚

```go
// src/errors/wrap.go
// As finds the first error in err's tree that matches target, and if one is found, sets
// target to that error value and returns true. Otherwise, it returns false.
//
// The tree consists of err itself, followed by the errors obtained by repeatedly
// calling Unwrap. When err wraps multiple errors, As examines err followed by a
// depth-first traversal of its children.
//
// An error matches target if the error's concrete value is assignable to the value
// pointed to by target, or if the error has a method As(interface{}) bool such that
// As(target) returns true. In the latter case, the As method is responsible for
// setting target.
//
// An error type might provide an As method so it can be treated as if it were a
// different error type.
//
// As panics if target is not a non-nil pointer to either a type that implements
// error, or to any interface type.
func As(err error, target any) bool {
    if err == nil {
        return false
    }
    if target == nil {
        panic("errors: target cannot be nil")
    }
    val := reflectlite.ValueOf(target)
    typ := val.Type()
    if typ.Kind() != reflectlite.Ptr || val.IsNil() {
        panic("errors: target must be a non-nil pointer")
    }
    targetType := typ.Elem()
    if targetType.Kind() != reflectlite.Interface && !targetType.Implements(errorType) {
        panic("errors: *target must be interface or implement error")
    }
    for {
        // è‹¥å¯åˆ†é…ï¼Œåˆ™ç›´æ¥å°†erræ‹†å°åˆ°target
        if reflectlite.TypeOf(err).AssignableTo(targetType) {
            val.Elem().Set(reflectlite.ValueOf(err))
            return true
        }
        // åˆ¤æ–­erræ˜¯å¦å®ç°asæ–¹æ³•ï¼Œå®ç°åˆ™ç›´æ¥è°ƒç”¨
        if x, ok := err.(interface{ As(any) bool }); ok && x.As(target) {
            return true
        }
        // å¦åˆ™ç»§ç»­è§£åŒ…è£…
        switch x := err.(type) {
        case interface{ Unwrap() error }:
            err = x.Unwrap()
            if err == nil {
                return false
            }
        case interface{ Unwrap() []error }:
            for _, err := range x.Unwrap() {
                if As(err, target) {
                    return true
                }
            }
            return false
        default:
            return false
        }
    }
}
```

ç”±äºé”™è¯¯é“¾çš„å­˜åœ¨ï¼Œerrors.Asæ–¹æ³•çš„ç›®çš„æ˜¯æ›¿æ¢ç±»å‹æ–­è¨€å¼çš„é”™è¯¯æ–­è¨€ï¼š

```go
if e, ok := err.(*os.PathError); ok {
	// ... å¤„ç†é”™è¯¯
}

=>

var e *os.PathError
if errors.As(err, &e) {
	// ... å¤„ç†é”™è¯¯
}
```

## 3ã€map

å®ç°ä¸€ä¸ªæ€§èƒ½ä¼˜å¼‚çš„å“ˆå¸Œè¡¨ï¼Œéœ€è¦è€ƒè™‘ä¸¤ä¸ªæ–¹é¢ï¼Œä¸€ä¸ªæ˜¯å“ˆå¸Œå‡½æ•°ï¼Œå¦ä¸€ä¸ªæ˜¯å“ˆå¸Œå†²çªçš„è§£å†³æ–¹æ¡ˆã€‚

è£…è½½å› å­:=å…ƒç´ æ•°é‡Ã·æ¡¶æ•°é‡

å¦‚æœä½¿ç”¨ç»“æœåˆ†å¸ƒè¾ƒä¸ºå‡åŒ€çš„å“ˆå¸Œå‡½æ•°ï¼Œé‚£ä¹ˆå“ˆå¸Œçš„å¢åˆ æ”¹æŸ¥çš„æ—¶é—´å¤æ‚åº¦ä¸ºOï¼ˆ1ï¼‰ï¼Œä½†æ˜¯å¦‚æœå“ˆå¸Œå‡½æ•°çš„ç»“æœåˆ†å¸ƒä¸å‡åŒ€ï¼Œé‚£ä¹ˆæ‰€æœ‰æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å¯èƒ½ä¼šè¾¾åˆ°Oï¼ˆnï¼‰ã€‚

è§£å†³å“ˆå¸Œå†²çªçš„æ–¹æ³•ï¼š

1ï¼‰å¼€æ”¾å¯»å€æ³•ï¼Œè¿™ç§æ–¹æ³•çš„æ ¸å¿ƒæ€æƒ³æ˜¯ä¾æ¬¡æ¢æµ‹å’Œæ¯”è¾ƒæ•°ç»„ä¸­çš„å…ƒç´ ä»¥åˆ¤æ–­ç›®æ ‡é”®å€¼å¯¹æ˜¯å¦å­˜åœ¨äºå“ˆå¸Œè¡¨ä¸­ã€‚å½“æˆ‘ä»¬å‘å“ˆå¸Œè¡¨å†™å…¥æ–°çš„æ•°æ®æ—¶ï¼Œå¦‚æœå‘ç”Ÿäº†å†²çªï¼Œå°±ä¼šå°†é”®å€¼å¯¹å†™å…¥åˆ°ä¸‹ä¸€ä¸ªç´¢å¼•ä¸ä¸ºç©ºçš„ä½ç½®ã€‚å½“éœ€è¦æŸ¥æ‰¾æŸä¸ªé”®å¯¹åº”çš„å€¼æ—¶ï¼Œä¼šä»ç´¢å¼•çš„ä½ç½®å¼€å§‹çº¿æ€§æ¢æµ‹æ•°ç»„ï¼Œæ‰¾åˆ°ç›®æ ‡é”®å€¼å¯¹æˆ–è€…é‡åˆ°ç©ºå†…å­˜å°±ç»“æŸã€‚

å¼€æ”¾å¯»å€æ³•ä¸­å¯¹æ€§èƒ½å½±å“æœ€å¤§çš„æ˜¯è£…è½½ç‡ï¼Œå®ƒæ˜¯è¡¨ä¸­å…ƒç´ çš„æ•°é‡ä¸è¡¨å¤§å°çš„æ¯”å€¼ã€‚éšç€è£…è½½å› å­çš„å¢åŠ ï¼Œçº¿æ€§æ¢æµ‹çš„å¹³å‡ç”¨æ—¶å°±ä¼šé€æ¸å¢åŠ ï¼Œè¿™ä¼šå½±å“å“ˆå¸Œè¡¨çš„è¯»å†™æ€§èƒ½ã€‚ä¸€èˆ¬è¾¾åˆ°70%åï¼Œå“ˆå¸Œè¡¨çš„æ€§èƒ½å°±ä¼šæ€¥å‰§ä¸‹é™ï¼Œè€Œä¸€æ—¦è¾¾åˆ°100%ï¼Œæ•´ä¸ªå“ˆå¸Œè¡¨å°±ä¼šå®Œå…¨å¤±æ•ˆï¼Œå› ä¸ºè¿™æ—¶æŸ¥æ‰¾å’Œæ’å…¥ä»»æ„å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦éƒ½æ¥åˆ°äº†Oï¼ˆnï¼‰ã€‚

2ï¼‰æ‹‰é“¾æ³•

å¤§éƒ¨åˆ†çš„ç¼–ç¨‹è¯­è¨€éƒ½æ˜¯æ‹‰é“¾æ³•æ¥å®ç°çš„å“ˆå¸Œè¡¨ã€‚å®ç°æ‹‰é“¾æ³•ä¸€èˆ¬ä¼šä½¿ç”¨æ•°ç»„åŠ ä¸Šé“¾è¡¨ï¼Œä¸€äº›ç¼–ç¨‹è¯­è¨€ä¼šåœ¨æ‹‰é“¾æ³•çš„å“ˆå¸Œä¸­å¼•å…¥çº¢é»‘æ ‘ä»¥ä¼˜åŒ–æ€§èƒ½ã€‚æ‹‰é“¾æ³•ä¸­æœ‰ä¸€ä¸ªæ¦‚å¿µå°±æ˜¯è£…è½½å› å­ï¼Œå³å…ƒç´ æ•°é‡ä¸æ¡¶æ•°é‡çš„æ¯”å€¼ï¼Œè£…è½½å› å­è¶Šå¤§ï¼Œå“ˆå¸Œè¡¨çš„è¯»å†™æ€§èƒ½å°±è¶Šå·®ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ä½¿ç”¨æ‹‰é“¾æ³•çš„å“ˆå¸Œè¡¨è£…è½½å› å­ä¸ä¼šè¶…è¿‡1ï¼Œå½“å“ˆå¸Œè¡¨çš„è£…è½½å› å­è¾ƒå¤§æ—¶ä¼šè§¦å‘å“ˆå¸Œè¡¨çš„æ‰©å®¹ï¼Œåˆ›å»ºæ›´å¤šçš„æ¡¶æ¥å­˜å‚¨å“ˆå¸Œä¸­çš„å…ƒç´ ï¼Œä¿è¯æ€§èƒ½ä¸ä¼šå‡ºç°ä¸¥é‡çš„ä¸‹é™ã€‚

<span style='color:red'>Goè¯­è¨€ä½¿ç”¨æ‹‰é“¾æ³•æ¥è§£å†³å“ˆå¸Œç¢°æ’çš„é—®é¢˜å»å®ç°å“ˆå¸Œè¡¨ï¼Œå®ƒçš„è®¿é—®ã€å†™å…¥å’Œåˆ é™¤ç­‰æ“ä½œéƒ½åœ¨ç¼–è¯‘æœŸé—´è½¬æ¢æˆäº†è¿è¡Œæ—¶çš„å‡½æ•°æˆ–è€…æ–¹æ³•ã€‚å“ˆå¸Œåœ¨æ¯ä¸€ä¸ªæ¡¶ä¸­å­˜å‚¨é”®å¯¹åº”å“ˆå¸Œçš„å‰å…«ä½ï¼Œå½“å¯¹å“ˆå¸Œè¿›è¡Œæ“ä½œæ—¶ï¼Œè¿™äº›tophashå°±æˆä¸ºå¯ä»¥å¸®åŠ©å“ˆå¸Œå¿«é€Ÿéå†æ¡¶ä¸­å…ƒç´ çš„ç¼“å­˜ã€‚</span>

<span style='color:red'>å“ˆå¸Œè¡¨çš„æ¯ä¸ªæ¡¶éƒ½åªèƒ½å­˜å‚¨8ä¸ªé”®å€¼å¯¹ï¼Œä¸€æ—¦å½“å‰å“ˆå¸Œçš„æŸä¸ªæ¡¶è¶…å‡º8ä¸ªï¼Œæ–°çš„é”®å€¼å¯¹å°±ä¼šå­˜å‚¨åˆ°å“ˆå¸Œçš„æº¢å‡ºæ¡¶ä¸­ã€‚éšç€é”®å€¼å¯¹æ•°é‡çš„å¢åŠ ï¼Œæº¢å‡ºæ¡¶çš„æ•°é‡å’Œå“ˆå¸Œçš„è£…è½½å› å­ä¹Ÿä¼šé€æ¸å‡é«˜ï¼Œè¶…è¿‡ä¸€å®šèŒƒå›´å°±ä¼šè§¦å‘æ‰©å®¹ï¼Œæ‰©å®¹ä¼šå°†æ¡¶çš„æ•°é‡ç¿»å€ï¼Œå…ƒç´ å†åˆ†é…çš„è¿‡ç¨‹ä¹Ÿæ˜¯è°ƒç”¨å†™æ“ä½œæ—¶å¢é‡è¿›è¡Œçš„ï¼Œä¸ä¼šé€ æˆæ€§èƒ½çš„ç¬æ—¶å·¨å¤§æŠ–åŠ¨ã€‚</span>

### 1ï¼‰æ•°æ®ç»“æ„

```go
type hmap struct {
	count     int
	flags     uint8
	B         uint8
	noverflow uint16
	hash0     uint32

	buckets    unsafe.Pointer
	oldbuckets unsafe.Pointer
	nevacuate  uintptr

	extra *mapextra
}

type mapextra struct {
	overflow    *[]*bmap
	oldoverflow *[]*bmap
	nextOverflow *bmap
}
```

1. `count` è¡¨ç¤ºå½“å‰å“ˆå¸Œè¡¨ä¸­çš„å…ƒç´ æ•°é‡ï¼›
2. `B` è¡¨ç¤ºå½“å‰å“ˆå¸Œè¡¨æŒæœ‰çš„ `buckets` æ•°é‡ï¼Œä½†æ˜¯å› ä¸ºå“ˆå¸Œè¡¨ä¸­æ¡¶çš„æ•°é‡éƒ½ 2 çš„å€æ•°ï¼Œæ‰€ä»¥è¯¥å­—æ®µä¼šå­˜å‚¨å¯¹æ•°ï¼Œä¹Ÿå°±æ˜¯ `len(buckets) == 2^B`ï¼›
3. `hash0` æ˜¯å“ˆå¸Œçš„ç§å­ï¼Œå®ƒèƒ½ä¸ºå“ˆå¸Œå‡½æ•°çš„ç»“æœå¼•å…¥éšæœºæ€§ï¼Œè¿™ä¸ªå€¼åœ¨åˆ›å»ºå“ˆå¸Œè¡¨æ—¶ç¡®å®šï¼Œå¹¶åœ¨è°ƒç”¨å“ˆå¸Œå‡½æ•°æ—¶ä½œä¸ºå‚æ•°ä¼ å…¥ï¼›
4. `oldbuckets` æ˜¯å“ˆå¸Œåœ¨æ‰©å®¹æ—¶ç”¨äºä¿å­˜ä¹‹å‰ `buckets` çš„å­—æ®µï¼Œå®ƒçš„å¤§å°æ˜¯å½“å‰ `buckets` çš„ä¸€åŠï¼›

![](../image/hmap-and-buckets.png)

- å½“æ¡¶çš„æ•°é‡å°äº 2424 æ—¶ï¼Œç”±äºæ•°æ®è¾ƒå°‘ã€ä½¿ç”¨æº¢å‡ºæ¡¶çš„å¯èƒ½æ€§è¾ƒä½ï¼Œä¼šçœç•¥åˆ›å»ºçš„è¿‡ç¨‹ä»¥å‡å°‘é¢å¤–å¼€é”€ï¼›
- å½“æ¡¶çš„æ•°é‡å¤šäº 2424 æ—¶ï¼Œä¼šé¢å¤–åˆ›å»º 2ğµâˆ’42Bâˆ’4 ä¸ªæº¢å‡ºæ¡¶ï¼›

### 2ï¼‰æŸ¥æ‰¾è¿‡ç¨‹

èµ‹å€¼è¯­å¥å·¦ä¾§æ¥å—å‚æ•°çš„ä¸ªæ•°ä¼šå†³å®šä½¿ç”¨çš„è¿è¡Œæ—¶æ–¹æ³•ï¼š

- å½“æ¥å—ä¸€ä¸ªå‚æ•°æ—¶ï¼Œä¼šä½¿ç”¨ [`runtime.mapaccess1`](https://draveness.me/golang/tree/runtime.mapaccess1)ï¼Œè¯¥å‡½æ•°ä»…ä¼šè¿”å›ä¸€ä¸ªæŒ‡å‘ç›®æ ‡å€¼çš„æŒ‡é’ˆï¼›
- å½“æ¥å—ä¸¤ä¸ªå‚æ•°æ—¶ï¼Œä¼šä½¿ç”¨ [`runtime.mapaccess2`](https://draveness.me/golang/tree/runtime.mapaccess2)ï¼Œé™¤äº†è¿”å›ç›®æ ‡å€¼ä¹‹å¤–ï¼Œå®ƒè¿˜ä¼šè¿”å›ä¸€ä¸ªç”¨äºè¡¨ç¤ºå½“å‰é”®å¯¹åº”çš„å€¼æ˜¯å¦å­˜åœ¨çš„ `bool` å€¼ï¼š

[`runtime.mapaccess1`](https://draveness.me/golang/tree/runtime.mapaccess1) ä¼šå…ˆé€šè¿‡å“ˆå¸Œè¡¨è®¾ç½®çš„å“ˆå¸Œå‡½æ•°ã€ç§å­è·å–å½“å‰é”®å¯¹åº”çš„å“ˆå¸Œï¼Œå†é€šè¿‡ [`runtime.bucketMask`](https://draveness.me/golang/tree/runtime.bucketMask) å’Œ [`runtime.add`](https://draveness.me/golang/tree/runtime.add) æ‹¿åˆ°è¯¥é”®å€¼å¯¹æ‰€åœ¨çš„æ¡¶åºå·å’Œå“ˆå¸Œé«˜ä½çš„ 8 ä½æ•°å­—ã€‚

```go
func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	alg := t.key.alg
	hash := alg.hash(key, uintptr(h.hash0))
	m := bucketMask(h.B)
	b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
	top := tophash(hash)
bucketloop:
	for ; b != nil; b = b.overflow(t) {
		for i := uintptr(0); i < bucketCnt; i++ {
			if b.tophash[i] != top {
				if b.tophash[i] == emptyRest {
					break bucketloop
				}
				continue
			}
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
			if alg.equal(key, k) {
				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
				return v
			}
		}
	}
	return unsafe.Pointer(&zeroVal[0])
}
```

![](../image/hashmap-mapaccess.png)

å“ˆå¸Œä¼šä¾æ¬¡éå†æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ä¸­çš„æ•°æ®ï¼Œå®ƒä¼šå…ˆæ¯”è¾ƒå“ˆå¸Œçš„é«˜ 8 ä½å’Œæ¡¶ä¸­å­˜å‚¨çš„ `tophash`ï¼Œåæ¯”è¾ƒä¼ å…¥çš„å’Œæ¡¶ä¸­çš„å€¼ä»¥åŠ é€Ÿæ•°æ®çš„è¯»å†™ã€‚ç”¨äºé€‰æ‹©æ¡¶åºå·çš„æ˜¯å“ˆå¸Œçš„æœ€ä½å‡ ä½ï¼Œè€Œç”¨äºåŠ é€Ÿè®¿é—®çš„æ˜¯å“ˆå¸Œçš„é«˜ 8 ä½ï¼Œè¿™ç§è®¾è®¡èƒ½å¤Ÿå‡å°‘åŒä¸€ä¸ªæ¡¶ä¸­æœ‰å¤§é‡ç›¸ç­‰ `tophash` çš„æ¦‚ç‡å½±å“æ€§èƒ½ã€‚

æ¯ä¸€ä¸ªæ¡¶éƒ½æ˜¯ä¸€æ•´ç‰‡çš„å†…å­˜ç©ºé—´ï¼Œå½“å‘ç°æ¡¶ä¸­çš„ `tophash` ä¸ä¼ å…¥é”®çš„ `tophash` åŒ¹é…ä¹‹åï¼Œæˆ‘ä»¬ä¼šé€šè¿‡æŒ‡é’ˆå’Œåç§»é‡è·å–å“ˆå¸Œä¸­å­˜å‚¨çš„é”® `keys[0]` å¹¶ä¸ `key` æ¯”è¾ƒï¼Œå¦‚æœä¸¤è€…ç›¸åŒå°±ä¼šè·å–ç›®æ ‡å€¼çš„æŒ‡é’ˆ `values[0]` å¹¶è¿”å›ã€‚

### 3ï¼‰å†™å…¥è¿‡ç¨‹

é¦–å…ˆæ˜¯å‡½æ•°ä¼šæ ¹æ®ä¼ å…¥çš„é”®æ‹¿åˆ°å¯¹åº”çš„å“ˆå¸Œå’Œæ¡¶ï¼Œç„¶åé€šè¿‡éå†æ¯”è¾ƒæ¡¶ä¸­å­˜å‚¨çš„ `tophash` å’Œé”®çš„å“ˆå¸Œï¼Œå¦‚æœæ‰¾åˆ°äº†ç›¸åŒç»“æœå°±ä¼šè¿”å›ç›®æ ‡ä½ç½®çš„åœ°å€ã€‚å…¶ä¸­ `inserti` è¡¨ç¤ºç›®æ ‡å…ƒç´ çš„åœ¨æ¡¶ä¸­çš„ç´¢å¼•ï¼Œ`insertk` å’Œ `val` åˆ†åˆ«è¡¨ç¤ºé”®å€¼å¯¹çš„åœ°å€ï¼Œè·å¾—ç›®æ ‡åœ°å€ä¹‹åä¼šé€šè¿‡ç®—æœ¯è®¡ç®—å¯»å€è·å¾—é”®å€¼å¯¹ `k` å’Œ `val`ã€‚

ä¸Šè¿°çš„ for å¾ªç¯ä¼šä¾æ¬¡éå†æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ä¸­å­˜å‚¨çš„æ•°æ®ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¼šåˆ†åˆ«åˆ¤æ–­ `tophash` æ˜¯å¦ç›¸ç­‰ã€`key` æ˜¯å¦ç›¸ç­‰ï¼Œéå†ç»“æŸåä¼šä»å¾ªç¯ä¸­è·³å‡ºã€‚

```go
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	alg := t.key.alg
	hash := alg.hash(key, uintptr(h.hash0))

	h.flags ^= hashWriting

again:
	bucket := hash & bucketMask(h.B)
	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
	top := tophash(hash)
	var inserti *uint8
	var insertk unsafe.Pointer
	var val unsafe.Pointer
bucketloop:
	for {
		for i := uintptr(0); i < bucketCnt; i++ {
			if b.tophash[i] != top {
				if isEmpty(b.tophash[i]) && inserti == nil {
					inserti = &b.tophash[i]
					insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
					val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
				}
				if b.tophash[i] == emptyRest {
					break bucketloop
				}
				continue
			}
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
			if !alg.equal(key, k) {
				continue
			}
			val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
			goto done
		}
		ovf := b.overflow(t)
		if ovf == nil {
			break
		}
		b = ovf
	}
```

![](../image/hashmap-overflow-bucket.png)

å¦‚æœå½“å‰æ¡¶å·²ç»æ»¡äº†ï¼Œå“ˆå¸Œä¼šè°ƒç”¨ [`runtime.hmap.newoverflow`](https://draveness.me/golang/tree/runtime.hmap.newoverflow) åˆ›å»ºæ–°æ¡¶æˆ–è€…ä½¿ç”¨ [`runtime.hmap`](https://draveness.me/golang/tree/runtime.hmap) é¢„å…ˆåœ¨ `noverflow` ä¸­åˆ›å»ºå¥½çš„æ¡¶æ¥ä¿å­˜æ•°æ®ï¼Œæ–°åˆ›å»ºçš„æ¡¶ä¸ä»…ä¼šè¢«è¿½åŠ åˆ°å·²æœ‰æ¡¶çš„æœ«å°¾ï¼Œè¿˜ä¼šå¢åŠ å“ˆå¸Œè¡¨çš„ `noverflow` è®¡æ•°å™¨ã€‚

```go
	if inserti == nil {
		newb := h.newoverflow(t, b)
		inserti = &newb.tophash[0]
		insertk = add(unsafe.Pointer(newb), dataOffset)
		val = add(insertk, bucketCnt*uintptr(t.keysize))
	}

	typedmemmove(t.key, insertk, key)
	*inserti = top
	h.count++

done:
	return val
}
```

### 4ï¼‰æ‰©å®¹

[`runtime.mapassign`](https://draveness.me/golang/tree/runtime.mapassign) å‡½æ•°ä¼šåœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µå‘ç”Ÿæ—¶è§¦å‘å“ˆå¸Œçš„æ‰©å®¹ï¼š

1. è£…è½½å› å­å·²ç»è¶…è¿‡ 6.5ï¼›
2. å“ˆå¸Œä½¿ç”¨äº†å¤ªå¤šæº¢å‡ºæ¡¶ï¼›

```go
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	...
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
		hashGrow(t, h)
		goto again
	}
	...
}
```

ä¸è¿‡å› ä¸º Go è¯­è¨€å“ˆå¸Œçš„æ‰©å®¹ä¸æ˜¯ä¸€ä¸ªåŸå­çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥ [`runtime.mapassign`](https://draveness.me/golang/tree/runtime.mapassign) è¿˜éœ€è¦åˆ¤æ–­å½“å‰å“ˆå¸Œæ˜¯å¦å·²ç»å¤„äºæ‰©å®¹çŠ¶æ€ï¼Œé¿å…äºŒæ¬¡æ‰©å®¹é€ æˆæ··ä¹±ã€‚

æ ¹æ®è§¦å‘çš„æ¡ä»¶ä¸åŒæ‰©å®¹çš„æ–¹å¼åˆ†æˆä¸¤ç§ï¼Œå¦‚æœè¿™æ¬¡æ‰©å®¹æ˜¯æº¢å‡ºçš„æ¡¶å¤ªå¤šå¯¼è‡´çš„ï¼Œé‚£ä¹ˆè¿™æ¬¡æ‰©å®¹å°±æ˜¯ç­‰é‡æ‰©å®¹ `sameSizeGrow`ï¼Œ`sameSizeGrow` æ˜¯ä¸€ç§ç‰¹æ®Šæƒ…å†µä¸‹å‘ç”Ÿçš„æ‰©å®¹ï¼Œå½“æˆ‘ä»¬æŒç»­å‘å“ˆå¸Œä¸­æ’å…¥æ•°æ®å¹¶å°†å®ƒä»¬å…¨éƒ¨åˆ é™¤æ—¶ï¼Œå¦‚æœå“ˆå¸Œè¡¨ä¸­çš„æ•°æ®é‡æ²¡æœ‰è¶…è¿‡é˜ˆå€¼ï¼Œå°±ä¼šä¸æ–­ç§¯ç´¯æº¢å‡ºæ¡¶é€ æˆç¼“æ…¢çš„å†…å­˜æ³„æ¼[4](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:4)ã€‚[runtime: limit the number of map overflow buckets](https://github.com/golang/go/commit/9980b70cb460f27907a003674ab1b9bea24a847c) å¼•å…¥äº† `sameSizeGrow` é€šè¿‡å¤ç”¨å·²æœ‰çš„å“ˆå¸Œæ‰©å®¹æœºåˆ¶è§£å†³è¯¥é—®é¢˜ï¼Œä¸€æ—¦å“ˆå¸Œä¸­å‡ºç°äº†è¿‡å¤šçš„æº¢å‡ºæ¡¶ï¼Œå®ƒä¼šåˆ›å»ºæ–°æ¡¶ä¿å­˜æ•°æ®ï¼Œåƒåœ¾å›æ”¶ä¼šæ¸…ç†è€çš„æº¢å‡ºæ¡¶å¹¶é‡Šæ”¾å†…å­˜[5](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:5)ã€‚

```go
func hashGrow(t *maptype, h *hmap) {
	bigger := uint8(1)
	if !overLoadFactor(h.count+1, h.B) {
		bigger = 0
		h.flags |= sameSizeGrow
	}
	oldbuckets := h.buckets
	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)

	h.B += bigger
	h.flags = flags
	h.oldbuckets = oldbuckets
	h.buckets = newbuckets
	h.nevacuate = 0
	h.noverflow = 0

	h.extra.oldoverflow = h.extra.overflow
	h.extra.overflow = nil
	h.extra.nextOverflow = nextOverflow
}
```

å“ˆå¸Œåœ¨æ‰©å®¹çš„è¿‡ç¨‹ä¸­ä¼šé€šè¿‡ [`runtime.makeBucketArray`](https://draveness.me/golang/tree/runtime.makeBucketArray) åˆ›å»ºä¸€ç»„æ–°æ¡¶å’Œé¢„åˆ›å»ºçš„æº¢å‡ºæ¡¶ï¼Œéšåå°†åŸæœ‰çš„æ¡¶æ•°ç»„è®¾ç½®åˆ° `oldbuckets` ä¸Šå¹¶å°†æ–°çš„ç©ºæ¡¶è®¾ç½®åˆ° `buckets` ä¸Šï¼Œæº¢å‡ºæ¡¶ä¹Ÿä½¿ç”¨äº†ç›¸åŒçš„é€»è¾‘æ›´æ–°ï¼Œä¸‹å›¾å±•ç¤ºäº†è§¦å‘æ‰©å®¹åçš„å“ˆå¸Œï¼š

![](../image/hashmap-hashgrow.png)

æˆ‘ä»¬åœ¨ [`runtime.hashGrow`](https://draveness.me/golang/tree/runtime.hashGrow) ä¸­è¿˜çœ‹ä¸å‡ºæ¥ç­‰é‡æ‰©å®¹å’Œç¿»å€æ‰©å®¹çš„å¤ªå¤šåŒºåˆ«ï¼Œç­‰é‡æ‰©å®¹åˆ›å»ºçš„æ–°æ¡¶æ•°é‡åªæ˜¯å’Œæ—§æ¡¶ä¸€æ ·ï¼Œè¯¥å‡½æ•°ä¸­åªæ˜¯åˆ›å»ºäº†æ–°çš„æ¡¶ï¼Œå¹¶æ²¡æœ‰å¯¹æ•°æ®è¿›è¡Œæ‹·è´å’Œè½¬ç§»ã€‚å“ˆå¸Œè¡¨çš„æ•°æ®è¿ç§»çš„è¿‡ç¨‹åœ¨æ˜¯ [`runtime.evacuate`](https://draveness.me/golang/tree/runtime.evacuate) ä¸­å®Œæˆçš„ï¼Œå®ƒä¼šå¯¹ä¼ å…¥æ¡¶ä¸­çš„å…ƒç´ è¿›è¡Œå†åˆ†é…ã€‚

```go
func evacuate(t *maptype, h *hmap, oldbucket uintptr) {
	b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
	newbit := h.noldbuckets()
	if !evacuated(b) {
		var xy [2]evacDst
		x := &xy[0]
		x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
		x.k = add(unsafe.Pointer(x.b), dataOffset)
		x.v = add(x.k, bucketCnt*uintptr(t.keysize))

		y := &xy[1]
		y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
		y.k = add(unsafe.Pointer(y.b), dataOffset)
		y.v = add(y.k, bucketCnt*uintptr(t.keysize))
```

[`runtime.evacuate`](https://draveness.me/golang/tree/runtime.evacuate) ä¼šå°†ä¸€ä¸ªæ—§æ¡¶ä¸­çš„æ•°æ®åˆ†æµåˆ°ä¸¤ä¸ªæ–°æ¡¶ï¼Œæ‰€ä»¥å®ƒä¼šåˆ›å»ºä¸¤ä¸ªç”¨äºä¿å­˜åˆ†é…ä¸Šä¸‹æ–‡çš„ [`runtime.evacDst`](https://draveness.me/golang/tree/runtime.evacDst) ç»“æ„ä½“ï¼Œè¿™ä¸¤ä¸ªç»“æ„ä½“åˆ†åˆ«æŒ‡å‘äº†ä¸€ä¸ªæ–°æ¡¶ï¼š

![](../image/hashmap-evacuate-destination.png)

å¦‚æœè¿™æ˜¯ç­‰é‡æ‰©å®¹ï¼Œé‚£ä¹ˆæ—§æ¡¶ä¸æ–°æ¡¶ä¹‹é—´æ˜¯ä¸€å¯¹ä¸€çš„å…³ç³»ï¼Œæ‰€ä»¥ä¸¤ä¸ª [`runtime.evacDst`](https://draveness.me/golang/tree/runtime.evacDst) åªä¼šåˆå§‹åŒ–ä¸€ä¸ªã€‚è€Œå½“å“ˆå¸Œè¡¨çš„å®¹é‡ç¿»å€æ—¶ï¼Œæ¯ä¸ªæ—§æ¡¶çš„å…ƒç´ ä¼šéƒ½åˆ†æµåˆ°æ–°åˆ›å»ºçš„ä¸¤ä¸ªæ¡¶ä¸­ï¼Œè¿™é‡Œä»”ç»†åˆ†æä¸€ä¸‹åˆ†æµå…ƒç´ çš„é€»è¾‘ï¼š

```go
		for ; b != nil; b = b.overflow(t) {
			k := add(unsafe.Pointer(b), dataOffset)
			v := add(k, bucketCnt*uintptr(t.keysize))
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
				top := b.tophash[i]
				k2 := k
				var useY uint8
				hash := t.key.alg.hash(k2, uintptr(h.hash0))
				if hash&newbit != 0 {
					useY = 1
				}
				b.tophash[i] = evacuatedX + useY
				dst := &xy[useY]

				if dst.i == bucketCnt {
					dst.b = h.newoverflow(t, dst.b)
					dst.i = 0
					dst.k = add(unsafe.Pointer(dst.b), dataOffset)
					dst.v = add(dst.k, bucketCnt*uintptr(t.keysize))
				}
				dst.b.tophash[dst.i&(bucketCnt-1)] = top
				typedmemmove(t.key, dst.k, k)
				typedmemmove(t.elem, dst.v, v)
				dst.i++
				dst.k = add(dst.k, uintptr(t.keysize))
				dst.v = add(dst.v, uintptr(t.valuesize))
			}
		}
		...
}

```

åªä½¿ç”¨å“ˆå¸Œå‡½æ•°æ˜¯ä¸èƒ½å®šä½åˆ°å…·ä½“æŸä¸€ä¸ªæ¡¶çš„ï¼Œå“ˆå¸Œå‡½æ•°åªä¼šè¿”å›å¾ˆé•¿çš„å“ˆå¸Œï¼Œä¾‹å¦‚ï¼š`b72bfae3f3285244c4732ce457cca823bc189e0b`ï¼Œæˆ‘ä»¬è¿˜éœ€ä¸€äº›æ–¹æ³•å°†å“ˆå¸Œæ˜ å°„åˆ°å…·ä½“çš„æ¡¶ä¸Šã€‚æˆ‘ä»¬ä¸€èˆ¬éƒ½ä¼šä½¿ç”¨å–æ¨¡æˆ–è€…ä½æ“ä½œæ¥è·å–æ¡¶çš„ç¼–å·ï¼Œå‡å¦‚å½“å‰å“ˆå¸Œä¸­åŒ…å« 4 ä¸ªæ¡¶ï¼Œé‚£ä¹ˆå®ƒçš„æ¡¶æ©ç å°±æ˜¯ 0b11(3)ï¼Œä½¿ç”¨ä½æ“ä½œå°±ä¼šå¾—åˆ° 3ï¼Œ æˆ‘ä»¬å°±ä¼šåœ¨ 3 å·æ¡¶ä¸­å­˜å‚¨è¯¥æ•°æ®ï¼š

å¦‚æœæ–°çš„å“ˆå¸Œè¡¨æœ‰ 8 ä¸ªæ¡¶ï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼ŒåŸæ¥ç»è¿‡æ¡¶æ©ç  `0b11` ç»“æœä¸º 3 çš„æ•°æ®ä¼šå› ä¸ºæ¡¶æ©ç å¢åŠ äº†ä¸€ä½å˜æˆ `0b111` è€Œåˆ†æµåˆ°æ–°çš„ 3 å·å’Œ 7 å·æ¡¶ï¼Œæ‰€æœ‰æ•°æ®ä¹Ÿéƒ½ä¼šè¢« [`runtime.typedmemmove`](https://draveness.me/golang/tree/runtime.typedmemmove) æ‹·è´åˆ°ç›®æ ‡æ¡¶ä¸­ï¼š

![](../image/hashmap-bucket-evacuate.png)

[`runtime.evacuate`](https://draveness.me/golang/tree/runtime.evacuate) æœ€åä¼šè°ƒç”¨ [`runtime.advanceEvacuationMark`](https://draveness.me/golang/tree/runtime.advanceEvacuationMark) å¢åŠ å“ˆå¸Œçš„ `nevacuate` è®¡æ•°å™¨å¹¶åœ¨æ‰€æœ‰çš„æ—§æ¡¶éƒ½è¢«åˆ†æµåæ¸…ç©ºå“ˆå¸Œçš„ `oldbuckets` å’Œ `oldoverflow`ï¼š

```go
func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr) {
	h.nevacuate++
	stop := h.nevacuate + 1024
	if stop > newbit {
		stop = newbit
	}
	for h.nevacuate != stop && bucketEvacuated(t, h, h.nevacuate) {
		h.nevacuate++
	}
	if h.nevacuate == newbit { // newbit == # of oldbuckets
		h.oldbuckets = nil
		if h.extra != nil {
			h.extra.oldoverflow = nil
		}
		h.flags &^= sameSizeGrow
	}
}
```

ä¹‹å‰åœ¨åˆ†æå“ˆå¸Œè¡¨è®¿é—®å‡½æ•° [`runtime.mapaccess1`](https://draveness.me/golang/tree/runtime.mapaccess1) æ—¶å…¶å®çœç•¥äº†æ‰©å®¹æœŸé—´è·å–é”®å€¼å¯¹çš„é€»è¾‘ï¼Œå½“å“ˆå¸Œè¡¨çš„ `oldbuckets` å­˜åœ¨æ—¶ï¼Œä¼šå…ˆå®šä½åˆ°æ—§æ¡¶å¹¶åœ¨è¯¥æ¡¶æ²¡æœ‰è¢«åˆ†æµæ—¶ä»ä¸­è·å–é”®å€¼å¯¹ã€‚

```go
func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	...
	alg := t.key.alg
	hash := alg.hash(key, uintptr(h.hash0))
	m := bucketMask(h.B)
	b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
	if c := h.oldbuckets; c != nil {
		if !h.sameSizeGrow() {
			m >>= 1
		}
		oldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))
		if !evacuated(oldb) {
			b = oldb
		}
	}
bucketloop:
	...
}
```

å› ä¸ºæ—§æ¡¶ä¸­çš„å…ƒç´ è¿˜æ²¡æœ‰è¢« [`runtime.evacuate`](https://draveness.me/golang/tree/runtime.evacuate) å‡½æ•°åˆ†æµï¼Œå…¶ä¸­è¿˜ä¿å­˜ç€æˆ‘ä»¬éœ€è¦ä½¿ç”¨çš„æ•°æ®ï¼Œæ‰€ä»¥æ—§æ¡¶ä¼šæ›¿ä»£æ–°åˆ›å»ºçš„ç©ºæ¡¶æä¾›æ•°æ®ã€‚

æˆ‘ä»¬åœ¨ [`runtime.mapassign`](https://draveness.me/golang/tree/runtime.mapassign) å‡½æ•°ä¸­ä¹Ÿçœç•¥äº†ä¸€æ®µé€»è¾‘ï¼Œå½“å“ˆå¸Œè¡¨æ­£åœ¨å¤„äºæ‰©å®¹çŠ¶æ€æ—¶ï¼Œæ¯æ¬¡å‘å“ˆå¸Œè¡¨å†™å…¥å€¼æ—¶éƒ½ä¼šè§¦å‘ [`runtime.growWork`](https://draveness.me/golang/tree/runtime.growWork) å¢é‡æ‹·è´å“ˆå¸Œè¡¨ä¸­çš„å†…å®¹ï¼š

```go
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	...
again:
	bucket := hash & bucketMask(h.B)
	if h.growing() {
		growWork(t, h, bucket)
	}
	...
}
```

å½“ç„¶é™¤äº†å†™å…¥æ“ä½œä¹‹å¤–ï¼Œåˆ é™¤æ“ä½œä¹Ÿä¼šåœ¨å“ˆå¸Œè¡¨æ‰©å®¹æœŸé—´è§¦å‘ [`runtime.growWork`](https://draveness.me/golang/tree/runtime.growWork)ï¼Œè§¦å‘çš„æ–¹å¼å’Œä»£ç ä¸è¿™é‡Œçš„é€»è¾‘å‡ ä¹å®Œå…¨ç›¸åŒï¼Œéƒ½æ˜¯è®¡ç®—å½“å‰å€¼æ‰€åœ¨çš„æ¡¶ï¼Œç„¶åæ‹·è´æ¡¶ä¸­çš„å…ƒç´ ã€‚

å“ˆå¸Œåœ¨å­˜å‚¨å…ƒç´ è¿‡å¤šæ—¶ä¼šè§¦å‘æ‰©å®¹æ“ä½œï¼Œæ¯æ¬¡éƒ½ä¼šå°†æ¡¶çš„æ•°é‡ç¿»å€ï¼Œæ‰©å®¹è¿‡ç¨‹ä¸æ˜¯åŸå­çš„ï¼Œè€Œæ˜¯é€šè¿‡ [`runtime.growWork`](https://draveness.me/golang/tree/runtime.growWork) å¢é‡è§¦å‘çš„ï¼Œåœ¨æ‰©å®¹æœŸé—´è®¿é—®å“ˆå¸Œè¡¨æ—¶ä¼šä½¿ç”¨æ—§æ¡¶ï¼Œå‘å“ˆå¸Œè¡¨å†™å…¥æ•°æ®æ—¶ä¼šè§¦å‘æ—§æ¡¶å…ƒç´ çš„åˆ†æµã€‚é™¤äº†è¿™ç§æ­£å¸¸çš„æ‰©å®¹ä¹‹å¤–ï¼Œä¸ºäº†è§£å†³å¤§é‡å†™å…¥ã€åˆ é™¤é€ æˆçš„å†…å­˜æ³„æ¼é—®é¢˜ï¼Œå“ˆå¸Œå¼•å…¥äº† `sameSizeGrow` è¿™ä¸€æœºåˆ¶ï¼Œåœ¨å‡ºç°è¾ƒå¤šæº¢å‡ºæ¡¶æ—¶ä¼šæ•´ç†å“ˆå¸Œçš„å†…å­˜å‡å°‘ç©ºé—´çš„å ç”¨ã€‚

### 5ï¼‰åˆ é™¤

å¦‚æœæƒ³è¦åˆ é™¤å“ˆå¸Œä¸­çš„å…ƒç´ ï¼Œå°±éœ€è¦ä½¿ç”¨ Go è¯­è¨€ä¸­çš„ `delete` å…³é”®å­—ï¼Œè¿™ä¸ªå…³é”®å­—çš„å”¯ä¸€ä½œç”¨å°±æ˜¯å°†æŸä¸€ä¸ªé”®å¯¹åº”çš„å…ƒç´ ä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤ï¼Œæ— è®ºæ˜¯è¯¥é”®å¯¹åº”çš„å€¼æ˜¯å¦å­˜åœ¨ï¼Œè¿™ä¸ªå†…å»ºçš„å‡½æ•°éƒ½ä¸ä¼šè¿”å›ä»»ä½•çš„ç»“æœã€‚

![](../image/hashmap-delete.png)

```go
func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {
	...
	if h.growing() {
		growWork(t, h, bucket)
	}
	...
search:
	for ; b != nil; b = b.overflow(t) {
		for i := uintptr(0); i < bucketCnt; i++ {
			if b.tophash[i] != top {
				if b.tophash[i] == emptyRest {
					break search
				}
				continue
			}
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
			k2 := k
			if !alg.equal(key, k2) {
				continue
			}
			*(*unsafe.Pointer)(k) = nil
			v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
			*(*unsafe.Pointer)(v) = nil
			b.tophash[i] = emptyOne
			...
		}
	}
}
```

### 6ï¼‰for range éå†map

è¡¨æ—¶ï¼Œç¼–è¯‘å™¨ä¼šä½¿ç”¨ [`runtime.mapiterinit`](https://draveness.me/golang/tree/runtime.mapiterinit) å’Œ [`runtime.mapiternext`](https://draveness.me/golang/tree/runtime.mapiternext) ä¸¤ä¸ªè¿è¡Œæ—¶å‡½æ•°é‡å†™åŸå§‹çš„ for-range å¾ªç¯ï¼š

```go
ha := a
hit := hiter(n.Type)
th := hit.Type
mapiterinit(typename(t), ha, &hit)
for ; hit.key != nil; mapiternext(&hit) {
    key := *hit.key
    val := *hit.val
}
```

ä¸Šè¿°ä»£ç æ˜¯å±•å¼€ `for key, val := range hash {}` åçš„ç»“æœï¼Œåœ¨ [`cmd/compile/internal/gc.walkrange`](https://draveness.me/golang/tree/cmd/compile/internal/gc.walkrange) å¤„ç† `TMAP` èŠ‚ç‚¹æ—¶ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ® range è¿”å›å€¼çš„æ•°é‡åœ¨å¾ªç¯ä½“ä¸­æ’å…¥éœ€è¦çš„èµ‹å€¼è¯­å¥ï¼š

![](../image/2020-01-17-15792766877639-golang-range-map.png)

è¿™ä¸‰ç§ä¸åŒçš„æƒ…å†µåˆ†åˆ«å‘å¾ªç¯ä½“æ’å…¥äº†ä¸åŒçš„èµ‹å€¼è¯­å¥ã€‚éå†å“ˆå¸Œè¡¨æ—¶ä¼šä½¿ç”¨ [`runtime.mapiterinit`](https://draveness.me/golang/tree/runtime.mapiterinit) å‡½æ•°åˆå§‹åŒ–éå†å¼€å§‹çš„å…ƒç´ ï¼š

```go
func mapiterinit(t *maptype, h *hmap, it *hiter) {
	it.t = t
	it.h = h
	it.B = h.B
	it.buckets = h.buckets

	r := uintptr(fastrand())
	it.startBucket = r & bucketMask(h.B)
	it.offset = uint8(r >> h.B & (bucketCnt - 1))
	it.bucket = it.startBucket
	mapiternext(it)
}
```

è¯¥å‡½æ•°ä¼šåˆå§‹åŒ– [`runtime.hiter`](https://draveness.me/golang/tree/runtime.hiter) ç»“æ„ä½“ä¸­çš„å­—æ®µï¼Œå¹¶é€šè¿‡ [`runtime.fastrand`](https://draveness.me/golang/tree/runtime.fastrand) ç”Ÿæˆä¸€ä¸ªéšæœºæ•°å¸®åŠ©æˆ‘ä»¬éšæœºé€‰æ‹©ä¸€ä¸ªéå†æ¡¶çš„èµ·å§‹ä½ç½®ã€‚Go å›¢é˜Ÿåœ¨è®¾è®¡å“ˆå¸Œè¡¨çš„éå†æ—¶å°±ä¸æƒ³è®©ä½¿ç”¨è€…ä¾èµ–å›ºå®šçš„éå†é¡ºåºï¼Œæ‰€ä»¥å¼•å…¥äº†éšæœºæ•°ä¿è¯éå†çš„éšæœºæ€§ã€‚

éå†å“ˆå¸Œä¼šä½¿ç”¨ [`runtime.mapiternext`](https://draveness.me/golang/tree/runtime.mapiternext)ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œç®€åŒ–äº†å¾ˆå¤šé€»è¾‘ï¼Œçœå»äº†ä¸€äº›è¾¹ç•Œæ¡ä»¶ä»¥åŠå“ˆå¸Œè¡¨æ‰©å®¹æ—¶çš„å…¼å®¹æ“ä½œï¼Œè¿™é‡Œåªéœ€è¦å…³æ³¨å¤„ç†éå†é€»è¾‘çš„æ ¸å¿ƒä»£ç ï¼Œæˆ‘ä»¬ä¼šå°†è¯¥å‡½æ•°åˆ†æˆæ¡¶çš„é€‰æ‹©å’Œæ¡¶å†…å…ƒç´ çš„éå†ä¸¤éƒ¨åˆ†ï¼Œé¦–å…ˆæ˜¯æ¡¶çš„é€‰æ‹©è¿‡ç¨‹ï¼š

```go
func mapiternext(it *hiter) {
	h := it.h
	t := it.t
	bucket := it.bucket
	b := it.bptr
	i := it.i
	alg := t.key.alg

next:
	if b == nil {
		if bucket == it.startBucket && it.wrapped {
			it.key = nil
			it.value = nil
			return
		}
		b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize)))
		bucket++
		if bucket == bucketShift(it.B) {
			bucket = 0
			it.wrapped = true
		}
		i = 0
	}
```

è¿™æ®µä»£ç ä¸»è¦æœ‰ä¸¤ä¸ªä½œç”¨ï¼š

1. åœ¨å¾…éå†çš„æ¡¶ä¸ºç©ºæ—¶ï¼Œé€‰æ‹©éœ€è¦éå†çš„æ–°æ¡¶ï¼›
2. åœ¨ä¸å­˜åœ¨å¾…éå†çš„æ¡¶æ—¶ã€‚è¿”å› `(nil, nil)` é”®å€¼å¯¹å¹¶ä¸­æ­¢éå†ï¼›

[`runtime.mapiternext`](https://draveness.me/golang/tree/runtime.mapiternext) å‰©ä½™ä»£ç çš„ä½œç”¨æ˜¯ä»æ¡¶ä¸­æ‰¾åˆ°ä¸‹ä¸€ä¸ªéå†çš„å…ƒç´ ï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹éƒ½ä¼šç›´æ¥æ“ä½œå†…å­˜è·å–ç›®æ ‡é”®å€¼çš„å†…å­˜åœ°å€ï¼Œä¸è¿‡å¦‚æœå“ˆå¸Œè¡¨å¤„äºæ‰©å®¹æœŸé—´å°±ä¼šè°ƒç”¨ [`runtime.mapaccessK`](https://draveness.me/golang/tree/runtime.mapaccessK) è·å–é”®å€¼å¯¹ï¼š

```go
for ; i < bucketCnt; i++ {
		offi := (i + it.offset) & (bucketCnt - 1)
		k := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize))
		v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.valuesize))
		if (b.tophash[offi] != evacuatedX && b.tophash[offi] != evacuatedY) ||
			!(t.reflexivekey() || alg.equal(k, k)) {
			it.key = k
			it.value = v
		} else {
			rk, rv := mapaccessK(t, h, k)
			it.key = rk
			it.value = rv
		}
		it.bucket = bucket
		it.i = i + 1
		return
	}
	b = b.overflow(t)
	i = 0
	goto next
}
```

å½“ä¸Šè¿°å‡½æ•°å·²ç»éå†äº†æ­£å¸¸æ¡¶åï¼Œä¼šé€šè¿‡ [`runtime.bmap.overflow`](https://draveness.me/golang/tree/runtime.bmap.overflow) éå†å“ˆå¸Œä¸­çš„æº¢å‡ºæ¡¶ã€‚

![](../image/2020-01-17-15792766877646-golang-range-map-and-buckets.png)

ç®€å•æ€»ç»“ä¸€ä¸‹å“ˆå¸Œè¡¨éå†çš„é¡ºåºï¼Œé¦–å…ˆä¼šé€‰å‡ºä¸€ä¸ªç»¿è‰²çš„æ­£å¸¸æ¡¶å¼€å§‹éå†ï¼Œéšåéå†æ‰€æœ‰é»„è‰²çš„æº¢å‡ºæ¡¶ï¼Œæœ€åä¾æ¬¡æŒ‰ç…§ç´¢å¼•é¡ºåºéå†å“ˆå¸Œè¡¨ä¸­å…¶ä»–çš„æ¡¶ï¼Œç›´åˆ°æ‰€æœ‰çš„æ¡¶éƒ½è¢«éå†å®Œæˆã€‚
