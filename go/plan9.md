# plan9汇编

## 1、获取go编译后的汇编代码

1）使用反汇编工具

```shell
# 编译并生成可执行文件
# -gcflags选项用于传递给go语言编译器的参数。-N和-l是传递给编译器的两个参数，-N禁用了优化，-l禁用了内联，这两个选项通常在进行调试时使用，因为它们可以生成的二进制文件包含更多的调试信息。
# -ldflags选项用于传递给Go语言链接器的参数。在这里，-compressdwarf=false告诉链接器不要压缩dwarf调试信息，也是为了在调试时获取更多的信息。
go build -gcflags "-N -l" -ldflags=-compressdwarf=false -o main.out main.go
# go语言的反汇编工具来反汇编可执行文件
go tool objdump -s "main.main" main.out > main.S
```

2）使用compile工具

```shell
# 编译go源代码，使用-S选项生成汇编语言输出
go tool compile -S main.go
```

3）使用构建命令

```shell
# 使用构建命令，增加-gcflags选项向go的编译器传递参数， -S是gcflags的参数，会让编译器输出源代码对应的汇编语言代码
go build -gcflags -S main.go
```



## 2、指令

### 1）flag列表

DUPOK：链接器可以接受多个具有相同名称的全局符号。

| 名称     | 说明                                                         | 使用场景                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| NOPROF   | 不要分析标记的协程                                           | 这个标志已经被弃用                                           |
| DUPOK    | 链接器可以接受多个具有相同名称的全局符号。在链接阶段使用，影响链接器的行为。 | 1、当有多个包含相同全局符号的包时。2、当使用cgo，并且C代码包含很多的具有相同名称的全局符号。 |
| NOSPLIT  | 不要插入堆栈检查前导码。指示编译器不要在此函数上插入堆栈溢出检查的指令。 | 因为在某些情况下，插入这样的检查可能会导致问题，或者知道它是不必要的。这样可以提高函数性能。 |
| RODATA   | 存储只读数据，这些数据在程序运行期间不能被修改。             | 常量const通常放在RODATA段                                    |
| NOPTR    | 某个数据或者函数不应该包含任何指针。                         | Go的垃圾回收器需要知道哪些内存位置包含指针，以便正确地回收未使用的内存。如果一个数据或函数被标记为NOPTR，那么垃圾回收器就会忽略它，不会尝试在那里查找指针。这个指令通常用在一些特殊的情况下，比如当需要创建一个不包含任何指针的数据结构，或者需要创建一个函数，这个函数的参数和返回值都不包含指针。 |
| WRAPPER  | 这是一个包装函数，不应视为禁用“恢复”。                       |                                                              |
| NEEDCTXT | 该函数使用其传入的上下文寄存器。                             |                                                              |
| TLSBSS   | 分配一个线程本地存储字并存储相对于该字的偏移量该变量中线程本地存储的线程本地基址。 |                                                              |
| NOFRAME  | 不要插入为此函数分配堆栈帧的指令。                           | 仅对声明帧大小为0的函数有效。这就要求函数内部不能有局部变量。 |

REFLECTMETHOD：函数可以调用reflect.Type.Method或reflect.Type.MethodByName。

TOPFRAME：函数位于调用堆栈的顶部。调用堆栈展开器应该停止在这个函数中。

### 1）DATA

定义：全局数据符号由以DATA指令开头的序列。全局数据符号由一系列以DATA指令和一个GLOBAL指令定义。每个DATA指令初始化相应内存，未明确初始化的内存为零

示例：

```plan9
DATA divtab<>+0x00(SB)/4, $0xf4f8fcff  // 表示的是divtab<>在0偏移处有一个4字节大小的值，0xf4f8fcff
DATA divtab<>+0x04(SB)/4, $0xe6eaedf0  // 以4递增
...
DATA divtab<>+0x3c(SB)/4, $0x81828384
GLOBL divtab<>(SB), RODATA, $64 // 表示给变量divtab<>加了一个flag RODATA，表示里边存的是只读变量，最后的64表示这个变量占用了64字节的空间。

GLOBL runtime·tlsoffset(SB), NOPTR, $4 // 这个flag NOPTR 表示这个变量中存的不是指针
```

### 2）TEXT

```
// $8表示frame size，通常frame size的构成都是形如$24-8，表示这个TEXT block运行的时候需要占用24字节空间，参数和返回值要额外占用8字节空间（这8字节占用的是调用方栈帧里的空间）
// 如果有NOSPLIT这个flag，则可以忽略参数和返回值占用的空间
// 运行的时候需要占用8字节空间
TEXT runtime·profileloop(SB),NOSPLIT,$8
	MOVQ	$runtime·profileloop1(SB), CX // MOV指令有好几种后缀MOVB MOVW MOVL MOVQ分别对应的是1字节、2字节、4字节、8字节
	MOVQ	CX, 0(SP)
	CALL	runtime·externalthreadhandler(SB)
	RET
```



## 3、运行时协调

为保证垃圾回收正确运行，在大多数栈帧中，运行时必须知道所有全局数据的指针。Go编译器会将这部分信息耦合到Go源码文件中，但汇编程序必须进行显式定义。

被标记为NOPTR标志的数据符号会视为不包含指向运行时分配数据的指针。带有RODATA标志的数据符号在只读存储器中分配，因此被隐式标记为NOPTR。总大小小于指针的数据符号也被视为隐式标记NOPTR。在一份汇编源文件中是无法定义包含指针的符号的，因此这种符号必须定义在Go源文件中。一个良好的经验法则是RODATA在Go中定义所有非符号而不是在汇编中定义。

每个函数还需要注释，在其参数，结果和本地堆栈框架中给出实时指针的位置。对于没有指针结果且没有本地堆栈帧或没有函数调用的汇编函数，唯一的要求是在同一个包中的Go源文件中为函数定义为Go原型。汇编函数的名称不能包含名称组件（例如，syscall包中的函数Syscall应使用名称Syscall而不是syscall.Syscall其TEXT指令中的等效名称）。对于更复杂的情况，需要显式注释。这些注释使用标准#include文件中定义的伪指令funcdata.h。

如果函数没有参数且没有结果，则可以省略指针信息。这是由一个参数大小$n-0注释指示TEXT对指令。



## 4、寄存器

plan9的通用寄存器包括:

AX BX CX DX DI SI BP SP R8 R9 R10 R11 R12 R13 R14 PC

伪寄存器：

由工具链维护的虚拟寄存器

| 虚拟寄存器名称                | 含义               | 描述                                                         |
| ----------------------------- | ------------------ | ------------------------------------------------------------ |
| FP，Frame Pointer             | 帧指针             | 一个指向当前函数调用栈帧的固定位置的寄存器或变量，通常用于访问函数的局部变量和参数，在调试，异常处理和支持递归函数调用时有巨大作用。 |
| 参数和本地PC，Program Counter | 程序计数器         | 逻辑上的PC                                                   |
| 跳转和分支SB，Static Base     | 静态基指针         | 跳转和分支通常使用一个基址寄存器来计算目标地址，这个寄存器被称为SB。静态基址在编译时或链接时确定，适用于全局变量、静态变量和常量数据。动态基址在运行时确定，适用于局部变量和动态分配的内存。 |
| 全局符号SP，Stack Pointer     | 当前栈帧开始的地方 |                                                              |

所有用户定义的符号都作为偏移量写入伪寄存器FP和SB中。

汇编代码中需要表示用户定义的符号时，可以通过SP与偏移还有变量名的组合，如x-8(SP)。x是变量名。



## 5、寻址模式

plan9支持如下寻址模式

| R0             | 数据寄存器                                                   |
| :------------- | ------------------------------------------------------------ |
| A0             | 地址寄存器                                                   |
| F0             | 浮点寄存器                                                   |
| CAAR，CACR等   | 特殊名字                                                     |
| $con           | 常量                                                         |
| $fcon          | 浮点数常量                                                   |
| name + o(SB)   | 外部符号                                                     |
| name<> + o(SB) | 局部符号                                                     |
| name + o(SP)   | 自动符号                                                     |
| name + o(FP)   | 实际参数                                                     |
| $name + o(SB)  | 外部地址                                                     |
| $name<>+o(SB)  | 局部地址                                                     |
| (A0)+          | 间接后增量                                                   |
| -(A0)          | 间接前增量                                                   |
| o(A0)          | **A0**：基址寄存器，通常用于存储一个内存地址。**o**：偏移量，可以是一个常量或立即数。有效地址 = 基址寄存器的内容 + 偏移量 |
| o()(R0.s)      | 用于指定一个基址寄存器（R0）和一个偏移量（o）来访问存储在内存中的数据。.s表示大小 |

symbol+offset(SP)引用函数的局部变量，offset的合法取值是[-framesize, 0]，局部变量都是8字节，那么第一个局部变量就可以用localvar0-8(SP)来表示。

如果是symbol+offset(SP)形式，则表示伪寄存器SP

如果是offset(SP)则表示硬件寄存器SP

<span style='color:red'>LOCK前缀确保接下来的指令是原子的，意味着该指令在执行期间不会被其他处理器中断。</span>
