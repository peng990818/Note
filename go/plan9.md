# plan9汇编

## 1、获取go编译后的汇编代码

1）使用反汇编工具

```shell
# 编译并生成可执行文件
# -gcflags选项用于传递给go语言编译器的参数。-N和-l是传递给编译器的两个参数，-N禁用了优化，-l禁用了内联，这两个选项通常在进行调试时使用，因为它们可以生成的二进制文件包含更多的调试信息。
# -ldflags选项用于传递给Go语言链接器的参数。在这里，-compressdwarf=false告诉链接器不要压缩dwarf调试信息，也是为了在调试时获取更多的信息。
go build -gcflags "-N -l" -ldflags=-compressdwarf=false -o main.out main.go
# go语言的反汇编工具来反汇编可执行文件
go tool objdump -s "main.main" main.out > main.S
```

2）使用compile工具

```shell
# 编译go源代码，使用-S选项生成汇编语言输出
go tool compile -S main.go
```

3）使用构建命令

```shell
# 使用构建命令，增加-gcflags选项向go的编译器传递参数， -S是gcflags的参数，会让编译器输出源代码对应的汇编语言代码
go build -gcflags -S main.go
```



## 2、指令

### 1）flag列表

DUPOK：链接器可以接受多个具有相同名称的全局符号。

| 名称     | 说明                                                         | 使用场景                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| NOPROF   | 不要分析标记的协程                                           | 这个标志已经被弃用                                           |
| DUPOK    | 链接器可以接受多个具有相同名称的全局符号。在链接阶段使用，影响链接器的行为。 | 1、当有多个包含相同全局符号的包时。2、当使用cgo，并且C代码包含很多的具有相同名称的全局符号。 |
| NOSPLIT  | 不要插入堆栈检查前导码。指示编译器不要在此函数上插入堆栈溢出检查的指令。 | 因为在某些情况下，插入这样的检查可能会导致问题，或者知道它是不必要的。这样可以提高函数性能。 |
| RODATA   | 存储只读数据，这些数据在程序运行期间不能被修改。             | 常量const通常放在RODATA段                                    |
| NOPTR    | 某个数据或者函数不应该包含任何指针。                         | Go的垃圾回收器需要知道哪些内存位置包含指针，以便正确地回收未使用的内存。如果一个数据或函数被标记为NOPTR，那么垃圾回收器就会忽略它，不会尝试在那里查找指针。这个指令通常用在一些特殊的情况下，比如当需要创建一个不包含任何指针的数据结构，或者需要创建一个函数，这个函数的参数和返回值都不包含指针。 |
| WRAPPER  | 这是一个包装函数，不应视为禁用“恢复”。                       |                                                              |
| NEEDCTXT | 该函数使用其传入的上下文寄存器。                             |                                                              |
| TLSBSS   | 分配一个线程本地存储字并存储相对于该字的偏移量该变量中线程本地存储的线程本地基址。 |                                                              |
| NOFRAME  | 不要插入为此函数分配堆栈帧的指令。                           | 仅对声明帧大小为0的函数有效。这就要求函数内部不能有局部变量。 |

REFLECTMETHOD：函数可以调用reflect.Type.Method或reflect.Type.MethodByName。

TOPFRAME：函数位于调用堆栈的顶部。调用堆栈展开器应该停止在这个函数中。

### 1）DATA

定义：全局数据符号由以DATA指令开头的序列。全局数据符号由一系列以DATA指令和一个GLOBAL指令定义。每个DATA指令初始化相应内存，未明确初始化的内存为零

示例：

```plan9
DATA divtab<>+0x00(SB)/4, $0xf4f8fcff  // 表示的是divtab<>在0偏移处有一个4字节大小的值，0xf4f8fcff
DATA divtab<>+0x04(SB)/4, $0xe6eaedf0  // 以4递增
...
DATA divtab<>+0x3c(SB)/4, $0x81828384
GLOBL divtab<>(SB), RODATA, $64 // 表示给变量divtab<>加了一个flag RODATA，表示里边存的是只读变量，最后的64表示这个变量占用了64字节的空间。

GLOBL runtime·tlsoffset(SB), NOPTR, $4 // 这个flag NOPTR 表示这个变量中存的不是指针
```

### 2）TEXT

```
// $8表示frame size，通常frame size的构成都是形如$24-8，表示这个TEXT block运行的时候需要占用24字节空间，参数和返回值要额外占用8字节空间（这8字节占用的是调用方栈帧里的空间）
// 如果有NOSPLIT这个flag，则可以忽略参数和返回值占用的空间
// 运行的时候需要占用8字节空间
TEXT runtime·profileloop(SB),NOSPLIT,$8
	MOVQ	$runtime·profileloop1(SB), CX // MOV指令有好几种后缀MOVB MOVW MOVL MOVQ分别对应的是1字节、2字节、4字节、8字节
	MOVQ	CX, 0(SP)
	CALL	runtime·externalthreadhandler(SB)
	RET
```



## 3、运行时协调

为保证垃圾回收正确运行，在大多数栈帧中，运行时必须知道所有全局数据的指针。Go编译器会将这部分信息耦合到Go源码文件中，但汇编程序必须进行显式定义。

被标记为NOPTR标志的数据符号会视为不包含指向运行时分配数据的指针。带有RODATA标志的数据符号在只读存储器中分配，因此被隐式标记为NOPTR。总大小小于指针的数据符号也被视为隐式标记NOPTR。在一份汇编源文件中是无法定义包含指针的符号的，因此这种符号必须定义在Go源文件中。一个良好的经验法则是RODATA在Go中定义所有非符号而不是在汇编中定义。

每个函数还需要注释，在其参数，结果和本地堆栈框架中给出实时指针的位置。对于没有指针结果且没有本地堆栈帧或没有函数调用的汇编函数，唯一的要求是在同一个包中的Go源文件中为函数定义为Go原型。汇编函数的名称不能包含名称组件（例如，syscall包中的函数Syscall应使用名称Syscall而不是syscall.Syscall其TEXT指令中的等效名称）。对于更复杂的情况，需要显式注释。这些注释使用标准#include文件中定义的伪指令funcdata.h。

如果函数没有参数且没有结果，则可以省略指针信息。这是由一个参数大小$n-0注释指示TEXT对指令
