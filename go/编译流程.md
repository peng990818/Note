# 编译流程



### 第一阶段：词法和语法分析

源码参见：`cmd/compile/internal/syntax`（词法分析器，解析器，语法树）

在第一阶段，源代码先被token化即词法分析，语法解析，并为每个源构造语法树文件。每个语法树都是相应源文件的精确表示对应源的各种元素节点，如表达式，声明和陈述。语法树还包括位置信息用于错误报告和调试信息的创建。



### 第二阶段：语义分析

源码参见：`cmd/compile/internal/gc`（类型检查，AST变换）

AST：抽象语法树，AST变换涉及对代码的结构进行修改，以实现优化、代码生成或其他目的。通过对AST进行变换，可以在不改变代码语义的前提下优化代码，或者将代码转换为另一种形式。

对AST进行类型检查，第一步是名称解析和类型推断，它们确定哪个对象属于哪个标识符，以及每个表达式具有的类型。类型检查包括某些额外的检查，例如“声明和未使用”以及确定函数是否终止。

在AST上也进行了某些转换。一些节点基于类型信息被细化，例如从算术加法节点类型分割的字符串添加，还有死代码消除，函数调用内联和转义分析。

语义分析的过程包含几个重要操作：逃逸分析、变量捕获，函数内联，闭包处理。



### 第三阶段：SSA生成

源码参见

- `cmd/compile/internal/gc` (转换为SSA)
- `cmd/compile/internal/ssa` (SSA 传递与规则)

SSA：静态单赋值形式是一种中间表示，用于编译器优化。<span style='color:red'>SSA的核心思想是每个变量在代码中只赋值一次，这使得许多编译器优化变得更简单和高效。</span>

在此阶段，AST将转换为SSA，在转换期间，将应用函数内联，会根据具体情况用大量优化的代码替换。

某些节点在此期间也被降级为更简单的组件，因此编译器的其余部分可以使用它们，比如，内存复制替换为内存移动，并且范围循环被重写为for循环。

应用一系列与机器无关的传递和规则。这些不涉及任何单个计算机体系结构，因此可以在所有GAOARCH变体上运行。这些通用过程的一些示例包括消除死代码，删除不需要的零检查以及删除未使用的分支。通用重写规则主要涉及表达式，例如用常量值替换某些表达式，以及优化乘法和浮点运算。



### 第四阶段：机器码生成

源码参见

- `cmd/compile/internal/ssa` (底层SSA和架构特定的传递)
- `cmd/internal/obj` (生成机器码)

传递将通用值重写为其机器特定的变体。例如在amd64存储器操作数上是可能的，因此可以组合许多加载存储操作。

较低的通道运行所有特定于机器的重写规则，因此它当前也应用了大量优化。

一旦SSA降低并且更加特定于目标体系结构，就会运行最终的代码优化过程，这包括另一个死代码消除传递，移动值更接近它们的使用，删除从未读取的局部变量，以及寄存器分配。

其他重要工作包括堆栈框架布局，将堆栈偏移分配给局部变量，以及指针活动分析，计算每个gc安全点上的堆栈帧指针。

在SSA生成阶段结束时，GO函数已转换为一系列obj.Prog指令，它们会被传递给装载器，将它们转换为机器代码并写出最终的目标文件。目标文件还将包含反射数据，导出数据和调试信息。
