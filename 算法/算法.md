# 算法

## 一、循环不变式

初始化：在循环的第一轮迭代开始之前，应该是正确的。

保持：如果在循环的某一次迭代开始之前它是正确的，那么在下一次迭代开始之前，它也应该保持正确。

终止：当循环结束时，不变式给了我们一个有用的性质，它有助于表明算法是正确的。



## 二、算法分析

输入规模：与具体的问题有关。最自然的度量标准是输入中的元素个数。

运行时间：在特定输入时，所执行的基本操作数。

算法的时间复杂度，一般考察算法的最坏情况运行时间

- 一个算法的最坏情况运行时间是在任何输入下运行时间的一个上界。知道了这一点，就能确保算法的运行时间不会比这一时间更长，也就不需要对运行时间做某种复杂的猜测，并期望它不会变的更坏。
- 对于某些算法来说，最坏情况还是出现的相当频繁的。
- 大致上看来，平均情况通常与最坏情况一样差。



## 三、算法设计

1、增量：处理好子问题，然后不断追加处理。

2、分治：有很多算法在结构上是递归的，为了解决一个给定的问题，算法要一次或多次地递归调用其自身来解决相关的子问题，这些算法通常采用分治策略，将原问题划分成n个规模较小而结构与原问题相似地子问题，递归地解决这些子问题，然后在合并其结果，就得到原问题的解。

​	分治模式在每一层递归上都有三个步骤：

- 分解：将原问题分解成一系列子问题。
- 解决：递归地解决各个子问题。若子问题足够小，则直接求解。
- 合并：将子问题的结果合并成原问题的解。



## 四、应用模版

### 1、单调栈

​	含义：利用一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都能保持有序（单调递增或者递减）。

​	单调栈的模版

```go
// 下一个更大的数
func nextGreaterElement(nums []int) []int {
  res := make([]int, len(nums))
  stack := make([]int, 0)
  for i:=len(nums)-1;i>=0;i-- {
    // 将两个较大元素的中间元素排除
    for len(stack) > 0 && nums[i] >= stack[len(stack)-1] {
      stack = stack[:len(stack)-1]
    }
    if len(stack) > 0 {
      res[i] = stack[len(stack)-1]
    } else {
      res [i] = -1
    }
    stack = append(stack, nums[i])
  }
  return res
}
```

### 2、代换法

1）猜测解的形式。

2）用数学归纳法找出使解真正有效的常数。

注意：只能用于解的形式很容易猜的情形。

### 3、递归树方法

在递归树中，每一个结点都代表递归函数调用集合中一个子问题的代价。

### 4、主方法

T(n) = aT(n/b)+f(n)   （a>=1, b > 1是常数，f(n)是一个渐近正的函数。

递归式描述了将规模为n的问题划分为a个子问题的算法的运行时间，每个子问题规模为n/b，a和b都是正常数。a个子问题被分别递归地解决，时间各为T(n/b)。划分原问题和合并答案的代价由函数f(n)描述。
