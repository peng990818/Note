# GO语言

## 1、map相关

### 1）什么是哈希表？以及哈希冲突的处理？

哈希表（Hash Table），也称为散列表，是一种数据结构，用于以非常快的速度存储和查找数据。哈希表通过一种称为“哈希函数”的方法，将键（key）映射到存储数据的数组的某个位置（通常称为桶或槽），从而快速找到数据。

哈希表的核心有两部分，一个是哈希函数，另一个就是冲突处理。

哈希函数将键映射为一个整数索引，用于确定存储的位置，理想情况下，不同的键会得到不同的索引，避免冲突。

在现实情况下，几乎一定会发生冲突，因为输入域是无穷大，输出域是则是有限的。所以哈希表的第二个核心就是在于解决哈希冲突。

常见的处理方法有两种：

- 开放地址法：在发生冲突时，通过线性探测、二次探测或双重哈希等方法寻找下一个空闲槽。
- 链地址法：在数组的每个槽中存储一个链表（或其他数据结构），所有映射到该槽的键都放入这个链表中。

哈希表的查找、插入和删除操作在平均情况下是 O(1) 的时间复杂度，也就是常数时间。这是因为哈希表通过哈希函数直接找到存储位置，无需遍历数据结构。

### 2）哈希表的优缺点和使用场景

优点：查找，插入和删除效率高，适合用作字典、缓存等需要快速访问的场景。

缺点：哈希函数如果设计不当会导致大量冲突，降低效率。哈希表在存储数据时可能需要更多内存，以减少冲突。

使用场景：

哈希表可以用来实现缓存，以加速数据访问。也可以用来做数据库索引，哈希索引可以加速数据库查询。

### 3）Go 的map是如何实现的？

Go 语言的 map 使用哈希表来实现，通过将键（key）哈希成一个整数，然后将这个整数用来定位存储位置。每个 map 都由多个桶（bucket）组成，而每个桶可以存储多个键值对，以优化空间和查找效率。map 的查找、插入和删除在平均情况下都是 O(1) 的复杂度。

Go 通过哈希函数将键映射到一个哈希值。这个哈希值决定了键在整个 map 中的存储位置（桶位置）。哈希函数会根据键的类型生成不同的哈希值，常见类型如字符串、整数等都有特定的哈希算法。为了增强安全性和随机性，每次程序运行时，Go 会随机生成一个哈希种子，这样可以防止攻击者预测哈希值并引发冲突。

Go 的哈希表分为多个桶，每个桶可以存储多个键值对。每个桶的结构如下：

​	•	**数据槽位**：一个桶可以存储多达 8 个键值对。

​	•	**高 8 位哈希值**：每个键的哈希值的高 8 位会存储在桶中，用来帮助快速查找和筛选。

高8位哈希的作用：

​	•	**加速桶内查找**：在查找键值时，Go 会首先比较桶中存储的高 8 位哈希值，只有当高 8 位匹配时才进行完整的键值比较。这一步筛选减少了不必要的键值对比操作，提升了查找效率。

​	•	**冲突处理优化**：高 8 位哈希值可以帮助减少桶内冲突带来的查找开销，使得哈希表在较高负载时仍能保持较好的性能。

冲突的处理方面，Go 使用**链地址法**和**开放寻址法**的结合来处理冲突：

​	•	**链地址法（Separate Chaining）**：如果桶中的 8 个位置都已占满，则 Go 会使用溢出桶来存储新数据。

​	•	**溢出桶**：当桶内冲突达到一定程度时，会创建额外的溢出桶，链在原桶后面来存储更多键值对。

在 Go 的 map 中，键类型必须是可比较的（comparable），以便进行哈希运算和键值比对。例如，整数、字符串、布尔值、指针、结构体（字段也必须是可比较的）等可以作为键，而切片、映射和函数等不可比较的数据类型不能作为键。

### 4）详细介绍一下go map的查找过程。

首先计算哈希值，当需要在 map 中查找一个键时，Go 首先会对该键计算哈希值。哈希函数返回一个整数哈希值 hash，它在当前 map 的哈希桶总数（buckets）的基础上转换为桶索引。

然后定位到具体的桶，桶包含 8 个键值对槽位。每个槽位可以存储一个键值对及其对应的 tophash，即每个桶最多存储 8 个键值对。

接下来检查tophash，每个桶的头部有一个 tophash 数组，长度为 8，用于存储桶中每个键哈希值的高 8 位。tophash 在查找中的作用是快速过滤掉不匹配的键，避免不必要的键比较。查找时，会将目标键的哈希值高 8 位与桶中的每个 tophash 进行比较。如果某个槽位的 tophash 与目标键的哈希值高 8 位匹配，则继续比较键本身（逐字节比较）。

如果 tophash 匹配，接下来对实际的键进行比较以确保找到正确的键。这是因为不同键可能具有相同的 tophash，所以 tophash 匹配只是作为初步过滤。在这个步骤中，Go 会进行完整的键比较，确保键的内容完全一致。如果键匹配成功，那么查找过程结束，返回该键对应的值。如果键不匹配，继续检查当前桶中的下一个槽位。

由于每个桶最多只能存储 8 个键值对。当桶已满且继续插入更多键值对时，Go 会为该桶分配溢出桶。这些溢出桶形成一个链表，与主桶一起构成一个桶链表。在查找过程中，如果主桶中没有找到匹配的 tophash 或键，Go 会沿着溢出桶链表继续查找，重复 tophash 检查和键比较的步骤，直到找到目标键或链表遍历结束。

### 5）详细介绍一下go map的插入过程

首先，Go 通过哈希函数将键转换成一个哈希值。这一步返回一个整数 hash，用来决定键值对存放的桶位置。

定位到桶后，检查是否有空槽位：

​	•	tophash **检查**：每个槽位的 tophash 存储键的哈希值的高 8 位，用于快速定位和过滤。对于插入操作，遍历当前桶的所有槽位，检查 tophash 是否为零（表示该槽位为空），若找到空槽位，将键值对插入该位置。

​	•	**键覆盖**：如果 tophash 值相同且键也相同，则直接覆盖该槽位的值。这是因为在哈希表中，键是唯一的，当找到相同的键时应覆盖旧值。

当桶中所有 8 个槽位都已占用时（即当前桶已满），Go 会创建一个溢出桶，将其链接到当前桶。此时：

​	•	插入键值对到新建的溢出桶。

​	•	如果溢出桶链条过长，可能会导致性能下降。在极端情况下，Go 会触发 map 的扩容。

当桶的使用密度过高时，Go 会进行 map 的扩容操作。扩容时：

​	•	扩容通常会将 map 的桶数加倍。

​	•	重新计算哈希值，并重新分配键值对，以均匀分布在新的桶中。

​	•	此过程称为再哈希（rehashing），用以减少冲突，提升查找性能。

### 6）详细介绍一下go map的扩容过程

首先介绍一下触发扩容的条件

​	•	**负载因子过高**：即桶中槽位被使用的比例过大。Go 语言中的 map 会动态监控使用情况，当负载因子超过某个阈值时，就会触发扩容。

​	•	**键值对插入导致桶链长度过长**：当一个桶及其溢出桶链条变得过长（达到 4 个或更多溢出桶）时，也会触发扩容。

​	•	**删除大量元素**：在扩容中会删除标记删除的键值对，减少空间浪费。

扩容的过程分为以下几步

当触发扩容时，map 会将桶数组大小加倍（bucket 数量 * 2）。这会生成一个新的桶数组 newBuckets。新的桶数量 newB 是旧桶数量 oldB 的 2 倍，确保在新的数组中可以均匀分布元素，减少冲突。

扩容过程中，需要将旧桶中的所有键值对重新分布到新的桶数组中。这是通过对每个键重新计算哈希值并确定其在新桶数组中的位置来完成的。

​	•	Go map 使用二进制位操作重新计算每个键的哈希值，以确定它在新桶数组中的位置。

​	•	map 中的桶索引由 hash % newB 计算得出。对于每个旧桶中的键值对，将根据其哈希值在 newBuckets 中的相应位置插入。

​	•	Go 1.8 之后，Go 使用 **渐进式扩容**（incremental resizing）技术：即在新数据写入 map 时，逐步迁移旧桶中的键值对到新桶，逐步减少对旧桶的依赖。

​	•	扩容时 map 会维护两个桶数组：旧桶数组和新桶数组。此时，读写操作可以同时在两个桶数组中进行。每次插入或删除元素时，都会迁移一部分旧桶的数据。

渐进式扩容的实现

Go 的 map 采用了渐进式扩容，以避免一次性迁移所有键值对带来的性能抖动。渐进式扩容的实现过程如下：

​	1.	**启动扩容**：创建新的桶数组并设置 map 的 oldbuckets 指向旧桶数组。

​	2.	**分段迁移**：每次对 map 进行插入、删除等修改操作时，会自动迁移一定数量的旧桶中的键值对。

​	3.	**迁移策略**：从 oldbuckets 中按顺序迁移桶。迁移时将每个旧桶的键值对重新分配到 newBuckets 中。

​	4.	**标记完成**：所有旧桶都迁移完成后，将 oldbuckets 设置为 nil，从而结束扩容过程。

分裂迁移策略

Go 的 map 会在迁移过程中将旧桶分裂成两个新的桶。每个旧桶中的元素将根据其哈希值的最低位被分配到 newBuckets 中的新位置上。

迁移中的读写操作处理

由于 Go 采用渐进式扩容，因此在扩容过程中，可能会发生读写操作。Go 使用以下方法来确保读写的一致性：

​	•	**查找操作**：查找时，map 会优先从 newBuckets 中查找键值对；如果未找到，则会在 oldbuckets 中查找。这样可以保证迁移期间数据的可见性。

​	•	**写操作**：在迁移过程中，如果向 map 中插入新的键值对，则会将新的键值对直接插入到 newBuckets 中。

### 7）详细介绍一下go map的删除过程

delete() 操作的第一步是根据 key 的哈希值找到目标 bucket。查找 bucket 的过程如下：

​	1.	通过哈希函数计算 key 的哈希值，并根据哈希值定位到对应的 bucket。

​	2.	在 bucket 的 tophash 数组中找到与 key 高位哈希值匹配的条目。

​	3.	若目标 bucket 已满并且未找到对应的 key，会继续检查该 bucket 的溢出桶。

找到目标 bucket 后，删除操作会尝试将该键值对从 bucket 中移除。步骤如下：

​	1.	**清除** tophash：将对应 key 的 tophash 值设置为 empty，表示该位置为空。

​	2.	**清除** key **和** value：将 key 和 value 的存储位置清零，表示删除该键值对。

​	3.	**处理溢出桶**：如果该 bucket 是溢出桶，需要处理关联的前后 bucket，以便在未来的查询或删除中跳过这些空桶。

在实际的 map 删除过程中，Go 不会立即从内存中删除该键值对，而是通过设置 tophash 为特殊标记，标识该位置为空或被删除。这样做的好处是避免了频繁的内存分配和释放，有助于提高 map 的性能。

​	•	**标记为无效**：删除后，bucket 的槽位会被标记为空闲，但实际数据仍然留在原地。

​	•	**避免立即释放**：这样做可以提高效率，避免频繁的内存操作，但会导致一定的内存占用。

大量删除，会触发等量扩容

### 8）详细介绍一下Go range遍历map的过程

首先初始化迭代器，根据随机种子决定当前遍历的顺序，确保每次迭代的遍历顺序是随机的。

**遍历** bucket **中的每个键值对**：

​	•	遍历 bucket 时，会检查 tophash 是否有效，以确认该槽位是否有键值对。

​	•	如果 tophash 表示为空或删除的槽位，跳过该位置。

​	•	若槽位有效，读取 key 和 value，并将它们传递到 for range 的循环变量中。

**处理** overflow bucket：

​	•	若 bucket 满且有溢出桶（overflow bucket），则继续访问 overflow bucket 链表。

​	•	通过循环链表，按序遍历 overflow bucket，直到遍历完所有溢出桶。

•	遍历过程中会记录已访问的条目数。

​	•	每次遍历完一个 bucket 后，更新 hmapIterator 中的 bucket 索引，继续到下一个 bucket。

**检查并发写操作**：

​	•	map 不允许在遍历过程中修改（并发写入），所以在遍历前会保存 map 的修改次数。

​	•	如果在遍历过程中 map 的修改次数发生变化，则会引发并发错误，终止遍历。

### 9）Go语言中如何比较两个map是否相等？

在 Go 语言中，直接使用 `==` 操作符是无法比较两个 `map` 是否相等的。需要手动编写代码来进行比较。最常见的方法是先比较两个 `map` 的长度，如果长度相等，再逐一比较每个键值对。

使用`reflect.DeepEqual`，尽管使用此函数比较 `map` 会有性能开销。

为什么不能直接使用==操作符？

Go语言中的map是引用类型，直接使用==只能比较map的引用地址是否相同，而不能对比内容，但是可以用来检查map是否为nil。

### 10）Go语言中，使用值为nil的map会发生什么？

对于 `nil` map：

- 不能直接赋值，这会导致运行时错误
- 可以进行读取操作，返回的是该类型的零值
- `len` 返回 0
- 不能进行 key 的删除操作，这会导致运行时错误

### 11）Go map的一些基础知识

1）**`map` 的内部实现**：Go 语言中的 `map` 底层是通过哈希表实现的，因此访问速度非常快，但也因此无法保证顺序。

2）**零值调度**：对于零值的 `map`，也就是在未初始化的情况下，直接操作会导致崩溃。实际开发中应注意初始化。

3）**键的类型**：Go 语言中的 `map` 允许键的类型可以是所有可比较类型。一般常用的是字符串、整数等，因为它们的哈希计算和比较操作速度较快。

4）**并发安全**：默认情况下，`map` 不是并发安全的。在并发环境中读写 `map` 需要使用 `sync.Map` 或者加锁来保证安全。

5）**`sync.Map`**：Go 标准库 `sync` 包提供了一个并发安全的 `map`，它在高并发下性能优越，但在低并发或单线程程序中，与原生 `map` 相比略显复杂。

6）**`reflect` 包的应用**：在一些动态场景中，可能需要使用反射来操作 `map`，`reflect` 包提供了丰富的操作工具，但性能开销也比直接操作大得多。



## 2、for range

### 1）循环永动机

```go
func main() {
	arr := []int{1, 2, 3}
	for _, v := range arr {
		arr = append(arr, v)
	}
	fmt.Println(arr)
}

$ go run main.go
1 2 3 1 2 3
```

上述代码的输出意味着循环只遍历了原始切片中的三个元素，我们在遍历切片时追加的元素不会增加循环的执行次数，所以循环最终还是停了下来。

对于所有的range循环，GO语言都会在编译期将原切片或者数组赋值给一个新变量，在赋值的过程中就发生了拷贝，而又通过len关键字预先获取了切片的长度，所以在循环中追加新的元素也不会改变循环的次数。

### 2）指针

```go
func main() {
	arr := []int{1, 2, 3}
	newArr := []*int{}
	for _, v := range arr {
		newArr = append(newArr, &v)
	}
	for _, v := range newArr {
		fmt.Println(*v)
	}
}

$ go run main.go
3 3 3
```

遇到这种同时遍历索引和元素的range循环时，Go语言会额外创建一个新的变量存储切片中的元素，循环中使用的这个变量会在每一次迭代被重新赋值而覆盖，赋值时也会触发拷贝。

因为在循环中获取返回变量的地址都完全相同，所以会发生上述代码中的情况，因此当我们想要访问数组中元素所在的地址时，不应该直接获取 range 返回的变量地址 `&v2`，而应该使用 `&a[index]` 这种形式。
