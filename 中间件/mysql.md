# mysql

### 一、mysql的架构

#### 1.1 逻辑架构

<img src="../image/mysql_struct.jpg" />

第一层大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。连接管理，授权认证，安全等。

每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行。服务器会负责缓存线程，不需要为每一个新建的连接创建或销毁线程。

服务器会先进行认证（用户名、原始主机信息和密码），使用安全套接字SSL的方式连接，可以使用X.509证书认证==》然后验证该客户端是否具有执行某个特定查询的权限。

第二层包含mysql大多数的核心服务功能，比如查询解析、分析、优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

Mysql会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示优化器，影响它的决策过程。优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。

对于Select语句，在解析查询之前。服务器会先检查查询缓存，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。

第三层包含了存储引擎。存储引擎负责mysql中数据的存储和提取。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。

<span style='color:red'>存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析sql，不同存储引擎之间也不会相互通信，只是简单响应上层服务器的请求。</span>



#### 1.2 并发控制

锁策略就是在锁的开销和数据的安全性之间寻求平衡。

每种Mysql存储引擎都可以实现自己的锁策略和锁粒度。

表锁：锁定整张表。服务器会为诸如alter table之类的语句使用表锁，而忽略存储引擎的锁机制。

行级锁：可以最大程度地支持并发处理（同时也会带来最大的锁开销）。在InnoDB和XtraDB，以及其他一些存储引擎中实现了行级锁。<span style='color:red'>行级锁只在存储引擎层实现，Mysql服务器层没有实现。</span>



#### 1.3 事务

事务就是一组原子性的SQL查询，或者说是一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。

ACID

- 原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。
- 一致性：数据库总是从一个一致性的状态转换到另外一个一致性状态。
- 隔离性：通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。
- 持久性：一旦事务提交，则其所做的修改将会永久保存到数据库中。

隔离级别

SQL标准中定义了四种
